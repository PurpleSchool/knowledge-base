---
metaTitle: Использование декораторов в Python
metaDescription: Разбор декораторов в Python — синтаксис, применение, встроенные и пользовательские декораторы, примеры и типовые сценарии использования.
author: Олег Марков
title: Как использовать декораторы в Python
preview: Разберём декораторы в Python — как применять встроенные и пользовательские декораторы, синтаксис, практические примеры и сценарии использования.
---

## Введение

Декораторы в Python — это функции, которые принимают другую функцию и возвращают модифицированную или обёрнутую функцию. Они позволяют добавлять дополнительное поведение без изменения исходного кода, что делает программу более гибкой и читаемой.

В этой статье мы разберём синтаксис декораторов, как их использовать с функциями и методами, а также покажем практические примеры.

Если вы хотите детальнее изучить декораторы и паттерны их применения в Python — приходите на наш курс [Основы Python](https://purpleschool.ru/course/python-basics?utm_source=knowledgebase&utm_medium=article&utm_campaign=Kak_ispolzovat_dekoratory_v_Python). На курсе 209 уроков и 34 упражнения, AI-тренажеры для практики с кодом и задачами 24/7, решение задач с живым ревью наставника, еженедельные встречи с менторами.

## Синтаксис декораторов

Базовый декоратор выглядит так:

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        print("Перед вызовом функции")
        result = func(*args, **kwargs)
        print("После вызова функции")
        return result
    return wrapper
```

Применение декоратора:

```python
@decorator
def say_hello(name):
    print(f"Hello, {name}!")

say_hello("Alice")
```

Вывод:

```
Перед вызовом функции
Hello, Alice!
После вызова функции
```

Здесь `@decorator` заменяет `say_hello = decorator(say_hello)`.

## Декораторы с аргументами

Можно создавать декораторы, принимающие аргументы:

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")

greet("Bob")
```

Вывод:

```
Hello, Bob!
Hello, Bob!
Hello, Bob!
```

## Встроенные декораторы

* `@staticmethod` — делает метод статическим.
* `@classmethod` — метод класса, получает `cls`.
* `@property` — позволяет обращаться к методу как к атрибуту.

```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        return self._radius

c = Circle(5)
print(c.radius)  # 5
```

## Частые ошибки

* Декоратор не использует `*args` и `**kwargs` — теряются параметры функции.
* Забывают возвращать результат `func` внутри wrapper.
* Несоблюдение порядка декораторов при использовании нескольких `@`.

## Часто задаваемые вопросы

1. **Можно ли декорировать метод класса?**
   Да, и важно учитывать, что первый аргумент может быть `self` или `cls`.

2. **Можно ли декорировать функцию несколько раз?**
   Да, декораторы применяются сверху вниз, важно следить за их порядком.

3. **Можно ли создать декоратор без функции wrapper?**
   Да, если нужно просто изменить поведение функции напрямую, но чаще используют wrapper для гибкости и сохранения аргументов.

## Заключение

Декораторы позволяют добавлять функциональность функциям и методам без изменения их кода, что делает программы более чистыми и расширяемыми. Они широко используются в логировании, авторизации, кэшировании и тестировании.

Для системного изучения декораторов и паттернов их применения рекомендую пройти курс [Основы Python](https://purpleschool.ru/course/python-basics?utm_source=knowledgebase&utm_medium=article&utm_campaign=Kak_ispolzovat_dekoratory_v_Python). В первых 3 модулях уже доступно бесплатное содержание — начните погружаться в мир Python прямо сегодня.
