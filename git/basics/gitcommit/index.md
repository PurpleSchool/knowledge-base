---
metaTitle: Создание коммита в Git - полное руководство по git commit
metaDescription: Подробное объяснение команды git commit - синтаксис флаги типичные сценарии использования и практики оформления коммитов
author: Олег Марков
title: Создание коммита в Git - git commit
preview: Разберитесь как правильно создавать коммиты в Git - от базового git commit до продвинутых опций оформления сообщений истории и фиксации изменений
---

## Введение

Создание коммита в Git — это базовая операция, без которой не обходится ни один рабочий процесс разработки. Каждый коммит фиксирует состояние файлов в репозитории в конкретный момент времени. С его помощью вы можете:

- вернуться к любому из прошлых состояний кода
- понять, кто и какие изменения внес
- вести понятную историю проекта
- безопасно экспериментировать в ветках

Здесь я покажу вам, как работает команда git commit, какие у нее есть режимы, флаги и нюансы. Мы последовательно разберем путь от простого локального коммита до аккуратно оформленной истории, с которой удобно работать и вам, и вашей команде.

---

## Что такое коммит в Git и как он устроен

Прежде чем переходить к практике, полезно понять, что именно делает git commit.

В упрощенном виде коммит — это:

- снимок состояния отслеживаемых файлов (snapshot)
- ссылка на один или несколько родительских коммитов (обычно один)
- метаданные — автор, дата, сообщение коммита
- уникальный хеш (SHA-1), по которому Git идентифицирует коммит

Каждый раз, когда вы вызываете git commit, Git:

1. Берет содержимое индексированных файлов (staging area).
2. Создает новый объект-снимок (tree) и объект-коммит, который на него указывает.
3. Обновляет указатель ветки (например, main или master) на новый коммит.

Важно понимать — коммит фиксирует не «разницу» в привычном смыслe, а целостное состояние файлов. Разницы (diff) Git вычисляет на лету при сравнении двух снимков.

---

## Подготовка к первому коммиту

Перед тем как создавать коммит, вам нужно:

1. Инициализировать репозиторий.
2. Настроить имя и email автора.
3. Добавить файлы в индекс.

### Инициализация репозитория

Если вы еще не создали репозиторий Git в папке проекта, сделайте это:

```bash
git init
# Git создаст скрытую папку .git и начнет отслеживать состояние проекта
```

После этого все команды Git начнут работать в этой директории.

### Настройка имени и email

Git обязательно требует указать имя и email, чтобы записывать их в каждый коммит. Один раз настройте глобальные значения:

```bash
git config --global user.name "Ваше Имя"
git config --global user.email "you@example.com"
# Эти данные будут записываться в каждый новый коммит
```

Если хотите задать настройки только для конкретного репозитория:

```bash
git config user.name "Имя для этого репозитория"
git config user.email "email@дляпроекта.com"
# Эти данные будут применяться только в текущей папке с репозиторием
```

### Добавление файлов в индекс перед коммитом

Команда git commit фиксирует только то, что уже добавлено в индекс (staging area). Для этого используется git add.

```bash
git add main.py
# Добавляем конкретный файл в индекс

git add src/
# Добавляем все файлы из папки src и вложенных папок

git add .
# Добавляем все измененные и новые файлы в текущей директории
```

Комментарии к происходящему:

```bash
# Создаем новый файл
echo 'print("Hello")' > main.py

# Проверяем статус
git status
# Тут вы увидите main.py как "untracked file" - файл, который еще не отслеживается

# Добавляем файл в индекс
git add main.py

# Теперь git status покажет main.py в разделе "Changes to be committed"
```

---

## Базовый синтаксис git commit

Теперь давайте посмотрим базовую форму команды:

```bash
git commit -m "Сообщение коммита"
# -m задает текст сообщения коммита напрямую в командной строке
```

Пошагово пример:

```bash
echo 'print("Hello")' > main.py
git add main.py
git commit -m "Добавлен простой скрипт вывода Hello"
# Git создаст новый коммит со снимком main.py и указанным сообщением
```

Чтобы увидеть результат:

```bash
git log
# Вы увидите хеш коммита, автора, дату и сообщение
```

### Что происходит, если вызвать git commit без параметров

Когда вы вызываете:

```bash
git commit
# Без -m
```

Git откроет текстовый редактор (по умолчанию Vim, Nano или другой, в зависимости от конфигурации), чтобы вы могли написать многострочное сообщение коммита.

Схема работы:

1. В открывшемся редакторе вы вводите заголовок коммита (первая строка).
2. Оставляете пустую строку.
3. При желании добавляете подробное описание.

Пример содержимого окна редактора:

```text
Добавлена авторизация по токену

Реализована базовая авторизация по токену для API
- добавлена проверка токена в middleware
- настроена обработка ошибок с кодом 401
```

После сохранения и закрытия редактора коммит будет создан.

---

## Сообщение коммита — как писать понятно

От качества сообщений коммитов сильно зависит удобство работы с историей. Давайте разберемся, как формулировать их так, чтобы и вы сами через год поняли, что происходило, и коллегам было понятно.

### Простейшие рекомендации по сообщениям

1. Заголовок до 50–72 символов, по сути, краткий ответ на вопрос «что сделано».
2. В заголовке лучше использовать повелительное наклонение глагола  
   Пример — «Добавить проверку токена», «Исправить ошибку сериализации».
3. В теле сообщения (если оно есть) можно описать:
   - зачем вы сделали изменения
   - какие важные детали реализации стоит знать
   - есть ли побочные эффекты или ограничения

Пример команды с длинным сообщением:

```bash
git commit -m "Добавить авторизацию по токену" -m "Реализована проверка токена в middleware
Добавлен возврат 401 при некорректном или истекшем токене
Обновлена документация по API авторизации"
# Первый -m задает заголовок, второй - тело сообщения
```

Комментарии к примеру:

- первый параметр -m — короткий заголовок
- второй -m — многострочный текст  
  (переносы строки в теле сохранятся как есть)

---

## Типичный рабочий цикл: от изменений к коммиту

Давайте соберем вместе базовый рабочий сценарий.

### Шаг 1. Проверка статуса

```bash
git status
# Показывает:
# - измененные файлы (modified)
# - новые файлы (untracked)
# - файлы, уже добавленные в индекс (staged)
```

### Шаг 2. Выбор, что войдет в коммит

```bash
git add file1.py
# Добавляем только file1.py

git add src/
# Добавляем изменения во всех файлах папки src
```

### Шаг 3. Создание коммита

```bash
git commit -m "Краткое понятное описание изменений"
# Фиксируем только те файлы, которые были добавлены в индекс
```

### Шаг 4. Просмотр истории

```bash
git log --oneline
# Покажет коммиты коротко:
# <короткий хеш> <сообщение>
```

Обратите внимание — вы можете изменять множество файлов, но в один конкретный коммит попадут только те, которые вы добавили командой git add.

---

## Работа с частично подготовленными файлами (git add -p)

Иногда вы редактируете один файл, но хотите разбить изменения на несколько логических коммитов. В таких случаях удобно использовать режим по частям.

### Режим интерактивного добавления по кускам

```bash
git add -p main.py
# -p включает пошаговый выбор фрагментов изменений
```

Git покажет вам каждый фрагмент (hunk) и спросит, что с ним делать. Пример:

```text
@@ -1,3 +1,7 @@
 print("Hello")

+def greet(name):
+    print(f"Hello, {name}!")
+
 greet("World")
Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]?
# Здесь вы можете выбрать, добавлять ли этот фрагмент в индекс
```

Основные варианты ответов:

- y — добавить этот фрагмент в индекс
- n — пропустить этот фрагмент
- a — добавить этот и все последующие фрагменты
- d — пропустить этот и все последующие фрагменты
- e — вручную отредактировать фрагмент перед добавлением

Давайте посмотрим, как это может выглядеть на практике:

```bash
# Меняем в одном файле и функцию, и комментарии
# Хотим, чтобы в коммит попали только изменения логики

git add -p main.py
# Сначала выбираем только те блоки, где правится код
git commit -m "Изменена логика вычисления скидки"
# Потом добавляем визуальные правки в отдельный коммит
git add -p main.py
git commit -m "Обновлены комментарии в коде"
```

Такой подход делает историю чище и понятнее.

---

## Важные флаги git commit и когда их использовать

Команда git commit имеет много полезных опций. Давайте разберем основные, которые чаще всего применяются в реальной работе.

### Флаг -a или --all — коммит всех отслеживаемых изменений

```bash
git commit -am "Сообщение"
# Короткая форма: -a и -m вместе
```

Что делает -a:

- автоматически добавляет в индекс все измененные и удаленные файлы, которые уже отслеживаются Git
- не добавляет новые файлы, которые еще не были добавлены через git add

На практике это сокращенный вариант двух команд:

```bash
git add -u
# Добавляет все измененные и удаленные отслеживаемые файлы
git commit -m "Сообщение"
# Фиксирует их
```

С осторожностью используйте -a на больших изменениях. Лучше понимать, какие файлы попадают в коммит.

### Флаг --amend — исправление последнего коммита

Иногда после коммита вы замечаете:

- опечатку в сообщении
- забытый файл, который тоже должен был попасть в коммит
- мелкую правку, связанную с только что сделанным изменением

В этом случае можно «переписать» последний коммит вместо создания нового.

#### Изменение только сообщения коммита

```bash
git commit --amend -m "Новое сообщение для последнего коммита"
# Последний коммит будет перезаписан с новым текстом
```

#### Добавление забытых файлов в последний коммит

```bash
# Дописываем код в забытый файл
git add missing_file.py
# Добавляем его в индекс

git commit --amend --no-edit
# --no-edit говорит - не менять текст сообщения
# В итоге последний коммит будет содержать и старые, и новые изменения
```

Важно помнить:

- git commit --amend меняет историю — старый коммит заменяется новым, с другим хешем
- не стоит делать amend, если вы уже отправили этот коммит на общий удаленный репозиторий и другие разработчики могли его забрать

### Флаг --no-edit — сохранить сообщение при изменении коммита

Мы уже использовали его выше:

```bash
git commit --amend --no-edit
# Переписывает последний коммит, но оставляет прежнее сообщение
```

Этот флаг удобен, если вы просто добрасываете забытые файлы в последний коммит.

### Флаг --allow-empty — создание пустого коммита

Иногда нужно создать коммит без изменений в файлах. Например:

- для запуска CI-пайплайна
- для фиксации какого-то события (например, включение фичи без изменения кода)

```bash
git commit --allow-empty -m "Тестовый запуск CI"
# Создаст коммит, в котором нет изменений файлов
```

### Флаг --no-verify — пропустить хуки

Если у вас настроены Git-хуки (например, pre-commit) и по какой-то причине вы хотите их временно обойти:

```bash
git commit -m "Сообщение" --no-verify
# Хуки pre-commit и commit-msg будут пропущены
```

Используйте это осознанно, чтобы не пропускать важные проверки кода.

---

## Проверка перед коммитом: git diff и git status

Перед тем как фиксировать изменения, полезно еще раз просмотреть, что именно попадет в коммит.

### Просмотр всех незафиксированных изменений

```bash
git diff
# Покажет изменения в файлах, которые еще не добавлены в индекс
```

### Просмотр того, что уже в индексе (будет в коммите)

```bash
git diff --cached
# Показывает только изменения, уже добавленные в индекс
```

Часто удобно сочетать эти команды:

```bash
git status
# Проверяем общую картину

git diff
# Смотрим, что еще не подготовлено к коммиту

git add нужные_файлы_или_фрагменты

git diff --cached
# Смотрим итоговый набор изменений, который попадет в коммит

git commit -m "Сообщение"
```

---

## Использование шаблонов для сообщений коммитов

Если вы хотите, чтобы сообщения коммитов были более однообразными (например, начинались с типа изменения или содержали обязательные секции), вы можете настроить шаблон.

### Настройка шаблона сообщения

Создайте файл-шаблон, например .gitmessage.txt:

```text
Тип изменения Краткое описание

Описание изменений
- пункт 1
- пункт 2

Ссылки на задачи или тикеты
- ISSUE-123
```

Теперь укажите Git использовать этот шаблон:

```bash
git config --global commit.template ~/.gitmessage.txt
# Теперь при выполнении git commit без -m шаблон будет подставлен в редактор
```

Когда вы вызовете git commit, Git откроет редактор с этим текстом. Вам останется только заполнить нужные места и удалить лишнее.

---

## Коммиты и ветки: как все связано

Чтобы понимать, куда именно попадает коммит, нужно немного взглянуть на связь между ветками и коммитами.

- Ветка в Git — это просто указатель на конкретный коммит.
- Каждый новый коммит в текущей ветке сдвигает этот указатель на себя.
- Текущая ветка определяется переменной HEAD.

Давайте посмотрим простой пример:

```bash
# Находитесь в ветке main
git checkout -b feature/auth
# Создаем новую ветку feature/auth и переходим в нее

# Вносим изменения и коммитим
git add .
git commit -m "Добавлена базовая авторизация"

# Этот коммит теперь находится в ветке feature/auth
# Ветка main по-прежнему указывает на старый коммит
```

Пример проверки:

```bash
git log --oneline --decorate --graph --all
# --all покажет все ветки
# --graph нарисует небольшой граф ветвления
# --decorate добавит имена веток к коммитам
```

Так вы увидите, в каких ветках присутствует ваш коммит и как он связан с остальной историей.

---

## Откат и изменение коммитов

Иногда важно не только создать коммит, но и уметь откатить его или изменить последовательность действий.

### Изменение еще не закоммиченных изменений: git restore и git reset

Если вы передумали насчет части изменений до коммита, можно:

```bash
git restore file.py
# Отменить изменения в рабочей директории для file.py, вернуть файл к последнему коммиту

git restore --staged file.py
# Убрать файл из индекса, но оставить изменения в рабочей директории
```

Эти команды помогают подготовить нужный набор изменений для будущего коммита.

### Отмена последнего коммита без потери изменений

Если вы сделали коммит, но решили, что он пока не должен быть в истории:

```bash
git reset --soft HEAD~1
# Удаляет последний коммит, но:
# - изменения остаются в индексе
# - файлы остаются измененными, как были
```

Если хотите убрать коммит, но оставить изменения только в рабочей директории:

```bash
git reset --mixed HEAD~1
# По умолчанию именно --mixed
# - коммит удаляется
# - изменения попадают в незастейдженные (как после правки файлов)
```

Комментарии:

- HEAD~1 — это «предыдущий коммит относительно текущего»
- Используйте эти команды только, если коммит еще не ушел на общий удаленный репозиторий

### Создание нового коммита, отменяющего другой: git revert

Если коммит уже есть в общей истории (например, на GitHub), переписывать историю рискованно. Тогда применяется revers-коммит:

```bash
git revert <хеш_коммита>
# Создает новый коммит, который возвращает файлы в состояние, противоположное указанному коммиту
```

Пример:

```bash
git revert a1b2c3d4
# Теперь будет создан новый коммит, который логически «отменяет» изменения a1b2c3d4
```

Здесь история остается линейной и прозрачной — старый коммит все еще существует, но его эффект компенсирован новым.

---

## Практические советы по оформлению коммитов

Чтобы ваша история Git была полезной:

### Делите работу на логические шаги

Не стоит складывать в один коммит:

- изменение бизнес-логики
- рефакторинг
- форматирование кода
- правки комментариев

Лучше разделить:

```text
Коммит 1 - "Рефакторинг функции calculate_price"
Коммит 2 - "Изменена логика применения скидки"
Коммит 3 - "Форматирование файла price_service.py"
```

Так проще:

- делать код-ревью
- находить причину регрессий
- при необходимости выборочно откатывать изменения

### Не бойтесь делать маленькие коммиты

Частые небольшие коммиты:

- помогают восстановить ход мысли
- уменьшают конфликтность при слиянии веток
- упрощают отладку

Хуже, когда есть один огромный коммит, где «почти все переписано».

### Связывайте коммиты с задачами

Если вы используете трекер задач (Jira, YouTrack, GitHub Issues), добавляйте идентификаторы задач:

```bash
git commit -m "Добавить пагинацию в список товаров - SHOP-123"
# Или:
git commit -m "SHOP-123 Добавить пагинацию в список товаров"
```

Так можно легко отследить, какие коммиты относятся к какой задаче.

---

## Расширенные примеры рабочих сценариев

Чтобы собрать все воедино, давайте разберем несколько практических сценариев.

### Сценарий 1. Обычный коммит с проверкой изменений

```bash
# Вносим изменения в код
vim main.py
# Редактируем файл

git status
# Проверяем, какие файлы изменены

git diff
# Смотрим конкретные изменения

git add main.py
# Добавляем только main.py в индекс

git diff --cached
# Проверяем, какие изменения попадут в коммит

git commit -m "Исправлена обработка ошибок при авторизации"
# Фиксируем изменения с понятным сообщением
```

Комментарии:

- вы всегда понимаете, что именно отправляете в коммит
- риск случайно добавить лишнее минимален

### Сценарий 2. Разделение большого изменения на несколько коммитов

```bash
# В одном файле вы поменяли и логику, и ошибки в комментариях

git add -p main.py
# По кускам выбираете только изменения в логике

git commit -m "Изменена логика обработки заказов"
# Первый коммит только с логикой

git add -p main.py
# Теперь добавляете остальные изменения (комментарии, форматирование)

git commit -m "Обновлены комментарии и форматирование в обработчике заказов"
# Второй коммит с не функциональными правками
```

Так история получается гораздо понятнее.

### Сценарий 3. Исправление опечатки в последнем коммите

```bash
# Только что сделали коммит, но заметили, что забыли обновить README

vim README.md
# Исправили документацию

git add README.md
# Добавили в индекс

git commit --amend --no-edit
# Добавили README к предыдущему коммиту, сообщение оставили прежним
```

С точки зрения истории выглядит так, будто вы изначально все сделали в одном аккуратном коммите.

---

## Заключение

Команда git commit — это центральный инструмент в работе с Git. Она не просто «сохраняет изменения», а формирует структуру истории вашего проекта. От того, насколько грамотно вы создаете коммиты, зависит:

- удобство анализа прошлого кода
- простота отката и поиска ошибок
- качество взаимодействия в команде

Основные моменты, которые стоит закрепить на практике:

- всегда смотрите git status и git diff перед коммитом
- используйте git add осознанно, по файлам или даже по фрагментам с -p
- формулируйте сообщения так, чтобы через время они были понятны без открытия диффа
- применяйте git commit --amend для исправления только что сделанных коммитов, пока они не ушли в общий репозиторий
- разделяйте логически разные изменения по отдельным коммитам

Освоив эти приемы, вы сможете вести историю проекта структурированно и предсказуемо, а работа с Git станет заметно проще.

---

## Частозадаваемые технические вопросы по теме статьи и ответы на них

### Как изменить редактор, который открывается при выполнении git commit без -m

Можно задать предпочитаемый редактор, например Nano или VS Code:

```bash
git config --global core.editor "nano"
# Теперь при git commit без -m будет открываться Nano

git config --global core.editor "code --wait"
# Для VS Code - флаг --wait нужен, чтобы Git дождался закрытия окна
```

### Что делать, если я случайно закоммитил секреты или пароли

1. Удалите секреты из кода и вынесите их в конфигурацию или переменные окружения.  
2. Создайте новый коммит с удалением секретов.  
3. Если секрет уже попал в общий репозиторий, замените его (например, пересоздайте ключ или пароль).  
4. Если нужно убрать секрет из истории, используйте инструменты переписывания истории, например git filter-repo, но делайте это с пониманием последствий для команды.

### Как добавить в коммит только новые файлы, не затрагивая измененные

Используйте:

```bash
git add --intent-to-add .
# Отметит новые файлы как добавленные, но без содержимого

git add path/to/new_file1 path/to/new_file2
# Явно добавьте нужные новые файлы

git commit -m "Сообщение"
```

Либо более явно:

```bash
git add path/to/new_file1 path/to/new_file2
# Добавляем только новые файлы вручную
```

### Как запретить пустые сообщения коммитов в команде

Настройте хук commit-msg, который будет проверять сообщение:

1. В папке .git/hooks создайте файл commit-msg (или переименуйте пример commit-msg.sample).  
2. Добавьте в него проверку, что сообщение не пустое и соответствует нужному формату.  
3. Сделайте файл исполняемым chmod +x .git/hooks/commit-msg.  

Теперь каждый git commit будет проходить эту проверку, и при нарушении правила коммит не создастся.

### Как сделать так, чтобы определенные файлы никогда не попадали в коммит

Добавьте их в .gitignore:

```text
# В файле .gitignore
.env
*.log
tmp/
```

После этого:

- новые файлы, подходящие под эти шаблоны, не будут показываться в git status и не попадут в индекс  
- если файл уже был закоммичен ранее, его нужно сначала удалить из индекса git rm --cached file, а затем добавить шаблон в .gitignore