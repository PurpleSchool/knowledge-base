---
metaTitle: Легковесный тег в Git команда git tag -l
metaDescription: Подробное руководство по работе с легковесными тегами в Git - разбор команды git tag -l создание просмотр фильтрация и практические сценарии использования
author: Олег Марков
title: Легковесный тег в Git - работа с командой git tag -l
preview: Разберитесь как использовать легковесные теги в Git - создавайте метки на коммитах просматривайте их через git tag -l фильтруйте и организуйте релизы и версии
---

## Введение

Легковесные теги в Git — это простой способ «приклеить» короткую метку к конкретному коммиту без дополнительных метаданных. Они удобны, когда вам нужно быстро зафиксировать важное состояние кода, не создавая релиз, не добавляя комментарии и не привязывая подписи.

Команда git tag -l отвечает за просмотр и фильтрацию тегов в репозитории. Через нее вы можете:

- увидеть список всех тегов;
- отфильтровать теги по шаблону;
- проверить, какие теги уже есть, прежде чем создавать новые;
- использовать результаты в скриптах и автоматизации.

Смотрите, я покажу вам, как на практике связаны две вещи: сами легковесные теги и команда git tag -l, которая помогает с ними работать.

---

## Что такое легковесный тег в Git

### Легковесный vs аннотированный тег

В Git есть два основных типа тегов:

- легковесный тег (lightweight tag);
- аннотированный тег (annotated tag).

Разница между ними важна, поэтому давайте разберемся.

**Легковесный тег** — это просто имя, указывающее на конкретный хеш-коммита. Никаких дополнительных данных он не хранит. Можно представить его как «ярлык» или «bookmark».

**Аннотированный тег** — это полноценный объект в базе данных Git. Он хранит:

- автора (кто создал тег);
- дату;
- сообщение (комментарий к тегу);
- опционально криптографическую подпись (GPG).

Давайте посмотрим на примеры создания:

```bash
# Создание легковесного тега
git tag v1.0.0

# Создание аннотированного тега
git tag -a v1.0.0 -m "Релиз версии 1.0.0"
```

Комментарии:

- в первом случае `v1.0.0` — просто имя, которое указывает на текущий коммит;
- во втором случае создается отдельный объект тега с метаданными.

### Когда использовать легковесные теги

Легковесные теги хорошо подходят, когда:

- вы быстро помечаете промежуточные состояния (например, экспериментальные версии);
- у вас есть внутренние метки для CI/CD, которые не несут бизнес-смысл;
- нужна просто ссылка на коммит, без истории автора/даты тега.

Аннотированные теги лучше использовать для:

- официальных версий релизов;
- публичных меток, которые будут использовать другие команды или пользователи;
- случаев, когда важна история того, кто и когда создал тег.

---

## Базовая команда git tag и флаг -l

### Что делает git tag без параметров и с -l

Команда git tag по умолчанию без аргументов уже выводит список тегов:

```bash
git tag
```

Но довольно часто вы будете видеть и использовать вариант:

```bash
git tag -l
```

Флаг `-l` (или `--list`) явно говорит Git: «покажи список тегов». На практике `git tag` и `git tag -l` ведут себя одинаково в простом случае. Однако флаг `-l` нужен, когда вы хотите использовать **шаблоны** и дополнительные опции.

Например:

```bash
# Показать только теги, начинающиеся на v1.
git tag -l "v1.*"
```

Здесь я использую `-l`, потому что передаю шаблон — без него Git воспримет строку как попытку создать тег, а не как паттерн для списка.

### Как git tag -l связан с легковесными тегами

Важно понимать: команда git tag -l **не различает** легковесные и аннотированные теги в списке. Она показывает все теги сразу. Для просмотра именно легковесных потребуется чуть более продвинутый подход (чуть позже мы к этому вернемся).

Тем не менее, вы будете очень часто использовать git tag -l именно для:

- проверки, создали ли вы уже легковесный тег;
- поиска нужного тега по имени;
- навигации по версиям (например, `v1.0.0`, `v1.0.1` и т.д.).

---

## Создание легковесных тегов и проверка через git tag -l

### Создание легковесного тега на текущем коммите

Допустим, вы сделали несколько коммитов и хотите отметить важный:

```bash
git tag v0.1.0-experimental
```

Комментарии:

- здесь создается легковесный тег с именем `v0.1.0-experimental`;
- тег будет указывать на **текущий** коммит на HEAD.

Теперь давайте посмотрим теги:

```bash
git tag -l
```

Вы увидите в выводе `v0.1.0-experimental`. Если тегов много, вы можете уточнить:

```bash
git tag -l "v0.1.0*"
```

Так вы убедитесь, что только нужная серия тегов попала в список.

### Создание легковесного тега на конкретном коммите

Бывает, что нужно пометить не последний коммит, а более ранний. Смотрите, я покажу вам, как это делается:

1. Сначала найдите хеш нужного коммита:

```bash
git log --oneline
```

Например, вы увидели строку:

```text
a1b2c3d Фикс критической ошибки
```

2. Теперь создадим легковесный тег на этом коммите:

```bash
# Создаем тег на конкретном хеше
git tag fix-critical-bug a1b2c3d
```

Комментарии:

- `fix-critical-bug` — имя тега;
- `a1b2c3d` — сокращенный хеш коммита, который вы увидели в логе.

Проверим, что тег появился:

```bash
git tag -l "fix*"
```

Вы увидите в выводе `fix-critical-bug`.

---

## Просмотр и фильтрация тегов через git tag -l

### Список всех тегов

Самый простой вариант:

```bash
git tag -l
```

или просто

```bash
git tag
```

Но довольно скоро список тегов начнет разрастаться. Тогда шаблоны станут особенно полезны.

### Фильтрация тегов по шаблону

Git использует **glob-шаблоны** (аналогично оболочке Bash), а не полноценные регулярные выражения. Давайте разберемся на примерах.

```bash
# Все теги, начинающиеся на v1.
git tag -l "v1.*"

# Все теги, включающие в себя слово beta
git tag -l "*beta*"

# Все теги, заканчивающиеся на -rc1
git tag -l "*-rc1"

# Все теги, начинающиеся на release-
git tag -l "release-*"
```

Комментарии:

- `*` — означает «любая последовательность символов»;
- `"v1.*"` — все, что начинается с `v1.` и имеет что-то после точки;
- кавычки лучше ставить, чтобы ваша оболочка не пыталась подставить файлы из директории.

Давайте посмотрим типичный сценарий. Например, вы используете теги:

- `v1.0.0`
- `v1.0.1`
- `v1.1.0`
- `v2.0.0-beta`
- `v2.0.0`

Тогда:

```bash
# Все стабильно релизные теги версии 1.x.x
git tag -l "v1.*"

# Все теги версии 2.x.x
git tag -l "v2.*"

# Только beta-релизы
git tag -l "*beta*"
```

### Сортировка и дополнительные опции списка

По умолчанию git tag -l выводит теги **в алфавитном порядке**. Иногда это удобно, но не всегда. Если вы хотите увидеть теги в порядке создания или в порядке коммитов, используйте дополнительные флаги.

Например:

```bash
# Показать теги вместе с коммитами, на которые они указывают
git tag -l --format="%(refname:short) %(objectname:short)"
```

Комментарии:

- `--format` позволяет задать формат вывода;
- `%(refname:short)` — короткое имя тега;
- `%(objectname:short)` — сокращенный хеш коммита.

Теперь давайте рассмотрим чуть более прикладной пример:

```bash
# Показать теги с датой коммита
git tag -l --format="%(refname:short) %(objectname:short) %(creatordate:short)"
```

Комментарии:

- `%(creatordate:short)` — дата создания **объекта**, на который указывает тег;
- для легковесных тегов это будет дата коммита;
- для аннотированных — дата объекта тега.

Обратите внимание: здесь мы используем более продвинутые возможности форматирования, которые особенно полезны в скриптах и при анализе истории.

---

## Как отличить легковесные теги от аннотированных

Команда git tag -l не дает вам напрямую информации о типе тега. Но вы легко можете это определить через git cat-file или git show.

### Проверка конкретного тега

Давайте разберемся на практике:

```bash
# Предположим, у нас есть тег v1.0.0
git show v1.0.0
```

Сценарии:

1. **Если тег легковесный**, вы увидите сразу информацию о коммите:

```text
commit a1b2c3d4e5f6...
Author: ...
Date:   ...

    Сообщение коммита
```

2. **Если тег аннотированный**, вывод начнется с информации об объекте тега:

```text
tag v1.0.0
Tagger: ...
Date:   ...

    Релиз версии 1.0.0

commit a1b2c3d4e5f6...
Author: ...
Date:   ...

    Сообщение коммита
```

Как видите, в случае аннотированного тега отдельно показывается заголовок `tag v1.0.0`, автор и сообщение тега.

### Сценарий: найти все легковесные теги

Иногда вам нужно в большом репозитории выделить именно легковесные теги. Здесь пригодится связка git for-each-ref и фильтрация по типу.

Давайте посмотрим пример:

```bash
# Показать только легковесные теги
git for-each-ref refs/tags --format="%(refname:short) %(objecttype)" | \
  awk '$2 == "commit" { print $1 }'
```

Комментарии к команде:

- `git for-each-ref refs/tags` — перебирает все ссылки в `refs/tags` (то есть все теги);
- `--format="%(refname:short) %(objecttype)"` — выводит имя тега и тип объекта, на который он указывает;
- для легковесного тега `objecttype` будет `commit`, а для аннотированного — `tag`;
- `awk '$2 == "commit" { print $1 }'` — фильтрует только строки, где второй столбец равен `commit`.

Результатом будет список **именно легковесных тегов**.

---

## Использование git tag -l в реальных сценариях

### 1. Навигация по промежуточным версиям

Представьте, что вы помечаете каждое более-менее значимое изменение легковесными тегами:

- `exp-new-ui-1`
- `exp-new-ui-2`
- `exp-new-ui-3`

Теперь вы хотите быстро ориентироваться, что у вас есть по теме `exp-new-ui`:

```bash
git tag -l "exp-new-ui-*"
```

Дальше вы можете перейти на нужную версию:

```bash
# Переключаемся на состояние репозитория на теге exp-new-ui-2
git checkout exp-new-ui-2
```

Комментарии:

- вы оказываетесь в состоянии «detached HEAD» (отделенная голова);
- это значит, что вы находитесь на конкретном коммите, не привязанном к ветке.

Если после этого вы захотите создать новую ветку от этого состояния:

```bash
# Создаем ветку от тега exp-new-ui-2
git checkout -b feature/new-ui-from-v2
```

Теперь у вас есть полноценная ветка, и вы можете продолжать разработку.

### 2. Быстрая отметка для CI/CD или экспериментов

Допустим, ваш CI настроен на сборку по тегам вида `build-*`. Тогда вы можете:

```bash
# Создаем легковесный тег для сборки
git tag build-2025-01-15

# Отправляем тег в удаленный репозиторий
git push origin build-2025-01-15
```

Затем проверяем, какие сборочные теги уже есть:

```bash
git tag -l "build-*"
```

Такой подход особенно удобен, когда:

- вы часто делаете экспериментальные сборки;
- вам не нужно хранить дополнительные данные в аннотированных тегах;
- CI просто реагирует на появление тега.

---

## Удаление и переименование легковесных тегов

### Удаление локального легковесного тега

Иногда тег нужно удалить, например, если вы ошиблись в имени или отметили не тот коммит.

```bash
# Удаление тега локально
git tag -d v0.1.0-experimental
```

После этого давайте проверим, что тега больше нет:

```bash
git tag -l "v0.1.0*"
```

Если вывод пустой — тег удален.

### Удаление тега на удаленном репозитории

Если тег уже отправлен в `origin` или другой удаленный репозиторий, одного локального удаления мало.

Смотрите, как удалить тег на удаленном сервере:

```bash
# Удаление тега на удаленном репозитории origin
git push origin :refs/tags/v0.1.0-experimental
```

Или более современный и читаемый вариант:

```bash
git push origin --delete v0.1.0-experimental
```

После этого вы можете снова запросить список тегов с сервера (например, через `git fetch --tags`), чтобы убедиться, что тег исчез.

### Переименование тега (через пересоздание)

В Git нет прямой команды «переименовать тег». Но вы можете сделать это двумя шагами:

1. Создать новый тег с правильным именем, указывающий на тот же коммит.
2. Удалить старый тег.

Давайте разберемся на примере:

```bash
# Узнаем, на какой коммит указывает старый тег
git rev-parse old-tag-name
```

Допустим, команда вывела:

```text
a1b2c3d4e5f6...
```

Теперь:

```bash
# Создаем новый тег на тот же коммит
git tag new-tag-name a1b2c3d4e5f6

# Удаляем старый тег
git tag -d old-tag-name
```

Если тег уже был в удаленном репозитории:

```bash
# Удаляем старый тег удаленно
git push origin --delete old-tag-name

# Отправляем новый тег
git push origin new-tag-name
```

Так вы аккуратно «переименуете» тег.

---

## Взаимодействие с удаленными тегами и git tag -l

### Просмотр локальных и удаленных тегов

Команда git tag -l по умолчанию показывает **локальные теги**, то есть те, которые есть в вашей локальной базе Git.

Чтобы убедиться, что вы видите все актуальные теги с сервера, сначала выполните:

```bash
# Забрать все теги с удаленного репозитория
git fetch --tags
```

После этого:

```bash
git tag -l
```

покажет полный актуальный список тегов.

### Почему git tag -l не показывает удаленные теги «как есть»

Иногда возникает путаница: разработчики ожидают, что можно как-то отдельно увидеть «удаленные теги». В Git теги при fetch/sync просто становятся локальными ссылками в `refs/tags`. Нет отдельной категории «remote tags».

Поэтому:

- `git tag -l` — всегда работает с локальной базой ссылок;
- если нужно, чтобы локальная база отражала состояние сервера, делайте `git fetch --tags`.

---

## Расширенные примеры использования git tag -l

### Форматирование вывода тегов

Смотрите, я покажу вам, как можно сделать вывод тегов более информативным. Для этого мы соединяем git tag -l и параметр --format:

```bash
# Теги с хешем коммита и сообщением коммита
git tag -l --format="%(refname:short) %(objectname:short) %(subject)"
```

Комментарии:

- `%(subject)` — это заголовок сообщения коммита (или сообщения тега, если он аннотированный);
- для легковесного тега subject будет из коммита;
- удобно, когда вы хотите понимать, за что отвечает каждая метка.

Еще один вариант:

```bash
# Теги в формате - имя - тип объекта - дата
git for-each-ref refs/tags --format="%(refname:short) %(objecttype) %(creatordate:short)"
```

Здесь вы сразу увидите, какие теги легковесные (objecttype = commit), а какие аннотированные (objecttype = tag).

### Использование git tag -l в скриптах

Команда git tag -l часто используется в автоматизации: сборка, деплой, генерация changelog.

Например, вы хотите взять последний тег версии 1.x.x и сравнить с текущим состоянием:

```bash
# Получаем последний тег версии 1.x.x (по алфавиту)
last_v1_tag=$(git tag -l "v1.*" | sort -V | tail -n 1)

# Смотрим изменения с этого тега до текущей HEAD
git log --oneline "${last_v1_tag}..HEAD"
```

Комментарии:

- `git tag -l "v1.*"` — список тегов версии 1.x.x;
- `sort -V` — сортировка по «версии» (1.2 < 1.10);
- `tail -n 1` — берем последний, самый свежий.

Такой подход полезен для автоматического формирования changelog между версиями.

---

## Рекомендации по использованию легковесных тегов

### Когда легковесные теги особенно уместны

Легковесные теги хорошо подходят для:

- временных меток: «последний стабильный коммит перед большой переработкой»;
- внутренних меток команды, которые не покидают репозиторий;
- меток для CI, сборок, внутренних проверок;
- меток на коммитах, которые вы не собираетесь широко распространять.

В этих случаях аннотированные теги будут излишними — вы просто захламите историю дополнительными объектами.

### Когда лучше сразу использовать аннотированные теги

Если вы:

- создаете **официальный релиз** (например, `v1.0.0`);
- работаете в публичном open-source проекте;
- хотите иметь историю того, кто создал тег и с каким комментарием,

то лучше использовать аннотированные теги. В этом случае git tag -l также будет работать, но вам будет проще отслеживать дополнительные метаданные через git show и форматирование.

---

## Заключение

Легковесные теги в Git — это простой и быстрый способ пометить важные коммиты. Они не создают дополнительных объектов в базе данных, не требуют сообщения и удобны для внутренних, временных или экспериментальных меток.

Команда git tag -l — ваш основной инструмент для работы со списком тегов:

- позволяет вывести полный список тегов;
- поддерживает фильтрацию по шаблонам;
- работает как база для автоматизации и скриптов;
- в сочетании с форматированием и вспомогательными командами помогает отличать легковесные теги от аннотированных и анализировать историю.

Используя git tag -l вместе с осознанным подходом к типам тегов, вы сможете лучше организовать историю проекта, упростить навигацию между версиями и выстроить надежные процессы сборки и релизов.

---

## Частозадаваемые технические вопросы по теме

### Как вывести только те теги, которые указывают на текущий коммит

Используйте следующую команду:

```bash
git tag --points-at HEAD
```

Комментарии:

- выводит все теги (легковесные и аннотированные), которые указывают на текущий коммит;
- удобно, когда вы хотите понять, помечен ли текущий коммит каким-то тегом.

### Как вывести теги в порядке даты коммита а не по алфавиту

Здесь поможет git for-each-ref:

```bash
git for-each-ref refs/tags --sort=creatordate --format="%(refname:short) %(creatordate:short)"
```

Комментарии:

- `--sort=creatordate` — сортировка по дате создания объекта;
- для легковесных тегов дата берется из коммита.

### Как найти разницу между двумя тегами и вывести только изменения в файлах

Используйте git diff:

```bash
git diff --name-status tag1 tag2
```

Комментарии:

- `--name-status` покажет список файлов и статус (A добавлен, M изменен, D удален);
- удобно при анализе изменений между двумя помеченными состояниями.

### Как проверить к какому тегу ближе всего текущий коммит

Команда git describe позволяет найти ближайший тег:

```bash
git describe --tags
```

Комментарии:

- покажет ближайший тег по истории и количество коммитов с момента этого тега;
- полезно для ориентирования в промежуточных состояниях между тегами.

### Как скопировать легковесный тег с одного удаленного репозитория в другой

1. Сначала заберите тег из первого удаленного:

```bash
git fetch origin tag some-tag
```

2. Затем отправьте этот тег в другой удаленный репозиторий:

```bash
git push another-remote some-tag
```

Так вы перенесете тег `some-tag` между серверами, сохранив ссылку на тот же коммит.