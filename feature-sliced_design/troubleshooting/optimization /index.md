---
metaTitle: Оптимизация сборки build-optimization в современных проектах
metaDescription: Подробный разбор практик оптимизации сборки build-optimization - стратегии ускорения сборки уменьшения размера артефактов и повышения эффективности CI CD
author: Олег Марков
title: Оптимизация сборки build-optimization для быстрых и эффективных проектов
preview: Разберем ключевые техники оптимизации сборки build-optimization - кэширование инкрементальная компиляция минификация и настройка инструментов сборки на реальных примерах
---

## Введение

Оптимизация сборки (build-optimization) — это совокупность приемов и настроек, которые помогают ускорить процесс сборки проекта, уменьшить размер итоговых артефактов и снизить нагрузку на инфраструктуру. Когда вы запускаете сборку локально или в CI, вы платите временем разработчика, ресурсами серверов и, в конечном счете, скоростью выхода фич в прод.

Смотрите, я покажу вам на примерах, что значит «оптимизировать сборку» в практическом смысле:

- Сборка фронтенда не 5–10 минут, а 30–60 секунд.
- Пересобираются только измененные модули, а не весь проект.
- Бандл для браузера не 4 МБ, а 500–800 КБ.
- CI собирает проект параллельно и переиспользует кэш между задачами.

Давайте разберем основные техники и инструменты, которые помогут вам добиться такого результата. Я буду приводить примеры на популярных инструментах (Webpack, Vite, esbuild, Gradle, Maven, Go, Docker), но принципы универсальны и легко переносятся на другие стеки.

---

## Базовые принципы оптимизации сборки

### Что именно мы оптимизируем

Когда вы думаете про build-optimization, полезно разделить цели:

1. Время сборки:
   - Насколько быстро собирается проект локально.
   - Сколько времени тратит CI на полный pipeline.

2. Размер артефактов:
   - Размер JS/CSS бандлов.
   - Размер бинарников и контейнеров.
   - Количество лишних зависимостей внутри артефакта.

3. Надежность и повторяемость:
   - Сборка должна быть детерминированной.
   - Результат не должен зависеть от случайностей (часовой пояс, локаль, версия кеша и т.п.).

Чуть дальше я покажу, как каждый из этих пунктов настраивается в реальных конфигурациях.

### Ключевые идеи, которые стоит запомнить

- Не пересобирать лишнего — инкрементальная сборка и правильное разбиение модулей.
- Кэшировать все, что можно — локальный и удаленный кэш, re-use артефактов.
- Параллелить — использовать доступные ядра процессора и шардирование задач.
- Убирать мусор — tree shaking, dead code elimination, удаление неиспользуемых зависимостей.
- Минимизировать работу на этапе сборки — переносить тяжелые операции в prebuild или CI.

---

## Оптимизация сборки фронтенда

Здесь я покажу вам практические приемы на примере Webpack, Vite и esbuild, потому что именно в фронтенде проблема долгих и тяжелых сборок встречается чаще всего.

### Инкрементальная сборка и режим watch

Инкрементальная сборка означает, что после первого полного билда инструмент пересобирает только изменившиеся файлы и их зависимые модули.

#### Пример с Webpack

```js
// webpack.config.js
const path = require('path');

module.exports = {
  mode: 'development',          // В dev-режиме включены быстрые пресеты
  entry: './src/index.tsx',     // Точка входа приложения
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',      // Имя основного бандла
  },
  cache: {
    type: 'filesystem',         // Включаем файловый кэш между запусками
  },
  devtool: 'eval-cheap-module-source-map', // Быстрые source map для dev
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',       // Компиляция TypeScript
        exclude: /node_modules/
      }
    ]
  }
};
```

Комментарии к важным моментам:

- `cache.type = 'filesystem'` — Webpack сохраняет результаты компиляции на диск и при повторной сборке использует их. Это сильно ускоряет dev-сборку и локальный запуск.
- Легкий `devtool` — упрощенные source map компилируются быстрее.

Запуск в режиме watch:

```bash
# Запускаем Webpack в режиме отслеживания изменений
npx webpack --watch
```

// Webpack будет пересобирать только измененные файлы, что резко ускоряет цикл правка–сборка–проверка.

#### Пример с Vite (инкрементальная сборка «из коробки»)

Vite изначально спроектирован как инструмент с быстрой инкрементальной сборкой.

```ts
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],           // Поддержка React и fast refresh
  build: {
    sourcemap: true,            // Source map для прод-сборки (по необходимости)
    minify: 'esbuild',          // Используем esbuild для минификации
  },
});
```

```bash
# Dev-сервер с инкрементальной пересборкой модулей
npx vite
```

// Vite использует ES-модули в dev-режиме и пересобирает только то, что реально изменилось.

### Кэширование и ускорение JavaScript/TypeScript сборки

Кэш помогает избежать повторной компиляции одних и тех же файлов между запусками.

#### Кэш в Babel

```json
// babel.config.json
{
  "presets": ["@babel/preset-env", "@babel/preset-react"],
  "plugins": [],
  "cacheDirectory": true
}
```

// Параметр `cacheDirectory` говорит Babel сохранять результаты трансформаций в папку кэша.

#### Кэш в ts-loader (Webpack + TypeScript)

```js
// Фрагмент rules в webpack.config.js
{
  test: /\.tsx?$/,
  use: [
    {
      loader: 'ts-loader',
      options: {
        transpileOnly: true,   // Только транспиляция, без type-check
        experimentalWatchApi: true, // Быстрый watch
      },
    },
  ],
  exclude: /node_modules/,
}
```

// Часто проверку типов выносят в отдельный процесс (например, через `fork-ts-checker-webpack-plugin`) — это ускоряет основную сборку.

### Tree shaking и dead code elimination

Теперь давайте посмотрим, как убрать неиспользуемый код из итогового бандла.

#### Условия для корректного tree shaking

1. Использование ES-модулей (`import` / `export`), а не CommonJS.
2. Конфигурация сборщика, включающая оптимизацию модулей.
3. Библиотеки должны помечать, что они side-effect free, когда это возможно.

#### Пример с Webpack

```js
// webpack.config.js (production)
module.exports = {
  mode: 'production',              // Автоматически включает tree shaking
  optimization: {
    usedExports: true,             // Помечает используемые экспортируемые сущности
    sideEffects: true,             // Учитывает поле sideEffects в package.json
    minimize: true,                // Включает минификацию
  },
};
```

```json
// package.json
{
  "name": "my-lib",
  "sideEffects": false
}
```

// Поле `sideEffects: false` говорит сборщику, что можно смело удалять неиспользуемые импорты из этой библиотеки.

#### Пример кода для tree shaking

```ts
// src/utils/math.ts
export function add(a: number, b: number): number {
  return a + b;
}

export function subtract(a: number, b: number): number {
  return a - b;
}

// В приложении мы импортируем только add
// import { add } from './utils/math';
```

// Если вы нигде не используете `subtract`, при корректной настройке сборщика эта функция не попадет в итоговый бандл.

### Минификация и splitting для фронтенда

Теперь вы увидите, как минификация и разбиение кода помогают уменьшить размер бандла.

#### Code splitting (динамический импорт)

```ts
// src/App.tsx
import React, { Suspense } from 'react';

// Динамический импорт тяжелого модуля
const HeavyPage = React.lazy(() => import('./HeavyPage'));

export function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <HeavyPage />
    </Suspense>
  );
}
```

// Браузер загрузит код `HeavyPage` только когда он действительно понадобится пользователю.

#### Настройка splitChunks в Webpack

```js
// webpack.config.js (часть optimization)
optimization: {
  splitChunks: {
    chunks: 'all',             // Разбивать как sync, так и async чанки
    cacheGroups: {
      vendors: {
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors',       // Отдельный чанк для зависимостей
        chunks: 'all',
      },
    },
  },
},
```

// Такой конфиг вынесет общие зависимости в отдельный бандл `vendors`, который будет кэшироваться браузером.

#### Минификация с помощью Terser

```js
// webpack.config.js (переопределение минификатора)
const TerserPlugin = require('terser-webpack-plugin');

optimization: {
  minimize: true,
  minimizer: [
    new TerserPlugin({
      parallel: true,            // Параллельная минификация на несколько потоков
      terserOptions: {
        compress: {
          drop_console: true,    // Удалить console.log в проде
        },
      },
    }),
  ],
},
```

// Параллельная минификация заметно ускоряет прод-сборку на больших проектах.

---

## Оптимизация сборки бэкенда

Теперь давайте посмотрим, как оптимизировать сборку серверной части — на примерах Go и JVM (Gradle/Maven). Здесь ключевой упор — на кэширование, инкрементальную компиляцию и уменьшение размеров артефактов и контейнеров.

### Оптимизация сборки Go

Go изначально компилируется довольно быстро, но и здесь есть полезные приемы.

#### Использование кэша компиляции

Go сам кэширует результаты компиляции модулей в `$GOMODCACHE` и `$GOCACHE`. Главное — не удалять кэш на каждом шаге CI.

Пример простого Dockerfile без учета кэша:

```dockerfile
# Плохой пример - кэш зависимостей не переиспользуется эффективно
FROM golang:1.22-alpine AS build

WORKDIR /app
COPY . .
RUN go build -o app ./cmd/app
```

Лучше разделить копирование зависимостей и исходников:

```dockerfile
# Здесь я показываю более оптимальный Dockerfile
FROM golang:1.22-alpine AS build

WORKDIR /app

# Сначала копируем только модули - так кэш go mod download переиспользуется
COPY go.mod go.sum ./
RUN go mod download

# Теперь копируем остальной код приложения
COPY . .

# Собираем бинарник без символов отладки и с оптимизациями
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o app ./cmd/app

FROM alpine:3.19
WORKDIR /app

# Копируем только итоговый бинарник
COPY --from=build /app/app /app/app

# Запускаем бинарник как основной процесс
CMD ["/app/app"]
```

Комментарии:

- Разделение `COPY go.mod go.sum ./` и `COPY . .` позволяет переиспользовать слой с `go mod download`.
- Флаг `-ldflags="-s -w"` уменьшает размер бинарника, убирая отладочную информацию.

### Инкрементальная сборка в Gradle (JVM)

Теперь давайте разберемся на примере Gradle-проекта (Java/Kotlin).

#### Включение кэширования и параллельной сборки

```groovy
// settings.gradle
gradle.settingsEvaluated {
    buildCache {
        local {
            enabled = true        // Локальный кэш задач
        }
    }
}
```

```properties
# gradle.properties
org.gradle.parallel=true          # Параллельное выполнение задач
org.gradle.caching=true           # Включение build cache
org.gradle.daemon=true            # Постоянно работающий демон Gradle
org.gradle.configureondemand=true # Конфигурировать только нужные модули
```

// Эти настройки позволяют Gradle переиспользовать результаты задач между сборками и запускать их на нескольких ядрах.

#### Инкрементальная компиляция Kotlin

```kotlin
// build.gradle.kts
plugins {
    kotlin("jvm") version "1.9.0"
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        incremental = true            // Включаем инкрементальную компиляцию
        jvmTarget = "17"
    }
}
```

// Инкрементальная компиляция пересобирает только измененные файлы и их зависимости.

---

## Подходы к оптимизации в CI/CD

Часто самые долгие сборки — это именно CI. Здесь я покажу вам, как использовать кэш, артефакты и параллельные задачи.

### Кэширование зависимостей в GitHub Actions

```yaml
# .github/workflows/build.yml
name: Build

on:
  push:
    branches: [ main ]

jobs:
  build-js:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache node modules
        uses: actions/cache@v4
        with:
          path: |
            **/node_modules
          key: node-modules-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            node-modules-${{ runner.os }}-

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build
```

Комментарии:

- `actions/cache` сохраняет `node_modules` между билдами, если `package-lock.json` не изменился.
- При изменении зависимостей кэш автоматически инвалидируется за счет нового `key`.

### Разделение pipeline на шаги с артефактами

```yaml
# Пример двух job для front и back с переиспользованием артефактов
jobs:
  build-frontend:
    runs-on: ubuntu-latest
    steps:
      # ...
      - name: Build frontend
        run: npm run build

      - name: Upload frontend artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: dist/

  build-backend:
    runs-on: ubuntu-latest
    needs: build-frontend
    steps:
      - name: Download frontend artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: /tmp/dist

      # Далее используем скачанный фронтенд в бэкенд-сборке или Docker image
```

// Такой подход позволяет не пересобирать фронтенд при каждом шаге бэкенда, а просто переиспользовать уже собранные артефакты.

---

## Оптимизация Docker-сборок и контейнеров

Контейнеризация — часть сборочного процесса, и ее тоже важно оптимизировать.

### Многостадийные Dockerfile

Смотрите, я покажу вам пример, как многослойная сборка уменьшает размер образа и время пуша:

```dockerfile
# Стадия 1 - сборка
FROM node:20-alpine AS build

WORKDIR /app

COPY package*.json ./
RUN npm ci            # Устанавливаем зависимости - слой хорошо кэшируется

COPY . .
RUN npm run build     # Собираем production-бандл

# Стадия 2 - минимальный runtime
FROM nginx:1.25-alpine

# Удаляем дефолтный конфиг и копируем наш
RUN rm /etc/nginx/conf.d/default.conf
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Копируем только статический результат
COPY --from=build /app/dist /usr/share/nginx/html

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

Комментарий:

- В runtime-образ попадает только минимально необходимый набор файлов.
- `npm ci` и `COPY package*.json ./` позволяют эффективно кэшировать установку зависимостей.

### Уменьшение числа слоев и мусора

```dockerfile
# Неудачный пример - каждый RUN создает новый слой
RUN apk update
RUN apk add git
RUN rm -rf /var/cache/apk/*

# Лучше объединить в один RUN
RUN apk update && \
    apk add --no-cache git
```

// Объединяя команды, вы уменьшаете количество слоев и размер образа.

---

## Общие приемы оптимизации: структура проекта и зависимости

### Правильное разбиение на модули

Чем больше ваш проект, тем важнее модульность. Давайте разберем, как структура влияет на сборку:

- Независимые модули можно собирать параллельно.
- Маленькие модули проще кэшировать.
- Можно настроить частичную сборку (только измененные сервисы).

Пример монорепозитория с фронтом и бекендом:

```text
repo/
  frontend/
    package.json
    src/
  backend/
    build.gradle.kts
    src/
  shared/
    lib/              # Общие модели и код
```

// В CI вы можете запускать сборку `frontend` и `backend` в параллельных job, а `shared` собирать как библиотеку и кэшировать.

### Чистка и аудит зависимостей

Лишние зависимости увеличивают:

- Время установки.
- Размер бандлов и образов.
- Риск безопасности.

Полезные практики:

- Периодически запускать анализ размерности бандла (например, `webpack-bundle-analyzer`).
- Удалять неиспользуемые пакеты из `package.json`.
- Использовать более легкие аналоги (например, заменить тяжелую библиотеку на узко специализированную).

Пример анализа Webpack-бандла:

```js
// webpack.config.js
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

module.exports = {
  // ...
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',       // Генерируется статический HTML-отчет
      openAnalyzer: false           // Не открывать автоматически
    }),
  ],
};
```

```bash
# После сборки вы увидите отчет в файле report.html
npx webpack --mode production
```

// Обратите внимание, как этот фрагмент кода помогает визуально увидеть самые тяжелые модули.

---

## Заключение

Оптимизация сборки — это не один фокусный трюк, а набор осознанных решений: как устроена структура проекта, какие инструменты вы используете, как настроено кэширование и CI. Если кратко, то ваша цель — пересобирать только то, что действительно изменилось, и делать это максимально параллельно и повторяемо.

Основные идеи, которые стоит внедрять по шагам:

- Включить и настроить кэширование (Webpack filesystem cache, Gradle build cache, GitHub Actions cache).
- Перейти на инкрементальную сборку (watch, incremental compile).
- Настроить tree shaking и минификацию, чтобы уменьшить размер фронтенд-бандлов.
- Использовать многостадийные Dockerfile и разумную структуру слоев.
- Разбить проект на модули так, чтобы сборка могла выполняться частями и параллельно.
- Регулярно анализировать размер артефактов и чистить зависимости.

Если вы будете смотреть на build-optimization как на регулярный процесс, а не разовую настройку, сборка со временем перестанет быть узким местом и станет стабильным, предсказуемым этапом вашего жизненного цикла разработки.

---

## Частозадаваемые технические вопросы по теме и ответы

### 1. Как понять, что именно тормозит сборку фронтенда

Используйте профилирование сборщика. В Webpack включите `--profile --json > stats.json` и проанализируйте файл с помощью `webpack-bundle-analyzer` или `webpack analyse`. Это покажет, какие шаги (лоадеры, плагины, минификаторы) занимают больше всего времени. Уберите или упростите самые тяжелые участки, например, сократите число тяжелых лоадеров или отключите ненужные плагины в dev-режиме.

### 2. Как настроить частичную сборку в монорепозитории

Используйте инструменты, которые умеют понимать граф зависимостей модулей, например Nx или Turborepo. Они позволяют запускать сборку только для пакетов, затронутых изменениями, а также кэшировать результаты задач. Настройте для каждого пакета свои команды build и test и добавьте в конфиг правила зависимости между пакетами.

### 3. Почему Gradle кэш не срабатывает и задачи всегда выполняются

Проверьте, что задачи маркированы как cacheable и не используют неучтенные побочные эффекты (например, доступ к внешним файлам вне объявленных входов/выходов). Включите логирование `--info` или `--scan` и посмотрите причину пропуска кэша. Часто проблема в том, что задача считает свои входы измененными из-за нестабильных путей или времени модификации файлов.

### 4. Как сделать так, чтобы Docker слои эффективно кэшировались в CI

Выделите этапы установки зависимостей и копирования исходников в отдельные слои. Сначала копируйте только файлы зависимостей (package-lock, go.mod, pom.xml) и запускайте установку. Затем копируйте исходный код и выполняйте сборку. В CI используйте buildkit и кэш (`--cache-from`, `--cache-to`), чтобы переиспользовать слои между билдами.

### 5. Как уменьшить размер JS-бандла без смены сборщика

Включите tree shaking и проверьте использование ES-модулей. Введите code splitting для маршрутов и тяжелых частей приложения. Замените большие библиотеки на более легкие аналоги либо импортируйте только нужные подмодули (например, вместо целого UI-фреймворка импорт отдельных компонентов). Запустите анализ бандла и целенаправленно уберите самые тяжелые и редко используемые части.