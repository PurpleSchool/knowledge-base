---
metaTitle: Клонирование репозитория в Git - полное руководство по git clone
metaDescription: Узнайте как работает команда git clone - рассмотрим варианты клонирования репозитория по SSH и HTTPS разберем глубину истории шаблоны и частичные клоны
author: Олег Марков
title: Клонирование репозитория - git clone
preview: Исследуйте команду git clone - как она работает какие есть параметры и как правильно клонировать репозитории для разработки и работы в команде
---

## Введение

Клонирование репозитория — это первый шаг, который вы почти всегда делаете, когда начинаете работать с уже существующим проектом на Git. Команда git clone создает у вас на машине полную копию удаленного репозитория со всей историей изменений, ветками, тегами и настройками удаленных источников.

Смотрите, я покажу вам, как с помощью git clone:

- скопировать репозиторий с GitHub, GitLab или другого сервера;
- выбрать правильный протокол — HTTPS или SSH;
- настроить каталог, в который будет клонирован проект;
- ускорить клонирование за счет сокращения истории;
- клонировать только нужные ветки или даже отдельные папки;
- разбираться с частыми ошибками при клонировании.

Давайте начнем с базового синтаксиса, а затем углубимся в каждую важную опцию.

## Что делает git clone и как он устроен

Когда вы запускаете git clone, происходит несколько шагов:

1. Устанавливается соединение с удаленным репозиторием по указанному URL.
2. Git скачивает все объекты истории — коммиты, деревья, блобы, теги.
3. Создается локальный репозиторий в папке на вашей машине.
4. Настраивается удаленный источник с именем origin — это ссылка на исходный репозиторий.
5. Создается рабочая копия файлов для выбранной по умолчанию ветки (обычно main или master).
6. Настраивается отслеживаемая ветка — локальная ветка main будет связана с origin/main.

В результате вы получаете полноценный репозиторий, который не зависит от сети для повседневной работы: можно коммитить, создавать ветки, смотреть историю без доступа к серверу.

## Базовый синтаксис git clone

### Минимальный пример клонирования

Самый простой вариант выглядит так:

```bash
git clone https://github.com/user/project.git
# Клонируем репозиторий по HTTPS в папку project
```

Git автоматически:

- создаст каталог project (по имени репозитория);
- инициализирует там репозиторий;
- скачает историю и файлы;
- настроит origin на указанный URL.

Если вы хотите задать имя каталога вручную, используйте дополнительный аргумент:

```bash
git clone https://github.com/user/project.git my-project
# Репозиторий будет склонирован в папку my-project
```

Это полезно, когда вы хотите другое имя папки, чем у удаленного репозитория.

### Общий формат команды

Давайте разберем общий формат:

```bash
git clone [опции] <url> [каталог]
```

Где:

- `<url>` — адрес удаленного репозитория;
- `[каталог]` — опциональный параметр, имя целевой папки;
- `[опции]` — дополнительные флаги, которые уточняют поведение клонирования (глубина, ветка, протокол и т.д.).

## Виды URL и протоколов для git clone

### HTTPS

HTTPS — самый распространенный и понятный вариант:

```bash
git clone https://github.com/user/project.git
```

Особенности:

- Аутентификация чаще всего через логин и токен доступа (personal access token).
- Работает практически всегда, даже за большинством корпоративных прокси.
- Можно использовать без настроенных SSH ключей.

Минус — при каждом push или pull Git может спрашивать логин и токен, если не настроен менеджер учетных данных.

### SSH

SSH удобен для постоянной разработки:

```bash
git clone git@github.com:user/project.git
# Схема для GitHub по SSH
```

Пример для GitLab:

```bash
git clone git@gitlab.com:user/project.git
```

Особенности:

- Используются SSH-ключи, а не пароли.
- Не нужно каждый раз вводить пароль или токен.
- Требуется предварительная настройка ключей на сервере и вашей машине.

Если вы впервые настраиваете SSH, порядок обычно такой:

```bash
ssh-keygen -t ed25519 -C "your_email@example.com"
# Генерируем ключ

# Далее вы копируете содержимое файла id_ed25519.pub
# и добавляете его в настройки SSH ключей на GitHub / GitLab
```

Затем можно проверить соединение:

```bash
ssh -T git@github.com
# Проверяем, что доступ по SSH работает
```

### Локальные пути и протокол file

Вы можете клонировать репозиторий с локального диска или с сетевой папки:

```bash
git clone /path/to/repo my-copy
# Клонируем локальный репозиторий из заданного каталога

git clone file:///path/to/repo my-copy
# То же самое, но явно через file
```

Это полезно, когда вы копируете шаблонный репозиторий или делаете резервную копию.

### Git протокол (git://)

Старый протокол git:// используется редко, в основном для публичных только-чтение репозиториев. Сейчас он постепенно вытесняется HTTPS и SSH, поэтому в реальных проектах вы будете встречать его все реже.

## Клонирование в нужный каталог и структура после clone

### Выбор целевого каталога

Покажу, как задать конкретный путь:

```bash
git clone https://github.com/user/project.git /home/user/work/project
# Клонируем прямо в указанный путь

git clone https://github.com/user/project.git .
# Клонируем в текущую папку (должна быть пустой)
```

Будьте аккуратны с точкой — если в текущей папке уже есть файлы, Git может выдать ошибку или создать конфликт.

### Что появляется после клонирования

После git clone в папке вы увидите:

- файлы проекта — рабочая директория;
- скрытую папку .git — там лежит весь внутренний репозиторий: история, индексы, настройки.

Посмотреть основные настройки можно так:

```bash
git remote -v
# Показывает все удаленные источники и их URL

git branch -a
# Показывает локальные и удаленные ветки
```

Комментарии к тому, что вы увидите:

```bash
# Пример вывода git remote -v
origin  git@github.com:user/project.git (fetch)  # URL для получения изменений
origin  git@github.com:user/project.git (push)   # URL для отправки изменений

# Пример вывода git branch -a
* main                     # Текущая локальная ветка
  remotes/origin/main      # Удаленная ветка главной ветки
  remotes/origin/dev       # Еще одна ветка на сервере
```

## Клонирование конкретной ветки

По умолчанию Git клонирует все ветки, но рабочая копия будет на одной — основной. Если вы заранее знаете, что вам нужна конкретная ветка, можно указать ее:

```bash
git clone -b dev https://github.com/user/project.git
# Клонируем и сразу переключаемся на ветку dev
```

Если вы хотите только одну ветку, без остальных, добавьте опцию --single-branch:

```bash
git clone -b dev --single-branch https://github.com/user/project.git
# Скачиваем только ветку dev без остальных веток и их истории
```

Обратите внимание:

- без --single-branch история других веток тоже скачивается;
- с --single-branch вы экономите место и время, но потом не сможете просто так переключиться на другие ветки без дополнительного fetch.

## Глубина клонирования и shallow clone

### Зачем ограничивать историю

Полная история большого репозитория может занимать сотни мегабайт и долго скачиваться. Если вам важны только последние коммиты, можно сделать так называемый поверхностный клон (shallow clone).

Используется опция --depth:

```bash
git clone --depth 1 https://github.com/user/big-repo.git
# Клонируем только последний коммит каждой ветки
```

Теперь давайте разберемся, что это значит:

- Git скачивает только указанное количество последних коммитов;
- предыстория обрезается, как будто проект начался с этого места;
- такая копия не знает более старых коммитов, вы не сможете к ним обратиться локально.

### Варианты использования depth

Примеры:

```bash
git clone --depth 5 https://github.com/user/project.git
# Берем последние 5 коммитов

git clone --depth 1 -b main https://github.com/user/project.git
# Один последний коммит только для ветки main

git clone --depth 50 --single-branch -b dev https://github.com/user/project.git
# 50 последних коммитов только для dev
```

Это особенно полезно в CI системах, где важен быстрый checkout и не нужна полная история.

### Ограничения shallow-клонов

Обратите внимание на важные нюансы:

- Нельзя легко посмотреть старые коммиты — их просто нет.
- Перенос веток и некоторые операции с rebase могут вести себя иначе.
- Иногда сервер может не позволять слишком маленькую глубину, но это редкость.

Если позже вы поймете, что нужна полная история, можно догрузить ее:

```bash
git fetch --unshallow
# Догрузить недостающую историю в уже существующий shallow-репозиторий
```

Комментарий:

```bash
# Эта команда превратит поверхностный клон в полноценный репозиторий
# Теперь у него будет вся история, как у обычного clone
```

## Частичные клоны и фильтрация содержимого

### Зачем нужны частичные клоны

В современных монорепозиториях размер может быть десятки гигабайт. Тянуть весь репозиторий на локальную машину неудобно. Здесь помогают частичные клоны: вы скачиваете только то, что нужно прямо сейчас.

Основная опция — --filter.

### Пример частичного клона с фильтрами

Часто хочется сначала получить только структуру и историю, а файлы подтянуть по мере обращения. Используется фильтр blob:none:

```bash
git clone --filter=blob:none --no-checkout https://github.com/user/big-repo.git
# Скачиваем структуру репозитория и историю, а содержимое файлов по запросу
```

Комментарии:

```bash
# --filter=blob:none говорит Git не скачивать содержимое файлов (blob-объекты)
# --no-checkout отключает автоматическую раскладку файлов в рабочую директорию
```

Теперь вы можете выбирать, что именно чек-аутить, а Git будет догружать только нужные файлы.

Простой пример частичного клона с выборочным checkout:

```bash
git clone --filter=blob:none https://github.com/user/big-repo.git
cd big-repo

git sparse-checkout init --cone
# Включаем разреженный checkout в режиме cone (упрощенная модель)

git sparse-checkout set src
# Чекаутим только папку src, остальное остаётся «виртуальным»
```

## Клонирование с шаблоном и bare-репозитории

### Bare-репозитории

Иногда нужно создать чистый репозиторий без рабочей копии — только данные Git. Такой формат называют bare-репозиторием. Серверные репозитории чаще всего именно такие.

Создать его с помощью clone можно так:

```bash
git clone --bare https://github.com/user/project.git project.git
# Создаем bare-репозиторий в папке project.git
```

Особенности bare-репозитория:

- нет рабочих файлов проекта, только содержимое .git;
- используется как центральный репозиторий для push и pull;
- разработчики обычно не работают напрямую в таком репозитории, а только отправляют в него изменения.

### Клонирование с шаблоном

Git позволяет использовать шаблоны (templates) — предварительные настройки, хуки и файлы, которые автоматически попадают в новый репозиторий. Это редко нужно новичкам, но полезно в командах с сложной инфраструктурой.

Пример:

```bash
git clone --template=/path/to/git-template https://github.com/user/project.git
# В качестве шаблона используем содержимое папки /path/to/git-template
```

В шаблоне могут быть:

- подготовленные хуки (scripts в .git/hooks);
- стандартные конфиги;
- файлы атрибутов и игнорируемые файлы.

## Параметры клонирования и их комбинации

### Часто используемые опции git clone

Давайте посмотрим на самые полезные флаги:

- --branch или -b — выбрать ветку для первоначального checkout;
- --single-branch — клонировать только одну ветку;
- --depth — ограничить количество коммитов;
- --shallow-since, --shallow-exclude — ограничивать историю по дате или тегу;
- --recurse-submodules — сразу инициализировать и обновить подмодули;
- --bare — создать bare-репозиторий;
- --origin — задать имя для удаленного (по умолчанию origin);
- --config — задать дополнительные настройки для нового репозитория.

### Примеры комбинирования опций

Давайте разберем несколько типичных сценариев.

#### Клонирование конкретной ветки для быстрой сборки

```bash
git clone --depth 1 -b release --single-branch \
  https://github.com/user/project.git project-release
# Берем только последний коммит ветки release в отдельную папку
```

Комментарии:

```bash
# Такой вариант часто используют в CI -
# минимум данных, быстрый checkout, достаточно для сборки релиза
```

#### Клонирование с подмодулями

Если проект использует подмодули, лучше сразу их инициализировать:

```bash
git clone --recurse-submodules https://github.com/user/project-with-submodules.git
# Клонируем основной репозиторий и все его подмодули
```

Если вы забыли указать этот флаг, можно сделать это потом:

```bash
git submodule update --init --recursive
# Инициализируем и обновляем все подмодули рекурсивно
```

#### Переименование origin

Иногда нужно другое имя для удаленного источника. Например, если вы заранее знаете, что origin будет использоваться для другого сервера:

```bash
git clone --origin upstream https://github.com/user/project.git
# Основной удаленный репозиторий будет называться upstream
```

Проверить можно так:

```bash
git remote -v
# Увидите upstream вместо origin
```

## Различия между git clone и git init + git remote + git fetch

Иногда вы можете встретить более «ручной» способ:

```bash
mkdir project
cd project
git init
git remote add origin https://github.com/user/project.git
git fetch origin
git checkout -b main origin/main
```

Комментарии:

```bash
# git init - создаем пустой локальный репозиторий
# git remote add - добавляем ссылку на удаленный
# git fetch - скачиваем историю с сервера
# git checkout - создаем локальную ветку на основе удаленной и переключаемся в нее
```

Важно понимать, что git clone по сути делает всё это за вас одним шагом. То есть:

- git clone = git init + git remote add + git fetch + git checkout;
- но еще и настраивает отслеживание веток и некоторые конфиги.

Ручной способ используют, когда нужно более тонко контролировать процесс или работать с нестандартной структурой.

## Типичные ошибки при git clone и как их решать

### Ошибка доступа по HTTPS

Распространенная ситуация — ошибка аутентификации:

- неверный логин или токен;
- истекший токен;
- аккаунт не имеет доступа к репозиторию.

Что можно сделать:

1. Проверить, что вы можете открыть URL репозитория в браузере.
2. Убедиться, что используете актуальный personal access token.
3. Настроить менеджер учетных данных Git, чтобы не вводить пароль каждый раз:

```bash
git config --global credential.helper store
# Будет хранить учетные данные в текстовом файле (подходит для не очень чувствительных окружений)
```

Или более безопасный менеджер (например, на Windows Git Credential Manager).

### Ошибка подключения по SSH

Частые причины:

- не настроены SSH ключи;
- не добавлен публичный ключ на Git-сервер;
- неправильный URL (например, https вместо git@).

Шаги проверки:

```bash
ssh -T git@github.com
# Проверяем, что SSH ключ корректен и доступ есть
```

Если получаете сообщение вроде Permission denied (publickey), нужно:

1. Сгенерировать ключ ssh-keygen, если его нет.
2. Добавить содержимое файла .pub в настройки SSH на Git-сервере.
3. Убедиться, что используете SSH-URL, а не HTTPS.

### Ошибка SSL или проблемы с прокси

В корпоративных сетях нередко мешает прокси или собственный сертификат.

Часто вы увидите что-то вроде SSL certificate problem. Решения зависят от политики безопасности, но общая логика:

- настроить доверие к корпоративному корневому сертификату;
- при необходимости сконфигурировать Git на использование системного хранилища сертификатов.

Иногда временно используют:

```bash
git config --global http.sslVerify false
# Отключить проверку SSL (не рекомендуется для постоянного использования)
```

Лучше все же корректно установить корневой сертификат и не отключать проверку.

### Ошибка «repository not found»

Это значит, что по указанному URL репозиторий не найден:

- опечатка в имени пользователя или репозитория;
- репозиторий приватный, а аутентификация не выполнена;
- недостаточные права чтения.

Проверьте URL в браузере: если проект не открывается, уточните путь или доступ.

## Практические сценарии использования git clone

### Клонирование своего репозитория для разработки

Классический рабочий сценарий:

```bash
git clone git@github.com:your-user/your-project.git
cd your-project

# Дальше вы создаете ветки, вносите изменения, коммитите и отправляете на сервер
git checkout -b feature/new-api
# Создаем ветку для новой фичи

# Вносим изменения в файлы, затем:
git commit -am "Implement new API"
# Фиксируем изменения

git push -u origin feature/new-api
# Отправляем ветку на сервер и связываем ее с удаленной
```

### Клонирование форка и работа с upstream

Когда вы работаете с форками, схема обычно такая:

1. На GitHub вы делаете fork основного репозитория.
2. Клонируете свой форк.
3. Добавляете ссылку на оригинальный репозиторий как upstream.

Пример:

```bash
git clone git@github.com:your-user/project-fork.git
cd project-fork

git remote add upstream git@github.com:original-owner/project.git
# Добавляем оригинальный репозиторий как upstream

git remote -v
# Проверяем, что есть origin (ваш форк) и upstream (оригинал)
```

Теперь вы можете периодически подтягивать обновления из основного репозитория:

```bash
git fetch upstream
git checkout main
git merge upstream/main
# Сливаем изменения из upstream/main в ваш main
```

### Клонирование для чтения кода без прав записи

Если у вас нет прав записи, но нужно просто изучить исходники, вы можете клонировать публичный репозиторий по HTTPS:

```bash
git clone https://github.com/torvalds/linux.git
# Скачиваем исходный код ядра Linux только для чтения
```

Вы по-прежнему можете создавать локальные ветки, делать коммиты, но не сможете отправить их обратно, если нет прав push.

## Кратко о производительности и выборе стратегии клонирования

Чтобы подобрать оптимальную стратегию git clone, ориентируйтесь на такие вопросы:

- Нужна ли вам вся история или только последние коммиты?
- Нужны ли все ветки или только одна?
- Насколько большой репозиторий по размеру?
- Какую роль вы выполняете — активная разработка, чтение кода, CI?

Практические рекомендации:

- Для активной разработки на рабочей машине — полный clone (без depth), все ветки по умолчанию.
- Для CI систем — git clone с --depth 1 или ограниченной историей, чтобы ускорить сборку.
- Для огромных монорепозиториев — частичные клоны (--filter=blob:none, sparse-checkout).
- Для серверных репозиториев — clone --bare.

---

## Частозадаваемые технические вопросы по теме git clone

### Как склонировать только одну папку из репозитория

Напрямую git clone так не умеет, но можно использовать разреженный checkout:

```bash
git clone --filter=blob:none https://github.com/user/project.git
cd project
git sparse-checkout init --cone
git sparse-checkout set path/to/folder
# Теперь у вас в рабочей директории будет только указанная папка
```

### Как изменить URL origin после клонирования

Если вы сначала клонировали по HTTPS, а потом настроили SSH, можно просто заменить URL:

```bash
git remote set-url origin git@github.com:user/project.git
# Меняем URL origin на SSH версию
```

Проверяем:

```bash
git remote -v
# Убедитесь, что теперь используется новый URL
```

### Как продолжить работу с shallow-клоном и получить полную историю позже

Если вы начали с поверхностного клона:

```bash
git clone --depth 1 https://github.com/user/project.git
```

А затем понадобилась полная история, выполните:

```bash
cd project
git fetch --unshallow
# Получаем недостающую историю и превращаем shallow-клон в полноценный
```

Если сервер не поддерживает unshallow, можно использовать:

```bash
git fetch --depth=1000
# Постепенно увеличиваем глубину истории
```

### Как клонировать репозиторий в уже существующую пустую папку

Вам нужно зайти в папку и указать точку как целевой каталог:

```bash
mkdir my-project
cd my-project
git clone https://github.com/user/project.git .
# Клонируем в текущий каталог (он должен быть пустым)
```

Если в папке уже есть файлы, лучше сначала сделать резервную копию или использовать git init и добавлять файлы вручную.

### Как клонировать только теги без веток

Можно сделать клон без checkout и затем ограничить fetch только тегами:

```bash
git clone --no-checkout https://github.com/user/project.git
cd project
git fetch --tags --depth=1
# Скачиваем только теги и минимальную историю
```

После этого вы сможете checkout нужный тег:

```bash
git checkout tags/v1.0.0
# Переходим к состоянию репозитория на момент релиза v1.0.0
```