---
metaTitle: Понимание Public API в современных веб сервисах
metaDescription: Узнайте как спроектировать и использовать Public API public-api - разберем ключевые принципы архитектуры версионирование безопасность документацию и практические примеры
author: Олег Марков
title: Public API - что это такое и как с ним работать на практике
preview: Исследуйте мир Public API - разберитесь как устроены открытые интерфейсы сервисов какие паттерны используются и как безопасно интегрировать их в свои приложения
---

## Введение

Public API (часто пишут как public-api) — это открытый программный интерфейс, к которому могут обращаться внешние системы и разработчики. Через такой интерфейс вы позволяете другим приложениям получать данные вашего сервиса или выполнять определенные операции.

Public API сегодня есть почти у всего — от платёжных систем и облачных провайдеров до социальных сетей и геосервисов. Если вы интегрируете сторонний сервис или собираетесь открыть свой, вам полезно понимать, как устроен public-api, какие у него типичные возможности, как с ним работать и на что обратить внимание.

В этой статье мы разберем:

- какие есть виды Public API и чем они отличаются;
- общие принципы REST/HTTP API, которые чаще всего используются;
- структуру запросов и ответов;
- аутентификацию и авторизацию;
- версионирование и совместимость;
- типичные эндпоинты и сценарии использования;
- ошибки, лимиты и практики безопасной работы.

Я буду опираться на типичный HTTP REST public-api, так как он наиболее распространен. Но большинство принципов применимо и к другим видам публичных API.

## Что такое Public API и зачем он нужен

### Определение и ключевые свойства

Public API — это интерфейс взаимодействия с системой, который:

- **документирован** — у вас есть официальное описание доступных методов, параметров и формата ответов;
- **стабилен** — поведение и контракт стараются не ломать от релиза к релизу;
- **доступен извне** — с ним могут работать внешние клиенты, не являющиеся частью вашего бэкенда;
- **подконтролен** — доступ защищен ключами, токенами, лимитами и политиками.

Такой API позволяет:

- интегрировать ваш сервис в чужие продукты;
- строить экосистему из сторонних приложений;
- автоматизировать операции, которые пользователи обычно делают через UI;
- разделять монолитные системы на независимые сервисы с четкими контрактами.

### Виды API по уровню открытости

Для понимания важно различать:

- **Private API** — используется только внутри компании или внутри одного приложения.
- **Partner API** — доступен ограниченному кругу партнеров по договорам.
- **Public API** — открыт для широкой аудитории разработчиков, обычно с регистрацией и выдачей ключей.

На практике один и тот же backend может иметь и публичную, и внутреннюю часть API, но public-api всегда документируется и поддерживается как продукт.

## Архитектурные подходы к Public API

### REST как де-факто стандарт

Чаще всего public-api строят в стиле REST поверх HTTP. Это не строгий стандарт, а набор принципов, но в результате API выглядит примерно так:

- ресурсы представлены как **URL** (например, `/v1/users`, `/v1/orders/123`);
- операции выполняются стандартными методами HTTP;
- данные передаются в формате JSON (иногда XML, но сейчас реже);
- используется кэширование, коды ответа и заголовки HTTP.

Классическое сопоставление методов HTTP и действий:

- GET — получить ресурс или список;
- POST — создать новый ресурс;
- PUT — полностью обновить существующий ресурс;
- PATCH — частично обновить ресурс;
- DELETE — удалить ресурс.

Смотрите, я покажу вам простой пример того, как может выглядеть публичный REST API. Представим, что у нас есть сервис задач:

- `GET /v1/tasks` — получить список задач;
- `POST /v1/tasks` — создать задачу;
- `GET /v1/tasks/{id}` — получить задачу по идентификатору;
- `PATCH /v1/tasks/{id}` — изменить поля задачи;
- `DELETE /v1/tasks/{id}` — удалить задачу.

### Альтернативы: GraphQL, gRPC, Webhooks

Иногда в дополнение к REST public-api предоставляет и другие варианты:

- **GraphQL** — позволяет клиентам самим выбирать структуру ответа, запрашивая сразу нужные поля и связи. Удобно, когда хочется гибкости на стороне клиента.
- **gRPC** — бинарный протокол поверх HTTP/2, дает высокую производительность, но менее удобен для браузеров и новичков.
- **Webhooks** — механизм обратных вызовов: ваш сервис отправляет HTTP-запросы на URL клиента при определенных событиях (например, “платеж завершен”).

Чаще всего сначала появляется REST public-api, а более специфичные варианты добавляют для продвинутых интеграций.

## Типовая структура Public API

### Базовый URL и версии

У большинства public-api есть базовый URL и версия:

- базовый URL — общий префикс, например:
  - `https://api.example.com/`
  - `https://public-api.example.com/`
- версия — чаще всего в пути:
  - `/v1/`
  - `/v2/`

Так получается, что полный адрес может выглядеть так:

- `https://api.example.com/v1/users`
- `https://api.example.com/v1/orders/123`

Версионирование важно, чтобы вы могли развивать API, не ломая существующих клиентов.

### Ресурсы и коллекции

Public-api обычно оперирует ресурсами:

- коллекции: `/v1/users`, `/v1/orders`, `/v1/products`;
- конкретные сущности: `/v1/users/42`, `/v1/orders/12345`.

Давайте посмотрим на типичный набор эндпоинтов для сущности “пользователь”:

- `GET /v1/users` — список пользователей;
- `POST /v1/users` — создание пользователя;
- `GET /v1/users/{id}` — получение пользователя;
- `PATCH /v1/users/{id}` — изменение конкретного пользователя;
- `DELETE /v1/users/{id}` — удаление пользователя.

### Параметры запросов: path, query, headers, body

Условно параметры делят на несколько типов:

- **Path-параметры** — часть пути:
  - `/v1/users/{id}`
  - `/v1/organizations/{org_id}/users/{user_id}`
- **Query-параметры** — в строке запроса:
  - `?page=2&limit=50`
  - `?sort=created_at&order=desc`
- **Заголовки (headers)** — служебная информация:
  - `Authorization`
  - `Accept`
  - `X-Request-Id`
- **Тело запроса (body)** — данные в формате JSON или другого формата:
  - обычно используется с POST/PUT/PATCH.

Теперь вы увидите, как это может выглядеть в реальном запросе.

Пример запроса создания задачи через public-api:

```http
POST /v1/tasks HTTP/1.1
Host: api.todo.example.com
Authorization: Bearer <access_token>
Content-Type: application/json
Accept: application/json

{
  "title": "Написать статью про public-api",
  "due_date": "2025-01-15",
  "priority": "high"
}
```

Ответ сервера:

```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "id": 123,
  "title": "Написать статью про public-api",
  "due_date": "2025-01-15",
  "priority": "high",
  "status": "open",
  "created_at": "2025-01-10T12:00:00Z"
}
```

Как видите, сервер возвращает созданный ресурс с идентификатором и дополнительными полями.

## Аутентификация и авторизация в Public API

### API-ключи

Самый простой вариант — **API key**. Это строка, которую вы получаете в кабинете разработчика и передаете в каждом запросе.

Чаще всего ключ передается:

- в заголовке:
  - `X-API-Key: your_api_key_here`
- или в query-параметре (менее безопасно):
  - `?api_key=your_api_key_here`

Пример:

```http
GET /v1/profile HTTP/1.1
Host: api.example.com
X-API-Key: 1234567890abcdef
Accept: application/json
```

Комментарии:

- `X-API-Key` — заголовок, куда вы помещаете ключ;
- сервер по этому ключу находит ваш аккаунт и проверяет права;
- ключ храните только на сервере, а не в публичном фронтенд-коде.

### OAuth 2.0 и Bearer-токены

Для более сложных сценариев используют OAuth 2.0 и токены доступа.

Схема в общих чертах:

1. Клиент (ваше приложение) перенаправляет пользователя на страницу авторизации сервиса.
2. Пользователь логинится и дает разрешение на доступ.
3. Сервис возвращает авторизационный код, по которому клиент получает access token (и иногда refresh token).
4. Ваше приложение обращается к public-api уже с токеном.

Токен передается в заголовке Authorization:

```http
GET /v1/me HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Accept: application/json
```

Комментарии:

// Authorization: Bearer <token> — здесь указывается токен доступа  
// Сервер по токену определяет пользователя и проверяет срок действия токена

### Роли и ограничения доступа

Даже при наличии ключа или токена не все методы могут быть доступны. Разделяют:

- read-only ключи — могут только читать данные;
- write-ключи — могут изменять и создавать ресурсы;
- ключи с ограничением по IP, организациям, областям данных.

В документации public-api обычно отдельно описано, какие токены или ключи подходят для каких эндпоинтов.

## Формат данных и структура ответов

### JSON как основной формат

Почти все современные public-api используют JSON. Условный ответ может выглядеть так:

```json
{
  "id": 42,
  "email": "user@example.com",
  "name": "Ivan Petrov",
  "created_at": "2025-01-10T12:00:00Z",
  "is_active": true
}
```

Здесь:

// id — идентификатор ресурса в базе  
// email и name — основные атрибуты  
// created_at — дата и время создания в формате ISO 8601  
// is_active — булев флаг, показывающий состояние

### Обертки данных: data, meta, links

Многие public-api оборачивают данные в дополнительные уровни:

```json
{
  "data": {
    "id": 42,
    "email": "user@example.com"
  },
  "meta": {
    "request_id": "b2d6e760-5a38-11ef-9a3e-0242ac120002"
  }
}
```

Комментарии:

// data — полезная нагрузка, сам ресурс  
// meta — служебные данные (идентификатор запроса, статистика и т.п.)

Для списков могут добавляться `links` и информация о пагинации:

```json
{
  "data": [
    {
      "id": 1,
      "title": "Первая задача"
    },
    {
      "id": 2,
      "title": "Вторая задача"
    }
  ],
  "meta": {
    "total": 42,
    "page": 1,
    "per_page": 2
  },
  "links": {
    "next": "https://api.todo.example.com/v1/tasks?page=2&per_page=2",
    "prev": null
  }
}
```

Здесь я размещаю пример, чтобы вам было проще понять, как API подсказывает клиенту, как перейти к следующей странице.

## Пагинация, фильтрация и сортировка

### Пагинация

Чтобы не отдавать тысячи записей за раз, public-api почти всегда поддерживает пагинацию.

Есть два популярных подхода:

1. **Offset / limit**  
   Пример: `GET /v1/tasks?offset=0&limit=50`  
   Плюсы — проще для понимания. Минусы — тяжелые запросы на больших offset.
2. **Page / per_page**  
   Пример: `GET /v1/tasks?page=2&per_page=20`.

Теперь давайте посмотрим, как это может выглядеть целиком:

```http
GET /v1/tasks?page=2&per_page=3 HTTP/1.1
Host: api.todo.example.com
Authorization: Bearer <token>
Accept: application/json
```

Ответ:

```json
{
  "data": [
    {
      "id": 4,
      "title": "Четвертая задача"
    },
    {
      "id": 5,
      "title": "Пятая задача"
    },
    {
      "id": 6,
      "title": "Шестая задача"
    }
  ],
  "meta": {
    "page": 2,
    "per_page": 3,
    "total": 12
  }
}
```

### Фильтрация

Фильтры позволяют отбирать только нужные данные. Обычно это query-параметры:

- `GET /v1/tasks?status=completed`
- `GET /v1/tasks?due_date_from=2025-01-01&due_date_to=2025-01-31`
- `GET /v1/tasks?priority=high&assignee_id=42`

Иногда используют вложенный синтаксис: `filter[status]=completed`, `filter[priority]=high`.

### Сортировка

Сортировка тоже задается параметрами:

- `GET /v1/tasks?sort=created_at&order=desc`
- `GET /v1/tasks?sort=-created_at` — минус означает убывание.

Важно смотреть в документации конкретного public-api, какую схему фильтров и сортировки он поддерживает.

## Обработка ошибок в Public API

### Коды статуса HTTP

Public-api активно использует коды HTTP. Ниже список наиболее часто встречающихся:

- 200 OK — успешный запрос;
- 201 Created — ресурс создан;
- 204 No Content — все ок, но без тела ответа (часто после DELETE);
- 400 Bad Request — ошибка в запросе (неправильные данные, отсутствие обязательного поля);
- 401 Unauthorized — нет или неверная аутентификация;
- 403 Forbidden — аутентификация есть, но прав недостаточно;
- 404 Not Found — ресурс не найден;
- 409 Conflict — конфликт (например, дубликат уникального поля);
- 422 Unprocessable Entity — данные валидны по синтаксису, но не проходят бизнес-валидацию;
- 429 Too Many Requests — превышен лимит запросов;
- 500 Internal Server Error — внутренняя ошибка сервера.

### Структура ответа об ошибке

Хороший public-api возвращает подробное описание точной проблемы. Типичный пример:

```json
{
  "error": {
    "code": "validation_error",
    "message": "Некоторые поля не прошли проверку",
    "details": [
      {
        "field": "email",
        "message": "Неверный формат email"
      },
      {
        "field": "password",
        "message": "Минимальная длина пароля 8 символов"
      }
    ]
  }
}
```

Комментарии:

// error.code — машинно-читаемый код можно использовать в обработчике  
// error.message — общее описание ошибки для человека  
// details — массив конкретных проблем по полям

Теперь давайте разберемся на примере, как это обрабатывать на клиенте.

Псевдокод на JavaScript:

```js
async function createUser(payload) {
  const response = await fetch("https://api.example.com/v1/users", {
    method: "POST",
    headers: {
      "Content-Type": "application/json", // Говорим серверу что отправляем JSON
      "Accept": "application/json"        // Просим вернуть ответ в JSON
    },
    body: JSON.stringify(payload)         // Сериализуем объект в строку JSON
  });

  if (!response.ok) {                     // Проверяем код статуса (2xx = ok)
    const error = await response.json();  // Считываем тело ошибки
    // Здесь можно показать пользователю сообщения из error.error.details
    throw new Error(error.error.message); // Бросаем исключение с общим текстом
  }

  return response.json();                 // При успехе возвращаем распарсенный JSON
}
```

## Лимиты, квоты и rate limiting

### Зачем нужны ограничения

Публичный API открыт для множества клиентов, поэтому:

- нужно защищать сервис от перегрузки;
- нужно не дать одному клиенту “съесть” все ресурсы;
- необходимо ограничивать злоупотребления и ботов.

Для этого вводят **лимиты по количеству запросов** (rate limiting) и **квоты**.

### Типы лимитов

Обычно встречаются:

- N запросов в минуту или в секунду для одного ключа или IP;
- ограничения на число одновременных соединений;
- ограничения на объем переданных данных.

Сервер может возвращать специальный код и заголовки:

```http
HTTP/1.1 429 Too Many Requests
Retry-After: 10
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1736851200
```

Комментарии:

// 429 Too Many Requests — вы превысили лимит  
// Retry-After — через сколько секунд можно попробовать снова  
// X-RateLimit-Limit — общий лимит запросов  
// X-RateLimit-Remaining — сколько запросов осталось в текущем окне  
// X-RateLimit-Reset — время в Unix-формате когда лимит сбросится

На стороне клиента важно:

- логировать такие ошибки;
- делать повторные попытки (retry) с паузой;
- не запускать бесконтрольные циклы запросов.

## Версионирование Public API

### Зачем нужны версии

Public-api нельзя “взять и изменить” без последствий. У вас уже есть клиенты, которые опираются на определенную структуру данных и поведение. Поэтому:

- новые несовместимые изменения выносите в новую версию;
- старую версию поддерживаете какое-то время;
- заранее уведомляете клиентов о планируемой “смерти” версии.

### Подходы к версионированию

Самый распространенный — версия в пути:

- `/v1/users`
- `/v2/users`

Иногда version указывают в заголовке или в параметре, но путь — самый понятный вариант для большинства.

Типичные причины появления новой версии:

- вы меняете формат поля (например, дату с строки на число);
- вы переименовываете ключевые поля;
- вы серьезно меняете логику работы методов.

### Стратегия миграции клиентов

Хороший public-api:

- помечает часть полей как deprecated до полного удаления;
- предоставляет период, когда v1 и v2 работают параллельно;
- дает подробную инструкцию “как перейти с v1 на v2”.

На клиенте важно:

- не хардкодить URL без версии;
- следить за новостями API-провайдера;
- планировать миграции заранее.

## Документация и инструменты

### Официальная документация

Работа с public-api почти всегда начинается с документации. В ней вы ищете:

- базовый URL и версии;
- способы аутентификации;
- описание ресурсов и методов;
- примеры запросов и ответов;
- коды ошибок и форматы;
- лимиты и правила использования.

Хорошую документацию часто строят на OpenAPI (Swagger). Вы можете:

- посмотреть интерактивное описание;
- выполнить тестовый запрос прямо из браузера;
- сгенерировать клиентскую библиотеку.

### SDK и клиентские библиотеки

Многие провайдеры public-api публикуют SDK для разных языков:

- JavaScript/TypeScript;
- Python;
- Java;
- Go;
- PHP и т.д.

Использование SDK:

- избавляет от ручного формирования HTTP-запросов;
- скрывает детали аутентификации;
- упрощает обработку ошибок.

Например, вместо ручного запроса:

```js
// Ручной запрос к API
const response = await fetch("https://api.example.com/v1/users/42", {
  headers: {
    "Authorization": "Bearer " + token,    // Передаем токен доступа
    "Accept": "application/json"          // Просим JSON
  }
});
const user = await response.json();       // Разбираем JSON
```

Через SDK вы можете писать что-то вроде:

```js
// Пример условного SDK
import { ApiClient } from "@example/public-api"; // Импортируем клиент SDK

const client = new ApiClient({                  // Создаем экземпляр клиента
  accessToken: token                            // Передаем токен в настройки
});

const user = await client.users.getById(42);    // Вызываем метод SDK для получения пользователя
```

Обратите внимание, как этот фрагмент кода избавляет вас от повторяющегося кода запросов и обработки заголовков.

## Практический пример: простой клиент для Public API

Теперь давайте перейдем к небольшому практическому примеру. Представим, что у нас есть public-api задач:

- базовый URL: `https://api.todo.example.com/v1/`;
- аутентификация через API key;
- несколько методов:
  - `GET /tasks`
  - `POST /tasks`
  - `GET /tasks/{id}`.

Покажу вам, как это реализовано на практике на примере клиента на Go.

### Настройка клиента

Создадим простую структуру клиента:

```go
package todoapi

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

// Client описывает клиента для работы с public-api задач
type Client struct {
	BaseURL    string       // Базовый URL API например https://api.todo.example.com/v1
	APIKey     string       // API ключ для аутентификации
	HTTPClient *http.Client // HTTP клиент можно переопределить при необходимости
}

// NewClient создает новый экземпляр клиента с разумными настройками по умолчанию
func NewClient(baseURL, apiKey string) *Client {
	return &Client{
		BaseURL: baseURL,
		APIKey:  apiKey,
		HTTPClient: &http.Client{
			Timeout: 10 * time.Second, // Устанавливаем таймаут чтобы запросы не висели бесконечно
		},
	}
}
```

### Модель данных задачи

Опишем структуру задачи, как ее возвращает public-api:

```go
// Task представляет задачу в системе
type Task struct {
	ID        int       `json:"id"`         // Уникальный идентификатор задачи
	Title     string    `json:"title"`      // Краткое название задачи
	DueDate   string    `json:"due_date"`   // Дата дедлайна в виде строки ISO 8601
	Priority  string    `json:"priority"`   // Приоритет задачи например low medium high
	Status    string    `json:"status"`     // Статус задачи например open completed
	CreatedAt time.Time `json:"created_at"` // Время создания задачи
}
```

### Получение списка задач

Теперь реализуем метод `GET /tasks`:

```go
// ListTasksOptions описывает параметры запроса списка задач
type ListTasksOptions struct {
	Page    int // Номер страницы пагинации
	PerPage int // Размер страницы
	Status  string // Необязательный фильтр по статусу
}

// ListTasks отвечает за получение списка задач из public-api
func (c *Client) ListTasks(opts ListTasksOptions) ([]Task, error) {
	// Формируем URL с учетом параметров пагинации и фильтрации
	url := fmt.Sprintf("%s/tasks?page=%d&per_page=%d", c.BaseURL, opts.Page, opts.PerPage)
	if opts.Status != "" {
		url += "&status=" + opts.Status // Добавляем фильтр по статусу если нужно
	}

	// Создаем новый HTTP запрос
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err) // Оборачиваем ошибку для контекста
	}

	// Добавляем заголовки аутентификации и формата
	req.Header.Set("X-API-Key", c.APIKey)       // Передаем API ключ
	req.Header.Set("Accept", "application/json") // Просим JSON в ответе

	// Отправляем запрос
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close() // Обязательно закрываем тело ответа

	// Проверяем успешность статуса
	if resp.StatusCode != http.StatusOK {
		// Здесь вы можете разобрать тело ошибки и вернуть более подробную информацию
		return nil, fmt.Errorf("unexpected status: %s", resp.Status)
	}

	// Распарсиваем JSON в структуру
	var result struct {
		Data []Task `json:"data"` // Предполагаем что API оборачивает задачи в поле data
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}

	return result.Data, nil // Возвращаем слайс задач
}
```

Давайте посмотрим, что происходит в этом примере:

- мы формируем URL с учетом пагинации и фильтров;
- добавляем заголовок с API-ключом;
- отправляем запрос и проверяем код ответа;
- декодируем JSON-ответ в структуру Go.

### Создание задачи

Теперь реализуем `POST /tasks`:

```go
// CreateTaskRequest описывает данные для создания задачи
type CreateTaskRequest struct {
	Title    string `json:"title"`     // Заголовок задачи
	DueDate  string `json:"due_date"`  // Дата дедлайна
	Priority string `json:"priority"`  // Приоритет
}

// CreateTask создает новую задачу через public-api
func (c *Client) CreateTask(reqData CreateTaskRequest) (*Task, error) {
	// Сериализуем тело запроса в JSON
	bodyBytes, err := json.Marshal(reqData)
	if err != nil {
		return nil, fmt.Errorf("marshal request: %w", err)
	}

	// Формируем URL
	url := c.BaseURL + "/tasks"

	// Создаем HTTP запрос с телом
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(bodyBytes))
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}

	// Устанавливаем заголовки
	req.Header.Set("X-API-Key", c.APIKey)                // API ключ для аутентификации
	req.Header.Set("Content-Type", "application/json")   // Сообщаем формат тела запроса
	req.Header.Set("Accept", "application/json")         // Просим вернуть JSON

	// Отправляем запрос
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("do request: %w", err)
	}
	defer resp.Body.Close()

	// Проверяем код статуса
	if resp.StatusCode != http.StatusCreated {
		return nil, fmt.Errorf("unexpected status: %s", resp.Status)
	}

	// Распарсиваем ответ с созданной задачей
	var result struct {
		Data Task `json:"data"` // Предполагаем что API возвращает задачу в поле data
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}

	return &result.Data, nil
}
```

Этот пример показывает базовый шаблон работы с public-api:

- описываем модели структур данных;
- пишем функцию для каждого эндпоинта;
- аккуратно обрабатываем ошибки и коды ответа;
- даем вызывающему коду уже готовые структуры, а не сырые JSON-строки.

## Безопасность при работе с Public API

### Хранение секретов

Когда вы используете public-api, у вас обычно есть:

- API ключ;
- client_id / client_secret (для OAuth);
- токены доступа и обновления.

Рекомендации:

- не храните секреты в репозитории;
- используйте переменные окружения или менеджеры секретов;
- не вшивайте ключи в клиентский JavaScript, если можно делать запросы через backend.

### HTTPS и защита данных

Public-api почти всегда работает только по HTTPS:

- это защищает данные от перехвата;
- проверяйте, что вы не отключаете проверку сертификата в продакшене;
- не передавайте чувствительные данные по HTTP.

### Минимизация прав

Если API поддерживает разные уровни доступа:

- создавайте отдельные ключи/приложения под разные задачи;
- давайте только те права, которые реально нужны;
- регулярно ревизуйте и отзывайте неиспользуемые ключи.

## Заключение

Public API — это продуманный, документированный и стабильный интерфейс, который позволяет внешним приложениям взаимодействовать с вашим сервисом. Важно понимать его ключевые элементы:

- ресурсы и эндпоинты;
- аутентификацию и авторизацию;
- структуру запросов и ответов;
- пагинацию, фильтры и сортировку;
- обработку ошибок и лимиты;
- версионирование и поддержку.

Когда вы используете чужой public-api, внимательно изучайте документацию, не игнорируйте обработку ошибок и не забывайте про лимиты. Когда вы разрабатываете свой, думайте о нем как о продукте: с четкими контрактами, понятной документацией и продуманной стратегией развития.

---

## Частозадаваемые технические вопросы по теме и ответы

### Как правильно тестировать интеграцию с Public API без риска повредить боевые данные

Многие public-api предоставляют sandbox окружение. В документации ищите отдельный базовый URL вида `https://sandbox.api.example.com`. Используйте его для разработки и автотестов. Если sandbox нет, создайте отдельный тестовый аккаунт и помечайте все тестовые данные специальными префиксами, чтобы их можно было легко удалить. Для автотестов на своей стороне можно мока́ть ответы API с помощью HTTP-фикстур или библиотек типа httptest (в Go) или nock (в Node.js).

### Что делать если Public API резко замедлился и вызывает таймауты в моем приложении

Во-первых, увеличьте таймаут клиента до разумных значений и добавьте повторные попытки (retry) с экспоненциальной паузой. Во-вторых, по возможности кэшируйте результаты запросов, которые редко меняются. В-третьих, оберните обращения к API в отдельную службу или слой с очередью, чтобы не блокировать основной поток обработки. И обязательно логируйте время ответа и коды статуса, чтобы при необходимости отправить провайдеру API логи для анализа.

### Как обрабатывать несовместимые изменения при обновлении версии public-api

Сначала реализуйте поддержку новой версии параллельно со старой. Вынесите работу с каждой версией в отдельные модули или классы. Добавьте фиче-флаг, который позволит переключать часть трафика на новую версию. После успешного тестирования постепенно переводите все вызовы на новую версию и только потом удаляйте код старой. Важно заранее описать маппинг полей между версиями и покрыть критичные сценарии интеграционными тестами.

### Как правильно логировать работу с Public API чтобы упростить отладку

Логируйте для каждого запроса как минимум метод, путь, код ответа, время выполнения и идентификатор запроса (если API его возвращает). Также сохраняйте выдержки из тела ошибок, но не логируйте чувствительные данные (токены, пароли, персональные данные). Желательно использовать структурированные логи в формате JSON, чтобы потом фильтровать их по полям. Если провайдер использует заголовок корреляции (например, X-Request-Id), добавляйте его в свои логи.

### Как поступать если документация public-api устарела и не соответствует реальному поведению

Во-первых, уточните фактическое поведение с помощью инструментов вроде curl или Postman и зафиксируйте его в своих внутренних заметках. Во-вторых, проверьте официальный трекер багов или форум разработчиков — возможно, проблема уже известна. В-третьих, оформите обращение к поддержке провайдера, приложив примеры запросов и ответов. На своей стороне закладывайтесь на фактическое поведение, но оставьте абстракцию (обертку), чтобы легче адаптироваться, если провайдер приведет API в соответствие с документацией.