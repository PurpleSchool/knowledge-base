---
metaTitle: Переименование ветки в Git - полное руководство по git branch -m
metaDescription: Подробное объяснение как переименовать ветку в Git с помощью команды git branch -m - примеры типичных сценариев и разбор частых ошибок
author: Олег Марков
title: Переименование ветки в Git - команда git branch -m
preview: Разбор команды git branch -m - как безопасно переименовать ветку в Git на локальном и удаленном репозитории и что делать чтобы не потерять историю
---

## Введение

Переименование ветки в Git кажется простой задачей, пока не начинаете делать это в реальном проекте, где есть общий репозиторий, ветку кто-то уже вытянул себе локально, а в CI настроены автоматические сборки по имени ветки.  

Смотрите, здесь я разберу, как работает команда git branch -m, чем она отличается от похожих вариантов, что происходит "под капотом" и какие шаги нужно выполнить, чтобы аккуратно переименовать ветку не только локально, но и на удаленном сервере (например, в GitHub, GitLab или Bitbucket).

Мы по шагам разберем:

- базовый синтаксис git branch -m  
- переименование текущей и другой (неактивной) ветки  
- полную замену старой ветки новой на удаленном репозитории  
- особенности переименования основной ветки (master, main, develop)  
- возможные ошибки и способы их обойти  

В конце вы получите набор практических сценариев, которые можно просто "копировать и использовать" в повседневной работе.

## Что делает git branch -m

Команда git branch используется для работы с локальными ветками: их создания, удаления, просмотра и переименования.  

Опция -m (от слова "move") как раз и отвечает за переименование ветки.

По сути, git branch -m:

- меняет имя ссылки на ветку в локальном репозитории  
- не меняет историю коммитов (хэш коммитов остается тем же)  
- не создает новую ветку, а именно "переименовывает" существующую  

Важно понимать: для Git ветка — это просто указатель (ссылка) на коммит. Когда вы переименовываете ветку, вы изменяете имя этой ссылки, но не сам набор коммитов.

### Базовый синтаксис

Давайте посмотрим на основной синтаксис:

```bash
# Общий вид
git branch -m <старое_имя> <новое_имя>  # Переименовать указанную ветку

# Сокращенный вариант
git branch -m <новое_имя>              # Переименовать текущую ветку
```

Комментарии:

- В первом случае вы явно указываете, какую ветку переименовываете.  
- Во втором случае — переименовывается именно та ветка, в которой вы сейчас находитесь (HEAD указывает на нее).

Git не меняет никакие удаленные ветки при выполнении git branch -m. Все изменения происходят только локально. Это важный момент, к которому мы еще вернемся.

## Переименование текущей ветки

Самый распространенный сценарий — вы работаете в ветке, понимаете, что назвали ее неудачно, и хотите быстро исправить имя.

### Проверка текущей ветки

Сначала посмотрите, в какой ветке вы находитесь:

```bash
git status
# В выводе вы увидите строку вида:
# On branch feature/old-name
```

Либо можно использовать:

```bash
git branch
# Текущая ветка будет отмечена звездочкой
# * feature/old-name
#   develop
#   main
```

### Переименование без указания старого имени

Теперь переименуем текущую ветку:

```bash
git branch -m feature/new-name
# -m говорит Git - переименовать ветку, в которой мы сейчас находимся
```

Как видите, здесь мы не указываем старое имя. Git сам понимает, что нужно работать с текущей веткой.

Проверяем результат:

```bash
git branch
# * feature/new-name
#   develop
#   main
```

Вся история, незакоммиченные изменения и т.д. сохраняются. Только имя ветки стало другим.

### Что происходит с удаленной веткой

Если у вас уже была ветка с таким же именем на удаленном репозитории, git branch -m не будет:

- ни трогать удаленную ветку  
- ни автоматически создавать новую удаленную ветку  

Это чисто локальное изменение. Чтобы синхронизировать новое имя с сервером, вам нужны дополнительные команды, о которых я расскажу чуть позже.

## Переименование другой (неактивной) ветки

Иногда нужно переименовать ветку, в которой вы сейчас не находитесь. Например, вы сидите в develop, но хотите переименовать старую feature/123 в feature/123-bugfix.

Смотрите, как это делается.

### Обязательное условие

Переименовать можно только локальную ветку, которая существует в вашем репозитории.

Проверим список веток:

```bash
git branch
#   develop
#   feature/123
# * main
```

Предположим, что вы сейчас в main, но хотите переименовать feature/123.

### Переименование явным указанием старого имени

Действуем так:

```bash
git branch -m feature/123 feature/123-bugfix
# Первый аргумент - старое имя ветки
# Второй аргумент - новое имя ветки
```

Теперь проверяем:

```bash
git branch
#   develop
#   feature/123-bugfix
# * main
```

Обратите внимание:

- Вы остались в той же ветке, где были (main).  
- Переименовалась только указанная ветка.  

## Разница между -m и -M

Кроме -m у команды git branch есть еще опция -M (большая буква M).  

Давайте разберемся, в чем разница. Это важно для ситуаций, когда уже существует ветка с целевым именем.

### Поведение -m

Опция -m:

- переименует ветку  
- но если ветка с новым именем уже существует — выдаст ошибку и ничего не изменит  

Пример:

```bash
git branch
#   feature/login
#   feature/login-new
# * main

git branch -m feature/login feature/login-new
# fatal: A branch named 'feature/login-new' already exists.
# Git отказывается перезаписать существующую ветку
```

### Поведение -M

Опция -M:

- принудительно переименовывает ветку  
- если ветка с новым именем уже существует — она будет заменена  

Пример:

```bash
git branch -M feature/login feature/login-new
# Ветка 'feature/login-new' будет перезаписана веткой 'feature/login'
```

Используйте -M очень осторожно. По сути вы:

- удаляете старую ветку с именем feature/login-new  
- и заменяете ее веткой feature/login  

Историю старой ветки при этом можно будет вернуть только через reflog или резервные копии, если вы успеете.

## Переименование ветки и работа с удаленным репозиторием

Переименование локальной ветки само по себе не меняет ничего на удаленном сервере. То есть после git branch -m удаленная ветка остается со старым именем.

Теперь давайте разберем полный цикл:

- локальное переименование  
- создание удаленной ветки с новым именем  
- удаление старой ветки на удаленном репозитории  
- обновление отслеживания (upstream)

### Базовый сценарий: ветка с фичей

Предположим:

- локальная ветка: feature/old-name  
- удаленная ветка: origin/feature/old-name  
- вы хотите, чтобы везде было feature/new-name  

Шаг 1. Переименовать локальную ветку:

```bash
git checkout feature/old-name
# Переходим в старую ветку

git branch -m feature/new-name
# Переименовываем текущую ветку
```

Шаг 2. Отправить новую ветку на удаленный репозиторий:

```bash
git push origin feature/new-name
# Создаем новую ветку на удаленном репозитории
```

Шаг 3. Установить upstream (связь локальной ветки с удаленной):

```bash
git push --set-upstream origin feature/new-name
# Теперь git push и git pull без параметров
# будут использовать origin/feature/new-name
```

Если вы уже указали ветку при первом push с флагом -u, можно объединить шаги 2 и 3:

```bash
git push -u origin feature/new-name
# -u это сокращение для --set-upstream
```

Шаг 4. Удалить старую удаленную ветку:

```bash
git push origin --delete feature/old-name
# Удаляем ветку feature/old-name на сервере
```

Итог:

- локально есть только feature/new-name  
- на удаленном сервере тоже только feature/new-name  
- название согласовано везде  

### Проверка настроек upstream

Покажу вам, как проверить, к какой удаленной ветке привязана локальная:

```bash
git branch -vv
# Пример вывода:
# * feature/new-name 1234abc [origin/feature/new-name] Commit message
#   main            abcd123 [origin/main] Another message
```

Здесь в квадратных скобках показана ветка, которая отслеживается (upstream).

Если после переименования там все еще указано старое имя, значит вы не переустановили upstream. Тогда выполняем:

```bash
git branch --set-upstream-to=origin/feature/new-name
# Привязываем локальную ветку к новой удаленной ветке
```

## Переименование основной ветки (master, main, develop)

Когда вы переименовываете обычную ветку с фичей — это одно. Но если речь идет об основной ветке репозитория (например, master → main), сценарий усложняется.

Давайте разберем аккуратный порядок действий.

### Важно учесть перед переименованием

Перед тем как переименовать основную ветку:

- убедитесь, что все участники команды знают о смене имени  
- проверьте, нет ли жестко прописанных имен веток в  
  - CI/CD скриптах  
  - конфигурационных файлах (например, .github/workflows/*)  
  - документации проекта  
- подготовьте инструкцию для коллег, как им обновить локальные репозитории  

### Переименование локальной основной ветки

Предположим:

- у вас есть ветка master  
- вы хотите переименовать ее в main  

Шаг 1. Перейти в master:

```bash
git checkout master
# Переходим в основную ветку
```

Шаг 2. Переименовать:

```bash
git branch -m main
# Переименовали текущую ветку master в main
```

Теперь локально основной веткой стала main.

### Переименование на удаленном репозитории

Дальше нужно, чтобы и удаленный репозиторий "понял", что основная ветка теперь main.

Шаг 3. Отправляем новую ветку:

```bash
git push -u origin main
# Создаем ветку main на сервере и связываем локальную main с origin/main
```

Шаг 4. Устанавливаем main как основную ветку на сервере:

- в GitHub это делается в настройках репозитория (Settings → Branches → Default branch)  
- в GitLab — в Settings → Repository → Default branch  
- в Bitbucket — в Repository settings → Main branch  

Здесь вы вручную говорите системе: "теперь ветка main — основная".

Шаг 5. Удаляем старую ветку master на сервере:

```bash
git push origin --delete master
# Удаляем удаленную ветку master
```

После этого:

- новые pull request по умолчанию будут открываться в main  
- CI/CD, если настроен на дефолтную ветку, будет использовать main  

### Что делать другим разработчикам

Коллегам, у которых уже был локальный клон с master, нужно:

Шаг 1. Обновить список веток:

```bash
git fetch origin
# Забираем измененный список веток с сервера
```

Шаг 2. Переименовать локальную master в main:

```bash
git branch -m master main
# Переименовываем локальную ветку
```

Шаг 3. Привязать локальную main к origin/main:

```bash
git branch --set-upstream-to=origin/main main
# Связываем локальную ветку main с удаленной origin/main
```

Шаг 4. Проверить:

```bash
git status
# Должно быть что-то вроде:
# On branch main
# Your branch is up to date with 'origin/main'.
```

## Возможные ошибки и как их избежать

Давайте разберем несколько типичных ошибок при работе с git branch -m и покажу методы их решения.

### Ошибка: ветка с таким именем уже существует

Сообщение:

```text
fatal: A branch named '<имя>' already exists.
```

Причина:

- вы пытаетесь переименовать ветку в имя, которое уже используется локально  

Решения:

1. Выберите другое имя:

   ```bash
   git branch -m feature/old feature/new-2
   ```

2. Если вы осознанно хотите заменить уже существующую ветку, используйте -M:

   ```bash
   git branch -M feature/old feature/new
   # Осторожно - существующая ветка feature/new будет перезаписана
   ```

### Ошибка: вы не в той ветке

Иногда вы думаете, что находитесь в одной ветке, а на самом деле в другой, и переименовываете не то, что нужно.

Как избежать:

- всегда перед git branch -m делайте проверку:

  ```bash
  git status
  # Проверяем строку 'On branch ...'
  ```

- при переименовании неактивной ветки лучше всегда явно указывать старое имя и новое:

  ```bash
  git branch -m feature/123 feature/123-refactor
  # Так вы не зависите от того, где сейчас находитесь
  ```

### Ошибка: забыли удалить старую ветку на сервере

Ситуация:

- локально вы переименовали ветку  
- отправили новую ветку на сервер  
- но старую ветку на удаленном репозитории не удалили  

В итоге на сервере две похожие ветки, и часть команды работает со старой, часть — с новой.

Как исправить:

1. Найдите старую ветку:

   ```bash
   git branch -a
   # В списке будут и удаленные ветки:
   # remotes/origin/feature/old-name
   # remotes/origin/feature/new-name
   ```

2. Удалите старую удаленную ветку:

   ```bash
   git push origin --delete feature/old-name
   # Удаляем ветку на сервере
   ```

3. Уберите "висячие" ссылки на удаленные ветки локально (опционально):

   ```bash
   git fetch --prune
   # Git удалит ссылки на несуществующие ветки на сервере
   ```

### Ошибка: CI/CD все еще смотрит на старую ветку

Вы переименовали основную ветку, но:

- пайплайны не запускаются  
- автодеплой остановился  

Скорее всего, имя старой ветки было прописано в конфигурации.

Как действовать:

1. Проверьте файлы настроек:

   - .github/workflows/*.yml  
   - .gitlab-ci.yml  
   - конфиги Jenkins, TeamCity, GitHub Actions и т.п.  

2. Найдите упоминания старого имени ветки:

   ```bash
   # Например, можно использовать поиск по проекту в IDE
   # или команду grep в терминале:
   grep -R "master" .
   # Комментарий - эта команда ищет строку master во всех файлах текущей директории
   ```

3. Замените master на main (или другое новое имя), закоммитьте изменения и запустите пайплайн снова.

## Практические сценарии использования git branch -m

Теперь давайте разберем несколько "живых" сценариев, с которыми вы можете столкнуться.

### Сценарий 1. Переименовать ветку с некорректным номером задачи

Представим:

- вы создали ветку feature/123, но задача в трекере на самом деле ISSUE-456  
- хотите, чтобы имя ветки соответствовало трекеру  

Шаги:

```bash
git checkout feature/123
# Переходим в ветку с неправильным именем

git branch -m feature/ISSUE-456
# Переименовываем локальную ветку

git push -u origin feature/ISSUE-456
# Отправляем новую ветку на сервер

git push origin --delete feature/123
# Удаляем старую удаленную ветку
```

### Сценарий 2. Исправить опечатку в имени ветки

Допустим, вы назвали ветку fix/auhtorization вместо fix/authorization.

Давайте разберемся на примере:

```bash
git checkout fix/auhtorization
# Открываем ветку с опечаткой

git branch -m fix/authorization
# Исправляем имя локальной ветки

git push -u origin fix/authorization
# Публикуем исправленную ветку на сервере

git push origin --delete fix/auhtorization
# Удаляем ветку с опечаткой на удаленном репозитории
```

### Сценарий 3. Переименовать ветку, по которой уже открыт pull request

Обычно сервисы вроде GitHub или GitLab привязывают pull request к конкретной ветке.  

Если вы переименовали ветку правильно:

- локально — git branch -m  
- на сервере — git push -u origin <новое_имя>  
- удалили старую ветку — git push origin --delete <старое_имя>  

то большинство современных систем (GitHub, GitLab) корректно "подтянут" новое имя ветки для уже существующего pull request.  

Важно:

- не создавайте новый PR вручную, если старый обновился автоматически  
- проверьте, что в интерфейсе PR указана ветка с новым именем  

Если ваша система не поддерживает автоматическое обновление, тогда:

- закройте старый PR  
- откройте новый из ветки с новым именем  

### Сценарий 4. Переименование ветки, которая еще не пушилась на сервер

Это самый простой случай:

```bash
git checkout feature/early
# Ветка есть только локально и не пушилась

git branch -m feature/improved-name
# Переименовали локальную ветку

git push -u origin feature/improved-name
# Первый push уже с корректным именем ветки
```

В этом сценарии даже не нужно ничего удалять на сервере — там еще не было старой ветки.

### Сценарий 5. Откат переименования

Иногда после переименования вы понимаете, что новое имя оказалось неудачным, и хотите вернуть старое.

Если вы только что переименовали:

```bash
git branch -m feature/old-name feature/new-name
# Переименование уже выполнено
```

Можно просто сделать обратное:

```bash
git branch -m feature/new-name feature/old-name
# Возврат к прежнему имени
```

Если вы успели уже выполнить push с новым именем, тогда:

1. Переименуйте ветку обратно локально.  
2. Еще раз сделайте push с правильным именем.  
3. Удалите лишнюю ветку на сервере, если она уже была создана.

## Небольшая теория: что именно переименовывает git branch -m

Чтобы лучше понимать поведение git branch -m, давайте чуть заглянем "под капот", но без излишней сложности.

- Ветка в Git — это обычный файл в каталоге .git/refs/heads.  
- Внутри этого файла лежит хэш коммита, на который смотрит ветка.  

Когда вы делаете:

```bash
git branch -m old-name new-name
# Переименование ветки
```

Git фактически:

- переименовывает файл .git/refs/heads/old-name в .git/refs/heads/new-name  
- обновляет внутренние ссылки и конфигурацию, где есть ссылки на ветку  

История коммитов при этом не меняется, потому что:

- коммиты — это отдельные объекты  
- ветка — всего лишь указатель на один из этих объектов  

Поэтому git branch -m безопасен с точки зрения потери истории. Основные риски связаны не с Git как таковым, а с:

- несогласованностью с удаленным репозиторием  
- сторонними инструментами (CI/CD, скрипты, документация), где жестко прописано имя ветки  

---

## Заключение

Команда git branch -m — простой и в то же время очень полезный инструмент, который помогает поддерживать порядок в именах веток и исправлять ошибки без создания новых веток и потери истории.

Ключевые моменты, которые важно запомнить:

- git branch -m переименовывает локальную ветку, не трогая историю коммитов  
- git branch -M — то же самое, но с принудительной заменой существующей ветки с таким же именем  
- переименование локальной ветки не затрагивает удаленный репозиторий — для этого нужны push новой ветки и удаление старой  
- при переименовании основной ветки (master → main и т.п.) не забудьте про:  
  - обновление настройки default branch на сервере  
  - корректировку CI/CD и других интеграций  
  - инструкцию для команды по обновлению локальных репозиториев  

Если вы будете относиться к git branch -m как к операции над "указателем на историю", а не над самой историей, понимание того, что происходит, станет значительно проще.

---

## Частозадаваемые технические вопросы по теме статьи и ответы на них

### Как переименовать локальную ветку так, чтобы при этом не потерять связь с уже существующей удаленной веткой

Если вы хотите просто изменить локальное имя, но продолжить работать с той же удаленной веткой, сделайте так:

```bash
git branch -m old-local new-local
# Переименовали локальную ветку

git branch --set-upstream-to=origin/old-remote new-local
# Явно указываем что новая локальная ветка должна отслеживать
# старую удаленную ветку
```

При этом origin/old-remote продолжит существовать, а локальная ветка будет иметь новое имя.

### Как переименовать ветку если она "detached HEAD" и git branch -m не работает

При "detached HEAD" вы не находитесь в ветке, а просто на конкретном коммите.  

Порядок действий:

```bash
git status
# Убедитесь что вы в состоянии detached HEAD

git switch -c temp-branch
# Создаем новую ветку temp-branch на текущем коммите

git branch -m нужное-имя
# Переименовываем temp-branch в целевое имя
```

Так вы фактически создаете новую ветку и даете ей правильное имя, вместо того чтобы переименовывать несуществующую.

### Как массово переименовать несколько веток по единому правилу

Встроенной команды для массового переименования нет, но можно использовать небольшой скрипт оболочки:

```bash
git branch | grep "feature/" | while read old; do
  # Допустим хотим добавить префикс new-
  new="new-${old}"
  git branch -m "${old}" "${new}"
done
```

Комментарии:

- git branch выводит список веток  
- grep "feature/" фильтрует нужные  
- в цикле мы применяем git branch -m к каждой ветке  

Перед запуском такого скрипта всегда делайте резервную копию или пробный запуск с echo вместо git branch -m.

### Как откатить переименование ветки если после него кто-то уже сделал новые коммиты

Если после переименования в ветку добавились коммиты, откат к старому имени — это снова просто переименование:

```bash
git branch -m new-name old-name
# Возвращаем старое имя
```

История с новыми коммитами останется, потому что вы по-прежнему переименовываете только указатель. Никаких дополнительных манипуляций не требуется, если вы не создавали параллельных веток с тем же именем.

### Как переименовать ветку если в Git настроен pre-hook который запрещает определенные имена

Иногда в репозитории настроены хуки (например, pre-receive на сервере), которые запрещают определенные шаблоны имен веток.  

Если вы получаете ошибку при push после переименования:

1. Ознакомьтесь с политикой именования веток (обычно описана в README или документации проекта).  
2. Переименуйте ветку в имя, удовлетворяющее этим правилам:

   ```bash
   git branch -m feature/wrong-name feature/ISSUE-123-description
   ```

3. Повторите push:

   ```bash
   git push -u origin feature/ISSUE-123-description
   ```

Если политика вам неизвестна, посмотрите сообщение об ошибке — часто в нем явно указан допустимый формат имени ветки.