---
metaTitle: Очистка неотслеживаемых файлов в Git с помощью git clean
metaDescription: Подробное руководство по использованию git clean - объяснение удаления неотслеживаемых файлов и директорий с примерами и практическими советами
author: Олег Марков
title: Очистка неотслеживаемых файлов в Git с помощью git clean
preview: Разбираем команду git clean - как безопасно удалять неотслеживаемые файлы и директории, очищать рабочее дерево и избегать потери важных данных
---

## Введение

Команда git clean помогает удалить из рабочего каталога все лишнее, что Git не отслеживает. Речь идет о временных артефактах сборки, сгенерированных файлах, мусоре после экспериментов и забытых файловых деревьях.

Смотрите, я покажу вам, как это работает на практике, и вы увидите, что git clean может быть как очень полезным инструментом, так и источником неприятностей, если использовать его невнимательно. В этой статье вы разберетесь:

- какие файлы Git считает неотслеживаемыми;
- чем git clean отличается от git reset и git checkout;
- как безопасно посмотреть, что будет удалено, до реального удаления;
- какие есть ключи (`-n`, `-f`, `-d`, `-x`, `-X`, `-i`) и чем они отличаются;
- как встроить git clean в процесс разработки и сборки проекта.

Давайте начнем с базовых понятий, а затем перейдем к практическим примерам.

## Что такое неотслеживаемые файлы в Git

Прежде чем использовать git clean, нужно четко понимать, что он удаляет.

### Категории файлов в рабочем каталоге Git

В рабочем каталоге Git файлы можно условно разделить на несколько групп:

1. Отслеживаемые и закоммиченные  
   Это файлы, которые уже находятся в истории репозитория (есть в последнем коммите ветки). Они могут быть:
   - неизмененными (состояние clean);
   - измененными (modified).

2. Отслеживаемые и подготовленные к коммиту  
   Эти файлы находятся в индексе (staging area) после команды:

   ```bash
   git add main.c
   ```

3. Неотслеживаемые файлы (untracked)  
   Это файлы, о которых Git пока ничего не знает. Они:
   - не находятся в индексе;
   - не находятся в истории коммитов;
   - существуют только в рабочем каталоге.

Чтобы увидеть, какие файлы не отслеживаются, используйте:

```bash
git status
```

Git подсветит их в блоке:

```text
Untracked files:
  (use "git add <file>..." to include in what will be committed)
    build/
    temp.log
    scratch.txt
```

Это те файлы, с которыми работает git clean.

### Чем git clean отличается от git reset и git restore

Здесь часто возникает путаница, давайте разберемся.

- git reset / git restore затрагивают **отслеживаемые** файлы. Они помогают:
  - откатить изменения в файлах, которые уже находятся под контролем версий;
  - вернуть их к состоянию последнего коммита или индекса.

- git clean удаляет **неотслеживаемые** файлы и директории:
  - они не были добавлены через git add;
  - их нельзя восстановить командами Git после удаления, так как они не в истории.

Простой пример для понимания:

```bash
echo "tracked" > tracked.txt
git add tracked.txt
git commit -m "Add tracked file"

echo "modified" > tracked.txt         # меняем отслеживаемый файл
echo "untracked" > untracked.txt      # создаем неотслеживаемый файл
```

Теперь:

- git restore tracked.txt вернет файл tracked.txt к состоянию коммита;
- git clean затронет только untracked.txt и подобные файлы.

## Базовое использование git clean

### Самое важное правило: всегда сначала пробный запуск

Команда git clean без ключей не удалит ничего. Но как только вы добавите нужные параметры, файлы будут удалены без возможности восстановления средствами Git.

Поэтому безопасный шаблон такой:

1. Сначала просмотр:

   ```bash
   git clean -n
   ```

2. Потом реальное удаление:

   ```bash
   git clean -f
   ```

Давайте разберем, что делает каждый из этих вариантов.

### Просмотр удаляемых файлов: git clean -n

Флаг `-n` (или `--dry-run`) выводит список файлов, которые были бы удалены, но **ничего не удаляет**. Это ваш основной инструмент проверки.

```bash
git clean -n
```

Пример вывода:

```text
Would remove temp.log
Would remove build/
Would remove scratch.txt
```

Как видите, Git явно сообщает, что он *сделал бы*, если бы вы добавили флаг `-f`. Это помогает избежать случайной очистки нужных файлов.

Рекомендация: привыкайте всегда делать git clean -n перед git clean -f. Это простой и надежный способ сохранить важные файлы.

### Фактическое удаление: git clean -f

Флаг `-f` (или `--force`) подтверждает удаление неотслеживаемых файлов. Без него команда работать не будет, Git специально требует явного согласия.

```bash
git clean -f
```

После выполнения:

- все неотслеживаемые файлы в текущем каталоге и вложенных директориях будут удалены;
- неотслеживаемые директории по умолчанию **не** удаляются (об этом поговорим ниже).

Для наглядности давайте посмотрим простой пример.

```bash
# Создаем несколько файлов
echo "temp data" > temp.log
echo "draft" > draft.txt

# Проверяем статус
git status

# Смотрим, что будет удалено
git clean -n
# Вывод:
# Would remove temp.log
# Would remove draft.txt

# Удаляем
git clean -f
```

Комментарий к примеру:

- temp.log и draft.txt были неотслеживаемыми;
- после git clean -f они исчезнут из файловой системы;
- вернуть их через Git больше нельзя, потому что они не были в истории.

Поэтому перед запуском команды полезно визуально просмотреть список файлов и, если нужно, часть из них сначала добавить в .gitignore или закоммитить.

## Очистка директорий: флаг -d

По умолчанию git clean удаляет только **файлы**, а не директории. Если у вас есть неотслеживаемая директория, она останется.

Например:

```bash
mkdir build
echo "binary" > build/app.bin
echo "cache" > build/cache.tmp

git clean -n
# Ничего не покажет, если в корне нет неотслеживаемых файлов
```

Git не будет заглядывать внутрь неотслеживаемых директорий без специального флага.

Чтобы удалить **неотслеживаемые директории вместе с содержимым**, используйте:

```bash
git clean -nd
```

Это предварительный просмотр. Вы увидите что-то вроде:

```text
Would remove build/
```

А для реального удаления:

```bash
git clean -fd
```

Разберем комбинацию:

- `-f` — реально удалить;
- `-d` — включить в очистку неотслеживаемые директории.

Теперь команда удалит:

- неотслеживаемые файлы в корне;
- неотслеживаемые директории и все их содержимое.

Обратите внимание: если директория отслеживается (есть в истории) и внутри нее есть **неотслеживаемые файлы**, git clean удалит только эти файлы, а саму директорию не тронет. Давайте посмотрим пример.

```bash
mkdir logs
git add logs
git commit -m "Add logs directory"

echo "temp" > logs/temp.log   # неотслеживаемый файл внутри отслеживаемой директории

git clean -n
# Would remove logs/temp.log   # будет удален только этот файл
```

Директория logs останется, потому что она уже отслеживается.

## Работа с игнорируемыми файлами: флаги -x и -X

В реальных проектах вы чаще всего используете .gitignore, чтобы не засорять статус временными файлами: логами, сборочными артефактами, кэшем.

### Как git clean относится к .gitignore по умолчанию

По умолчанию git clean:

- удаляет **неигнорируемые** неотслеживаемые файлы;
- **не трогает** файлы, которые игнорируются через:
  - .gitignore;
  - .git/info/exclude;
  - глобальные правила ignore.

То есть, если файл совпадает с шаблоном из .gitignore, git clean без специальных флагов его не удалит.

### Удалить только игнорируемые файлы: git clean -X

Иногда нужно очищать только те файлы, которые заведомо считаются временными или генераторными. Например: build артефакты, логи, кэш.

Для этого удобно использовать:

```bash
git clean -nX    # просмотр
git clean -fX    # удаление
```

Флаг `-X` говорит Git:

- удалить **игнорируемые** неотслеживаемые файлы;
- оставить **неигнорируемые** неотслеживаемые файлы.

Смотрите, я покажу вам, как это выглядит на примере.

```bash
# В .gitignore записано:
# build/
# *.log

mkdir build
echo "binary" > build/app.bin
echo "runtime log" > runtime.log
echo "notes" > notes.tmp       # файл не игнорируется

git status
# Untracked files:
#   build/
#   runtime.log
#   notes.tmp

# Сначала предварительный просмотр
git clean -nX
# Would remove build/
# Would remove runtime.log

# Реальное удаление
git clean -fX
```

Файл notes.tmp останется, потому что он не был в .gitignore.

Этот сценарий часто используют в командах:

```bash
git clean -fdX
```

Здесь:

- `-f` — удалить;
- `-d` — включить директории;
- `-X` — удалять только игнорируемые.

Такая команда хорошо подходит для очистки перед сборкой проекта.

### Удалить вообще все неотслеживаемое: git clean -x

Флаг `-x` более агрессивный:

- удаляет **все** неотслеживаемые файлы и директории;
- игнорирует правила .gitignore.

Использование:

```bash
git clean -nx    # просмотр
git clean -fx    # удаление
git clean -fdx   # с удалением директорий
```

Давайте разберемся на примере, чем это отличается от `-X`.

```bash
# .gitignore:
# build/
# *.log

mkdir build
echo "binary" > build/app.bin
echo "runtime log" > runtime.log
echo "notes" > notes.tmp

git clean -nX
# Would remove build/
# Would remove runtime.log

git clean -nx
# Would remove build/
# Would remove runtime.log
# Would remove notes.tmp
```

Флаг `-x` подходит для ситуаций, когда вам нужно привести рабочий каталог к максимально "чистому" виду, оставив только то, что отслеживается Git.

Здесь важно быть особенно внимательным: можно случайно удалить неотслеживаемые, но важные файлы конфигурации или рабочие заметки, которые вы еще не добавили в репозиторий.

## Интерктивный режим: git clean -i

Если вы хотите выбирать, какие файлы удалять, а какие сохранить, используйте интерактивный режим:

```bash
git clean -i
```

Смотрите, что происходит: Git запускает простой текстовый интерфейс, в котором предлагает действия.

Пример запуска:

```bash
git clean -i
```

Вы можете увидеть примерно такое меню:

```text
Would remove the following items:
  temp.log
  build/
*** Commands ***
  1: clean                # удалить выбранные элементы
  2: filter by pattern    # отфильтровать по шаблону
  3: select by numbers    # выбрать по номерам
  4: ask each             # спросить по каждому файлу
  5: quit                 # выйти
  6: help                 # помощь
What now>
```

Чаще всего удобны варианты:

- `3` — выбрать файлы по номерам;
- `4` — по каждому файлу ответить yes/no.

Допустим, вы выбираете `4` (ask each). Тогда Git начнет спрашивать:

```text
Remove temp.log? (y/n)
Remove build/? (y/n)
```

Вы можете точечно согласиться на удаление только тех элементов, которые точно не нужны.

Дополнительные особенности:

- вы можете комбинировать флаги, например:

  ```bash
  git clean -di       # директории + интерактивный режим
  git clean -dix      # тоже, но с учетом игнорируемых файлов
  ```

- интерактивный режим полезен, когда git clean -n показывает слишком много элементов, и вы хотите точно контролировать выбор.

## Выборочная очистка по маскам и путям

Иногда нужно удалить только часть неотслеживаемых файлов, например, только временные файлы с определенным расширением или только в отдельной директории.

### Очистка по пути

Вы можете указать путь(и) в конце команды git clean. Тогда очистка коснется только этого подкаталога.

```bash
git clean -n src/
git clean -f src/
```

В этом случае будут удалены только неотслеживаемые файлы внутри каталога src и его подкаталогов.

Аналогично:

```bash
git clean -fd build/
```

Удалит только неотслеживаемые файлы и директории внутри папки build (или саму build, если она неотслеживаемая и не добавлена в git).

### Очистка по маскам с опцией -e (exclude)

Вы можете исключить некоторые файлы из очистки с помощью опции `-e` (или `--exclude`). Это особенно удобно, если вам не хочется трогать определенные файлы или каталоги.

Пример:

```bash
git clean -n -e "!important.txt"
git clean -f -e "!important.txt"
```

Здесь я показываю пример исключения файла important.txt из очистки, даже если он неотслеживаемый.

Вы можете указать шаблон:

```bash
git clean -n -e "*.keep"
git clean -f -e "*.keep"
```

Вот что произойдет:

- все неотслеживаемые файлы будут претендентами на удаление;
- но файлы с расширением .keep будут проигнорированы и останутся.

Можно объединять флаги:

```bash
git clean -fdx -e "*.config"
```

Эта команда:

- удалит все неотслеживаемые файлы и директории;
- проигнорирует файлы *.config, даже если они неотслеживаемые.

Обратите внимание на разницу между .gitignore и `-e`:

- .gitignore определяет, какие файлы игнорировать для статуса и индексации;
- `-e` здесь задает исключения именно для текущей операции git clean.

## Практические сценарии использования git clean

Теперь давайте посмотрим, как git clean применяют в реальной работе.

### Сценарий 1. Очистка перед сборкой проекта

Частая задача: перед запуском сборки проекта нужно гарантированно удалить старые артефакты, кэш и временные файлы.

Если у вас .gitignore уже настроен так, что все сборочные артефакты туда попадают, можно использовать:

```bash
git clean -fdX
```

Инструкция по шагам:

1. Убедитесь, что в .gitignore перечислены:
   - каталоги сборки (например, build/, dist/);
   - временные файлы (например, *.log, *.tmp);
2. Выполните:

   ```bash
   git clean -nfdX   # проверка
   git clean -fdX    # реальное удаление
   ```

3. После этого запустите сборку (make, npm run build, gradle и так далее).

Так вы минимизируете влияние старых артефактов на новую сборку.

### Сценарий 2. Полная "перезагрузка" рабочего каталога

Иногда рабочий каталог захламляется неотслеживаемыми файлами: временными скриптами, экспериментальными заметками, полуготовыми конфигурациями.

Если вы хотите вернуться к "чистому" состоянию, когда в каталоге только то, что отслеживается Git, используйте:

```bash
git clean -nfdx   # сначала всегда предварительный просмотр
git clean -fdx    # затем реальное удаление
```

Эта команда:

- удалит все неотслеживаемые файлы;
- удалит все неотслеживаемые директории;
- не будет учитывать .gitignore.

После этого в каталоге останутся только файлы, которые:
- были в последнем коммите;
- плюс те, что изменены, но отслеживаются (modified).

Если вы дополнительно хотите откатить все отслеживаемые изменения (modified), можно совместить с:

```bash
git reset --hard
git clean -fdx
```

После такой комбинации рабочее дерево полностью совпадет с последним коммитом.

### Сценарий 3. Очистка только определенной части проекта

Допустим, вы хотите очистить только директорию tests/tmp, где скапливаются временные файлы от тестов.

Тогда вам не обязательно запускать git clean по всему репозиторию. Можно указать путь:

```bash
git clean -nfd tests/tmp
git clean -fd tests/tmp
```

Если при этом внутри есть файлы, которые игнорируются, но вы хотите их тоже удалить, используйте:

```bash
git clean -nfdx tests/tmp
git clean -fdx tests/tmp
```

Такой подход безопаснее, чем полная очистка всего проекта, если вы не уверены, нет ли в корне каких-нибудь полезных неотслеживаемых файлов.

### Сценарий 4. Локальный cleanup в рамках CI/CD

В сборочных конвейерах (CI) иногда используют git clean, чтобы гарантировать повторяемость сборок.

Пример шагов в CI:

```bash
git fetch --all
git reset --hard origin/main
git clean -fdx
# далее запуск сборки
```

Комментарий:

- git reset --hard приводит отслеживаемые файлы к состоянию ветки origin/main;
- git clean -fdx удаляет все неотслеживаемое;
- после этого сборка выполняется в максимально предсказуемых условиях.

Вы можете адаптировать этот шаблон под свой процесс, но принцип остается тем же.

## Типичные ошибки и как их избежать

### Ошибка 1. Использование git clean без предварительного просмотра

Команда:

```bash
git clean -fdx
```

может безвозвратно удалить много данных. Часто разработчики случайно теряют:

- локальные конфигурационные файлы (config.local, settings.json);
- временные заметки;
- файлы, которые еще не успели закоммитить.

Чтобы этого избежать, выработайте привычку:

```bash
git clean -nfdx
# внимательно просмотреть
git clean -fdx
```

Если вы увидели в списке что-то важное, у вас есть варианты:

- добавить файл в отслеживаемые:

  ```bash
  git add important.txt
  git commit -m "Save important file"
  ```

- добавить его в исключения при вызове git clean:

  ```bash
  git clean -fdx -e "important.txt"
  ```

### Ошибка 2. Ожидание, что git clean вернет отслеживаемые файлы к старой версии

Иногда пользователи путают git clean с откатом изменений. Еще раз подчеркнем:

- git clean работает только с неотслеживаемыми файлами;
- для отката отслеживаемых изменений нужно использовать:
  - git restore;
  - или git reset --hard;
  - или git checkout (в старых сценариях).

Пример:

```bash
echo "tracked" > tracked.txt
git add tracked.txt
git commit -m "Add tracked file"

echo "changed" > tracked.txt   # изменили отслеживаемый файл

git clean -n
# Ничего не изменится, tracked.txt не считается неотслеживаемым
```

Чтобы вернуть tracked.txt к состоянию коммита, используйте:

```bash
git restore tracked.txt
# или
git checkout -- tracked.txt     # старый синтаксис
```

### Ошибка 3. Удаление важных игнорируемых файлов через -x

Файл может быть в .gitignore, но при этом быть важным для вашей локальной конфигурации, например:

- .env;
- local.settings.json;
- system.config.

Если вы выполните:

```bash
git clean -fdx
```

такие файлы будут удалены. Чтобы избежать этого:

1. Либо не вносите их в .gitignore, а используйте другие механизмы;
2. Либо используйте `-X` вместо `-x`, если хотите сохранять неигнорируемые файлы;
3. Либо добавляйте исключения через `-e`:

   ```bash
   git clean -fdx -e ".env"
   ```

### Ошибка 4. Ожидание, что удаленные неотслеживаемые файлы можно восстановить через Git

После того как git clean удалил файл, который никогда не был закоммичен, Git не хранит его копию. Восстановить такой файл стандартными командами нельзя.

Если вы случайно удалили неотслеживаемый файл, варианты ограничены:

- поиск в файловой системе специализированными утилитами восстановления (если это вообще возможно);
- восстановление из резервных копий (если они есть).

Поэтому разумно:

- не хранить в репозитории критически важные данные, которые никуда больше не копируются;
- не запускать агрессивные команды очистки без предварительной проверки.

## Резюме возможностей git clean

Давайте коротко соберем вместе комбинации флагов, которые вы чаще всего будете использовать:

- Просмотр:
  - git clean -n — показать, что будет удалено (файлы);
  - git clean -nd — показать, включая директории;
  - git clean -nx / -nX — показать с учетом игнорируемых/всех файлов.

- Удаление:
  - git clean -f — удалить неотслеживаемые файлы;
  - git clean -fd — удалить неотслеживаемые файлы и директории;
  - git clean -fX — удалить только игнорируемые файлы;
  - git clean -fdX — удалить только игнорируемые файлы и директории;
  - git clean -fx — удалить все неотслеживаемые файлы, игнорируя .gitignore;
  - git clean -fdx — максимально агрессивная очистка всего неотслеживаемого.

- Интерактивный режим:
  - git clean -i — выборочно удалить неотслеживаемые файлы;
  - git clean -di — то же, но с директориями.

- Работа по путям и исключениям:
  - git clean -fd some/path — очистка только в указанном каталоге;
  - git clean -fdx -e "*.config" — удалить все неотслеживаемое, но сохранить файлы *.config.

Команда git clean — мощный инструмент, который позволяет держать рабочее дерево в порядке, но требует аккуратности. Если вы будете использовать предварительный просмотр и понимать, какие категории файлов она затрагивает, риск потери важных данных заметно снижается.

---

## Частозадаваемые технические вопросы по теме и ответы

### Вопрос 1. Как сделать так, чтобы git clean не трогал определенный файл, даже при использовании -fdx?

Используйте ключ `-e` (exclude) при вызове git clean. Например, если вы хотите, чтобы файл `.env` никогда не удалялся при очистке, выполните:

```bash
git clean -fdx -e ".env"
```

Если таких файлов несколько, можно указать несколько `-e`:

```bash
git clean -fdx -e ".env" -e "local.settings.json"
```

Так вы сохраните важные конфигурационные файлы, даже если используете агрессивную очистку.

### Вопрос 2. Можно ли отменить результат git clean, если он уже удалил неотслеживаемые файлы?

Стандартными средствами Git — нет, если файлы никогда не были закоммичены. Git не хранит их содержимое. Возможные шаги:

1. Проверить, были ли эти файлы когда-либо в истории:

   ```bash
   git log -- path/to/file
   ```

2. Если да, можно восстановить их из старого коммита:

   ```bash
   git checkout <commit_hash> -- path/to/file
   ```

3. Если нет — остается только поиск по файловой системе утилитами восстановления или использование резервных копий, если они настраивались заранее.

### Вопрос 3. Как настроить git clean как удобную alias-команду для типичных сценариев?

Можно добавить alias в глобальный конфиг Git:

```bash
git config --global alias.cleandry "clean -nfdX"
git config --global alias.cleanbuild "clean -fdX"
```

Теперь вы можете вызывать:

```bash
git cleandry     # предварительный просмотр перед очисткой сборочных артефактов
git cleanbuild   # реальное удаление игнорируемых файлов и директорий
```

Это ускоряет работу и уменьшает риск ошибки в наборе флагов.

### Вопрос 4. Почему git clean не удаляет файлы внутри отслеживаемой директории, хотя они неотслеживаемые?

Вероятно, вы запускали git clean без флага `-d`. По умолчанию он ограничивается файлами в корне и не заходит в неотслеживаемые директории, но внутри отслеживаемых директорий неотслеживаемые файлы должен удалять. Если этого не происходит:

1. Убедитесь, что файлы действительно не отслеживаются:

   ```bash
   git status
   ```

2. Попробуйте:

   ```bash
   git clean -nd    # предварительный просмотр с учетом директорий
   git clean -fd    # удаление
   ```

3. Если файлы игнорируются через .gitignore, добавьте флаг `-x` или используйте `-X` при необходимости.

### Вопрос 5. Как совместить git clean с локальными настройками, которые нельзя коммитить, но и терять их нельзя?

Один из рабочих подходов:

1. Не добавлять такие файлы в .gitignore, чтобы по ним было видно статус.
2. Пометить их как "assume unchanged", чтобы Git не показывал изменения:

   ```bash
   git update-index --assume-unchanged path/to/local.config
   ```

3. Никогда не использовать для этого проекта агрессивные команды вида `git clean -fdx`.
4. Если агрессивная очистка все же нужна, добавлять явные исключения:

   ```bash
   git clean -fdx -e "path/to/local.config"
   ```

Так вы сможете использовать git clean, не рискуя потерять важные локальные настройки.