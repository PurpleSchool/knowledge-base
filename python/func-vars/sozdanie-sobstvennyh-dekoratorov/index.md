---
metaTitle: Создание собственных декораторов в Python
metaDescription: Узнайте, как создавать собственные декораторы в Python — синтаксис, примеры, передача аргументов и применение для расширения функциональности функций и методов.
author: Олег Марков
title: Создание собственных декораторов в Python
preview: Разберём создание собственных декораторов в Python, их синтаксис, работу с аргументами функций и практические примеры применения.
---

## Введение

Собственные декораторы позволяют добавлять уникальное поведение функциям и методам без изменения их исходного кода. Они помогают создавать переиспользуемые компоненты, контролировать выполнение функций и внедрять дополнительные действия, такие как логирование или кэширование.

В этой статье мы разберём, как создавать собственные декораторы, использовать аргументы, правильно работать с замыканиями и избегать распространённых ошибок.

Если вы хотите детальнее изучить создание и использование декораторов, включая работу с аргументами и замыканиями — приходите на наш курс [Основы Python](https://purpleschool.ru/course/python-basics?utm_source=knowledgebase&utm_medium=article&utm_campaign=Sozdanie_sobstvennyh_dekoratorov_v_Python). На курсе 209 уроков и 34 упражнения, AI-тренажеры для практики с кодом и задачами 24/7, решение задач с живым ревью наставника, еженедельные встречи с менторами.

## Простейший собственный декоратор

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Перед вызовом функции")
        result = func(*args, **kwargs)
        print("После вызова функции")
        return result
    return wrapper

@my_decorator
def say_hello(name):
    print(f"Hello, {name}!")

say_hello("Alice")
```

Результат:

```
Перед вызовом функции
Hello, Alice!
После вызова функции
```

## Декоратор с аргументами

Для передачи аргументов в декоратор требуется вложенный уровень функций:

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")

greet("Bob")
```

Вывод:

```
Hello, Bob!
Hello, Bob!
Hello, Bob!
```

## Декоратор с возвращаемым значением

Важно возвращать результат функции:

```python
def add_logging(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        print(f"{func.__name__} вернула {result}")
        return result
    return wrapper

@add_logging
def multiply(a, b):
    return a * b

multiply(2, 5)
# multiply вернула 10
```

## Частые ошибки

* Не возвращать результат функции внутри wrapper.
* Не использовать `*args` и `**kwargs` — теряются параметры функции.
* Изменять внешние переменные без `nonlocal`, если требуется.
* Слишком глубокая вложенность — усложняет чтение и поддержку кода.

## Часто задаваемые вопросы

1. **Можно ли декоратор использовать для методов класса?**
   Да, и важно учитывать `self` или `cls` для методов экземпляра и класса.

2. **Можно ли декорировать декоратор?**
   Да, декораторы можно комбинировать, применяя их один за другим через `@`.

3. **Как отлаживать собственный декоратор?**
   Используйте print, callable() и type() для проверки объекта функции и аргументов.

## Заключение

Собственные декораторы — мощный инструмент для расширения функциональности функций и методов, упрощения кода и внедрения повторяющихся операций. Они применяются в логировании, кэшировании, проверке данных и тестировании.

Для системного изучения декораторов, включая создание собственных и работу с аргументами, рекомендую пройти курс [Основы Python](https://purpleschool.ru/course/python-basics?utm_source=knowledgebase&utm_medium=article&utm_campaign=Sozdanie_sobstvennyh_dekoratorov_v_Python). В первых 3 модулях уже доступно бесплатное содержание — начните погружаться в мир Python прямо сегодня.
