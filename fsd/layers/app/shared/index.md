---
metaTitle: Слой shared shared-layer в архитектуре фронтенд приложений
metaDescription: Разбор слоя shared shared-layer в модульной архитектуре фронтенд приложений - структура назначение принципы выделения и примеры реализации
author: Олег Марков
title: Слой shared shared-layer - как организовать переиспользуемые модули
preview: Подробный разбор слоя shared shared-layer - где хранить общие компоненты утилиты и типы как организовать структуру импорта и не превратить shared в свалку
---

## Введение

Слой shared (shared-layer) — это слой с переиспользуемыми частями приложения, которые не зависят от конкретных бизнес-сценариев. Проще говоря, это место, где живут общие кирпичики, которые вы можете использовать в разных модулях, не привязываясь к конкретной фиче или домену.

В архитектурах вроде Feature-Sliced Design, Clean Architecture, модульных монолитах и микрофронтендах shared-layer помогает:

- уменьшить дублирование кода
- сделать общие решения единообразными
- упростить рефакторинг и поддержку
- контролировать зависимости между слоями

Но на практике у многих shared превращается в свалку без структуры. Давайте разберем, как устроить слой shared так, чтобы он был полезным, предсказуемым и управляемым.

В статье я покажу:

- какую роль играет shared-layer в архитектуре
- что именно стоит выносить в shared, а что — нет
- как организовать структуру и правила импортов
- примеры реализации на фронтенде (React/TypeScript, но принципы универсальны)
- типичные ошибки при работе с shared и способы их избежать

## Назначение и роль слоя shared

### Где находится shared в общей архитектуре

Обычно в модульной архитектуре frontend-проекта вы можете встретить такую структуру слоев:

- app — инициализация приложения, роутер, глобальные провайдеры
- processes — сквозные бизнес-процессы
- pages — страницы
- features — функциональные возможности, ориентированные на пользователя
- entities — бизнес-сущности и их логика
- shared — переиспользуемые, независимые от домена модули

Слой shared обычно:

- не знает о домене (entities)
- не зависит от конкретных фич (features)
- не зависит от страниц (pages)
- может использоваться в любом слое выше него

Смотрите, можно визуализировать зависимости так:

- app  
  - pages  
    - features  
      - entities  
        - shared  

Стрелки зависят «вниз», но не «вверх»: shared — самый нижний, базовый слой.

### Что можно считать shared

Чтобы проще ориентироваться, давайте разделим содержимое shared на типичные группы:

- UI-компоненты общего назначения  
  - кнопки, инпуты, модальные окна, тултипы, таблицы, layout-компоненты  
- утилиты и хелперы  
  - функции форматирования, валидации, работы с датами, числами, строками  
- инфраструктурные модули  
  - http-клиент, логирование, обработка ошибок, локальное хранилище  
- общие типы и контракты  
  - базовые типы ошибок, результаты запросов, общие интерфейсы  
- конфигурация  
  - флаги фич, окружения, глобальные константы, но без бизнес-смысла  

Важно: shared — не место для доменной логики. Если в модуле есть знания о «заказе», «пользователе», «товаре» — это уже признак домена (entities) или фичи, а не shared.

### Когда стоит выделять модуль в shared

Обычно модуль логично перенести в shared, если:

- он используется в двух и более независимых модулях (features, entities, pages)
- его поведение не зависит от конкретной бизнес-сущности
- его можно описать как «общий механизм», а не «часть сценария пользователя»
- он не «знает» о структуре доменных данных

Простой фильтр: можно ли использовать этот модуль в другом проекте без изменений? Если ответ «да» или «почти да», то кандидатом на shared он быть может.

## Структура слоя shared

### Базовая структура директорий

Один из популярных подходов — разделить общие модули по подслоям внутри shared. Например:

```ts
// Пример общей структуры фронтенд проекта
src/
  app/
  pages/
  features/
  entities/
  shared/
    ui/           // Базовые UI-компоненты
    lib/          // Утилиты и хелперы
    api/          // Общая обертка над запросами
    config/       // Конфигурация и фиче-флаги
    model/        // Общие типы и модели (не доменные)
    assets/       // Иконки, картинки, шрифты
```

Комментарии к структуре:

- ui — здесь находятся визуальные компоненты без привязки к домену  
- lib — функции и классы, которые не зависят от UI  
- api — единая настройка http-клиента, перехватчики, baseURL  
- config — конфиги окружений, feature flags, глобальные константы  
- model — общие интерфейсы данных, которые не завязаны на конкретной сущности  
- assets — статические ресурсы

Теперь покажу более детально, как можно раскладывать содержимое внутри.

### Подслой ui в shared

В shared/ui обычно размещают:

- элементы управления: Button, Input, Checkbox, Select
- простые композиции: Modal, Drawer, Tabs
- layout-компоненты: Stack, Grid, Container

Структуру удобно делать по принципу «один компонент — один модуль»:

```ts
src/shared/ui/
  button/
    index.ts
    button.tsx
    button.module.css
  input/
    index.ts
    input.tsx
  modal/
    index.ts
    modal.tsx
```

Теперь вы увидите, как это выглядит в коде.

```tsx
// src/shared/ui/button/button.tsx
import React from "react";

export type ButtonVariant = "primary" | "secondary";

interface ButtonProps {
  // Текст на кнопке
  children: React.ReactNode;
  // Вариант оформления кнопки
  variant?: ButtonVariant;
  // Обработчик клика по кнопке
  onClick?: () => void;
  // Дополнительные CSS-классы
  className?: string;
  // Флаг активности процесса (например, загрузки)
  isLoading?: boolean;
}

export const Button: React.FC<ButtonProps> = ({
  children,
  variant = "primary",
  onClick,
  className,
  isLoading = false,
}) => {
  // Здесь собираем итоговый класс с учетом варианта и возможных модификаторов
  const classNames = ["btn", `btn-${variant}`, className]
    .filter(Boolean)
    .join(" ");

  return (
    <button
      className={classNames}
      onClick={onClick}
      // Если идет загрузка, блокируем нажатие
      disabled={isLoading}
    >
      {/* При загрузке показываем индикатор */}
      {isLoading ? "Loading..." : children}
    </button>
  );
};
```

```ts
// src/shared/ui/button/index.ts
export { Button } from "./button";
export type { ButtonVariant } from "./button";
```

Такой компонент:

- не знает о бизнес-сущности
- не зависит от конкретной фичи
- легко переиспользуется в любом месте

### Подслой lib в shared

Давайте разберемся на примере утилит. В shared/lib удобно держать:

- хелперы для работы с датой `formatDate`
- функции для работы с числами `round`, `toCurrency`
- функции для работы со строками `capitalize`, `truncate`
- вспомогательные функции для работы с промисами, ретраями и т. д.

Структура может быть плоской или разделенной по областям:

```ts
src/shared/lib/
  date/
    formatDate.ts
    isSameDay.ts
    index.ts
  number/
    toCurrency.ts
    round.ts
    index.ts
  string/
    capitalize.ts
    truncate.ts
    index.ts
  api/
    createApiClient.ts
    withRetry.ts
    index.ts
  index.ts
```

Теперь давайте посмотрим, что происходит в следующем примере:

```ts
// src/shared/lib/date/formatDate.ts

// Здесь мы импортируем библиотеку для работы с датами (пример)
import { format } from "date-fns";

// Тип для формата даты
export type DateFormat = "short" | "long";

export function formatDate(
  // Дата, которую надо отформатировать
  value: Date | string,
  // Тип формата, который хотим получить
  formatType: DateFormat = "short"
): string {
  // Если передана строка, пытаемся создать из нее объект Date
  const date = typeof value === "string" ? new Date(value) : value;

  // Заранее определяем шаблоны форматов
  const patterns: Record<DateFormat, string> = {
    short: "dd.MM.yyyy",
    long: "dd MMMM yyyy",
  };

  // Используем библиотеку format с выбранным шаблоном
  return format(date, patterns[formatType]);
}
```

```ts
// src/shared/lib/date/index.ts
export { formatDate } from "./formatDate";
export type { DateFormat } from "./formatDate";
```

```ts
// src/shared/lib/index.ts
export * as date from "./date";
export * as number from "./number";
export * as string from "./string";
```

Такой подход помогает:

- централизовать логику форматирования
- использовать единый стиль отображения в разных фичах
- легко менять реализацию (например, библиотеку форматирования)

### Подслой api в shared

Частый сценарий: в проекте нужен единый http-клиент — с общими заголовками, обработкой ошибок, базовым URL. Слой shared — хорошее место для такой инфраструктуры.

Покажу вам, как это реализовано на практике.

```ts
// src/shared/api/baseClient.ts
import axios from "axios";

// Базовая конфигурация http-клиента
export const apiClient = axios.create({
  // Базовый адрес API
  baseURL: "/api",
  // Максимальное время ожидания ответа
  timeout: 10000,
});

// Здесь мы добавляем перехватчик запросов
apiClient.interceptors.request.use((config) => {
  // Например, берем токен из localStorage
  const token = localStorage.getItem("token");

  if (token) {
    // Добавляем токен в заголовки, если он есть
    config.headers.Authorization = `Bearer ${token}`;
  }

  return config;
});

// Здесь мы добавляем перехватчик ответов
apiClient.interceptors.response.use(
  (response) => {
    // В успешном случае просто возвращаем ответ
    return response;
  },
  (error) => {
    // Здесь можно централизованно обработать ошибки
    // Например, залогировать и пробросить дальше
    console.error("API error", error);
    return Promise.reject(error);
  }
);
```

```ts
// src/shared/api/index.ts
export { apiClient } from "./baseClient";
```

Важно, чтобы этот клиент:

- не знал о конкретных эндпоинтах домена
- не содержал бизнес-правил
- был нейтральным по отношению к сущностям

Сами эндпоинты конкретных сущностей лучше описывать в entities или features, а не в shared.

### Подслой config в shared

Конфигурация — типичный кандидат для shared-layer, если:

- она нужна в разных слоях
- она не привязана к конкретной бизнес-сущности

Пример:

```ts
// src/shared/config/env.ts

// Тип для доступных окружений
type Env = "development" | "staging" | "production";

// Получаем текущее окружение из process.env
const env = (process.env.REACT_APP_ENV || "development") as Env;

// Базовые настройки по окружениям
const configs: Record<Env, { apiUrl: string; enableDebug: boolean }> = {
  development: {
    apiUrl: "https://dev.api.example.com",
    enableDebug: true,
  },
  staging: {
    apiUrl: "https://staging.api.example.com",
    enableDebug: true,
  },
  production: {
    apiUrl: "https://api.example.com",
    enableDebug: false,
  },
};

// Экспортируем текущую конфигурацию
export const appConfig = configs[env];
```

```ts
// src/shared/config/featureFlags.ts

// Набор фиче-флагов
export const featureFlags = {
  // Флаг включения нового профиля пользователя
  newProfilePage: false,
  // Флаг включения экспериментального поиска
  experimentalSearch: true,
};
```

```ts
// src/shared/config/index.ts
export { appConfig } from "./env";
export { featureFlags } from "./featureFlags";
```

Теперь любой слой может использовать эти данные, не дублируя логику.

### Подслой model в shared

Иногда полезно вынести общие типы, которые не относятся к конкретной сущности, но часто встречаются. Например:

```ts
// src/shared/model/common.ts

// Универсальный тип результата операции
export interface Result<T> {
  // Флаг, успешно ли завершилась операция
  ok: boolean;
  // Полезная нагрузка при успешном результате
  data?: T;
  // Описание ошибки, если ok === false
  error?: string;
}

// Тип для сущностей с идентификатором
export interface WithId {
  // Уникальный идентификатор
  id: string;
}
```

```ts
// src/shared/model/index.ts
export type { Result, WithId } from "./common";
```

Такие общие модели можно использовать в разных слоях, но важно не превращать model в свалку всех доменных типов — домен должен быть в entities.

## Правила зависимостей и импортов

### Слои, которые могут зависеть от shared

В большинстве случаев логика такая:

- любой слой может импортировать модули из shared
- shared не может зависеть ни от кого (кроме внешних пакетов)

То есть:

- app → shared (допускается)
- pages → shared (допускается)
- features → shared (допускается)
- entities → shared (допускается)
- shared → features (запрещено)
- shared → entities (запрещено)
- shared → pages (запрещено)

Так мы избегаем циклических зависимостей и запутанных связей.

### Индексные файлы и публичные API

Для управления импортами удобно использовать подход с публичными API. Идея простая:

- каждый модуль (например, shared/ui/button) имеет свой index.ts
- из слоев выше мы импортируем только из этих index.ts
- внутренние файлы компонента не импортируем напрямую

Давайте разберем пример:

```tsx
// src/shared/ui/button/index.ts
export { Button } from "./button";
export type { ButtonVariant } from "./button";
```

Тогда в фиче мы пишем:

```tsx
// src/features/auth/loginForm/ui/LoginForm.tsx

// Импортируем только из публичного API модуля shared/ui
import { Button } from "@/shared/ui/button";

export const LoginForm = () => {
  // ...
  return <Button>Войти</Button>;
};
```

Такой подход дает:

- четкие границы модулей
- возможность рефакторить внутренности без массовых правок импортов
- понятную навигацию и автодополнение в IDE

### Контроль за разрастанием shared

Одна из главных проблем — shared, который со временем превращается в «misc» или «common». Чтобы избежать этого, можно ввести несколько правил:

- нельзя добавлять в shared модули с бизнес-терминами в названии  
  - плохо: UserCard, OrderApi, ProductFormatter  
  - лучше: Avatar, Card, List, formatCurrency  

- каждый модуль в shared должен иметь понятное, общее назначение  
  - если логика понятна только в контексте одной фичи — ей не место в shared  

- перенос в shared делается только после повторного использования  
  - сначала реализуем модуль в фиче или entity  
  - если стало ясно, что он нужен в двух и более местах — выносим в shared  

## Примеры использования shared-layer в фичах и сущностях

### Пример использования shared/ui и shared/lib в feature

Давайте посмотрим небольшой пример фичи авторизации, которая использует общий UI и утилиты shared.

```tsx
// src/features/auth/loginForm/ui/LoginForm.tsx
import React, { useState } from "react";

// Импортируем общие UI-компоненты из shared
import { Button } from "@/shared/ui/button";
import { Input } from "@/shared/ui/input";

// Импортируем утилиту для работы с API
import { apiClient } from "@/shared/api";
import { formatDate } from "@/shared/lib/date";

export const LoginForm: React.FC = () => {
  // Локальное состояние для логина и пароля
  const [login, setLogin] = useState("");
  const [password, setPassword] = useState("");
  // Флаги загрузки и ошибки
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Обработчик отправки формы
  const handleSubmit = async (event: React.FormEvent) => {
    // Отменяем стандартное поведение формы
    event.preventDefault();

    // Сбрасываем ошибку и включаем индикатор загрузки
    setError(null);
    setIsLoading(true);

    try {
      // Отправляем запрос на сервер через общий apiClient
      const response = await apiClient.post("/auth/login", {
        login,
        password,
      });

      // Здесь можем использовать общую утилиту форматирования даты
      const loginAt = formatDate(new Date(), "long");
      console.log("User logged in at", loginAt, response.data);
    } catch (e) {
      // В случае ошибки показываем пользователю сообщение
      setError("Не удалось выполнить вход. Проверьте логин и пароль.");
    } finally {
      // Выключаем индикатор загрузки
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Поле для логина */}
      <Input
        value={login}
        onChange={setLogin}
        placeholder="Логин"
      />

      {/* Поле для пароля */}
      <Input
        value={password}
        onChange={setPassword}
        type="password"
        placeholder="Пароль"
      />

      {/* Если есть ошибка, выводим ее текст */}
      {error && <div>{error}</div>}

      {/* Кнопка входа с индикатором загрузки */}
      <Button type="submit" isLoading={isLoading}>
        Войти
      </Button>
    </form>
  );
};
```

Комментарий:

- LoginForm — часть feature auth
- она использует:
  - shared/ui: Button, Input
  - shared/api: apiClient
  - shared/lib: formatDate
- внутри shared нет ничего, что знало бы о логине или пользователе

### Пример shared-компонента, завязанного на конфиг

Бывает, что общему UI-компоненту нужны настройки из shared/config. Покажу пример:

```tsx
// src/shared/ui/debugPanel/debugPanel.tsx
import React from "react";
import { appConfig } from "@/shared/config";

interface DebugPanelProps {
  // Любые данные для отладки
  data: unknown;
}

export const DebugPanel: React.FC<DebugPanelProps> = ({ data }) => {
  // Если режим отладки выключен, ничего не рендерим
  if (!appConfig.enableDebug) {
    return null;
  }

  return (
    <pre>
      {/* Выводим данные в читаемом JSON формате */}
      {JSON.stringify(data, null, 2)}
    </pre>
  );
};
```

Такой модуль:

- используется в разных местах (например, при разработке сложных форм)
- зависит только от shared/config, а не от домена
- его можно выключить через конфигурацию

## Анти-паттерны и частые ошибки в shared-layer

### Ошибка 1. Перенос в shared «на будущее»

Есть распространенная привычка: как только появляется полезный модуль, сразу класть его в shared, даже если он используется только в одном месте.

Почему это проблема:

- увеличивается связность: shared начинают знать все фичи
- усложняется поиск кода: логика фичи «разбросана» по слоям
- растет риск, что shared станет свалкой

Лучше делать так:

1. Сначала пишем модуль там, где он нужен (внутри feature или entity)
2. Наблюдаем, начинает ли он использоваться в других модулях
3. Если использование расширяется и модуль не содержит доменной логики — выносим в shared

### Ошибка 2. Доменные названия и логика в shared

Если вы видите в shared такие названия, как:

- UserAvatarWithStatus
- OrderStatusBadge
- ProductPriceWithDiscount

то это знак, что модуль содержит знания о бизнес-сущности. Таким модулям место в entities или features.

В shared лучше использовать общие, нейтральные названия:

- Avatar
- StatusBadge
- Price

Далее в сущности или фиче можно собрать доменный компонент:

```tsx
// entities/user/ui/UserAvatar.tsx
import React from "react";
import { Avatar } from "@/shared/ui/avatar";

// Доменный компонент "Аватар пользователя"
export const UserAvatar = () => {
  // Здесь может быть логика получения пользователя
  // Например, через хук useUser
  const user = { name: "Alex", avatarUrl: "..." };

  return <Avatar src={user.avatarUrl} alt={user.name} />;
};
```

### Ошибка 3. Shared как мост между любыми слоями

Иногда shared используют как «обходные пути» для ограничений архитектуры. Например:

- feature А не может напрямую зависеть от feature B
- разработчик выносит общий код в shared, чтобы обойти правило
- в результате shared начинает знать о специфике обеих фич

Это приводит к:

- неявным зависимостям
- сложным эффектам при изменении кода
- неожиданным регрессиям

Чтобы избежать этого, полезно:

- явно описать в документации проекта, что можно, а что нельзя класть в shared
- периодически проводить ревью содержимого shared
- использовать линтеры, которые запрещают обратные зависимости (например, eslint-plugin-boundaries)

### Ошибка 4. Перегруженный экспорт shared

Если из shared/index.ts экспортируется «все подряд», это усложняет навигацию:

- автодополнение в IDE становится шумным
- трудно понять, к какому подслою относится модуль
- нет явной структуры

Лучше:

- делать отдельные «root»-модули для групп:
  - "@/shared/ui"
  - "@/shared/lib"
  - "@/shared/api"
  - "@/shared/config"
- или импортировать прямо из модуля:
  - "@/shared/ui/button"
  - "@/shared/lib/date"

## Практические рекомендации по проектированию shared-layer

### Небольшие, четко определенные модули

Старайтесь, чтобы каждый модуль в shared отвечал за одну понятную задачу:

- button — рендерит кнопку
- formatDate — форматирует даты
- apiClient — настраивает транспорт
- featureFlags — описывает включенные фичи

Если функция или компонент делает «слишком много», его лучше разделить и не выносить в shared до тех пор, пока не определится его четкая зона ответственности.

### Договоренности в команде

Чтобы shared-layer работал, а не мешал, важно, чтобы в команде были понятные правила. Примеры договоренностей:

- общий критерий, когда модуль можно выносить в shared
- список недопустимых зависимостей для shared
- код-ревью с отдельным вниманием к изменениям в shared

Вы можете оформить эти правила в документации проекта и периодически возвращаться к ним при росте кода.

### Автоматизированный контроль

Хорошая практика — не полагаться только на устные договоренности, а добавлять автоматические проверки:

- ESLint правила, запрещающие импорт из высоких слоев в низкие
- проверки путей импорта (например, запрещать `../../shared` и требовать алиасы)
- линтеры архитектуры (module boundaries)

Это уменьшает количество случайных нарушений и облегчает поддержку структуры.

## Заключение

Слой shared (shared-layer) — это фундамент с переиспользуемыми элементами приложения, которые не завязаны на конкретную бизнес-логику. При грамотном подходе он помогает:

- уменьшить дублирование кода
- сделать общие решения единообразными
- упростить поддержку и рефакторинг

Ключевые идеи:

- shared — это базовый слой, от которого могут зависеть все остальные, но он сам ни от кого не зависит
- в shared нужно класть только действительно общие и многократно используемые модули
- доменная логика и бизнес-термины в shared — тревожный сигнал
- структура shared должна быть понятной: ui, lib, api, config, model и т. п.
- полезно формализовать правила использования shared в команде и контролировать их автоматически

Если относиться к shared-layer как к аккуратной библиотеке общих механизмов, а не как к свалке «всего, что не подошло в другие слои», он становится сильной стороной архитектуры, а не источником проблем.

## Частозадаваемые технические вопросы

### Как поступать с общими хук-компонентами React — класть их в shared или в features

Если хук:
- не зависит от домена (работа с событиями окна, дебаунс, локальное хранилище) — ему место в `shared/lib` или `shared/hooks`
- инкапсулирует бизнес-процесс (useLogin, useCart, useUserProfile) — лучше хранить его в `features` или `entities`, а не в shared

### Можно ли в shared/ui использовать стор менеджера состояния например Redux или Zustand

Допустимо, но лучше избегать жестких связок. Общие UI-компоненты обычно:
- принимают данные и колбэки через пропсы
- не знают о конкретном сторадже
Если нужен доступ к стору (например, тема оформления), лучше передавать контекст через провайдеры верхнего уровня и использовать внутри shared только универсальные хуки типа useTheme без доменной логики.

### Где хранить общие схемы валидации например для форм если они используются в нескольких фичах

Если схема опирается на доменные поля (email пользователя, номер заказа) — её место в соответствующей entity или feature. В shared имеет смысл класть только базовые строительные блоки:
- общие правила (минимальная длина пароля)
- обертки над библиотеками валидации
- базовые типы ошибок

### Как разделять shared между несколькими пакетами монорепозитория

Рекомендуется выносить shared в отдельный npm-пакет внутри монорепы:
- `packages/shared-ui`
- `packages/shared-lib`
- `packages/shared-config`
Важно сохранить те же правила — отсутствие зависимостей от доменных пакетов и верхних слоев. Межпакетные зависимости лучше описать явно в package.json.

### Как обновлять модули shared без массовых регрессий

Полезный подход:
- вводить изменения через минорные версии shared (если он оформлен как пакет)
- добавлять новые API рядом со старыми, помечать старые как deprecated
- использовать строгий типизированный контракт (TypeScript)
- покрывать ключевые shared-модули тестами (юнит и компонентные) и запускать их в CI при каждом изменении shared