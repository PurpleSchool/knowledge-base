---
metaTitle: Пошаговая миграция баз данных в Go с использованием goose
metaDescription: Подробное руководство по пошаговой миграции баз данных в проектах на Go - разбор концепций миграций схема данных управление версиями и практика использования инструментов
author: Олег Марков
title: Пошаговая миграция баз данных в Go - step-by-step
preview: Разбор подхода пошаговой миграции схемы базы данных в Go - от концепций и структуры файлов до практических примеров использования миграций и откатов
---

## Введение

Пошаговая миграция (step-by-step migration) — это подход, при котором изменения в схеме базы данных и данных вносятся через последовательность маленьких, контролируемых шагов. Каждый шаг — это отдельная миграция, которую можно применить, откатить и отследить.

Смотрите, я покажу вам, как строится такой процесс от начала до конца: от настройки инструмента миграций до написания, применения и отката конкретных шагов. Для примеров я буду использовать популярный инструмент goose в Go, но сами принципы одинаково полезны и для других языков и инструментов (Liquibase, Flyway, Django migrations и т.д.).

Наша цель — разобраться, как организовать предсказуемую последовательную миграцию, не ломая продакшн и не теряя данные.

---

## Зачем нужна пошаговая миграция

### Основные проблемы без миграций

Если вы меняете схему базы данных напрямую:

- сложно воспроизвести состояние базы на другом окружении;
- непонятно, какие именно изменения уже применены;
- трудно откатить ошибочные изменения;
- опасно вносить изменения в продакшн.

Даже если вы храните SQL-скрипты в репозитории, без строгого порядка и механизма фиксации версий легко потерять синхронизацию между кодом и схемой базы.

### Что дает step-by-step подход

Пошаговая миграция решает эти проблемы за счет:

- Явного порядка шагов  
  Каждая миграция имеет номер версии. Пример: 0001_create_users.sql, 0002_add_email_to_users.sql.

- Истории изменений  
  Все изменения лежат в репозитории, вы видите, как эволюционировала схема.

- Воспроизводимости  
  Можно поднять новую базу и применить все миграции подряд, чтобы получить актуальную схему.

- Возможности отката  
  У каждой миграции есть обратный шаг (DOWN). Если что-то пошло не так, можно вернуться к предыдущей версии.

- Согласованности с кодом  
  Код и миграции синхронизированы через версии. Можно задеплоить код, затем — миграции или наоборот, в зависимости от стратегии.

Теперь давайте разберем, как это устроено на практике.

---

## Концепции пошаговой миграции

### Версия схемы и "точка во времени"

Схема базы в любой момент времени соответствует некоторой версии. Пошаговые миграции моделируют это как "ленту времени":

- версия 0 — пустая база или исходное состояние;
- версия 1 — после применения миграции 0001;
- версия 2 — после миграции 0002;
- и так далее.

Инструмент миграций хранит текущую версию в специальной служебной таблице в базе. Например, goose создает таблицу goose_db_version.

Каждый раз, когда вы запускаете миграции:

1. Проверяется текущая версия в таблице версий.
2. Сканируются файлы миграций в директории.
3. Выбираются скрипты, которые нужно применить или откатить, чтобы дойти до целевой версии.
4. Скрипты выполняются по порядку.

### Типы миграций

В step-by-step подходе обычно различают:

- DDL миграции  
  Изменения структуры — создание таблиц, изменение столбцов, индексов, ограничений.

- DML миграции  
  Изменения данных — миграция старых данных в новый формат, добавление справочников, фиксы.

- Миграции совместимости  
  Временные шаги, позволяющие код старой версии работать с новой схемой (и наоборот).

Часто одну логическую фичу разбивают на несколько миграций, чтобы соблюдать безопасную последовательность.

---

## Подготовка проекта для миграций (на примере Go и goose)

### Установка инструмента миграций

Покажу вам, как это выглядит с goose.

Установим инструмент командой:

```bash
go install github.com/pressly/goose/v3/cmd/goose@latest
```

Комментарий:

```bash
# Эта команда скачивает и устанавливает бинарник goose
# Теперь вы сможете запускать его как обычную CLI-команду
goose -h
```

Если хотите использовать goose как библиотеку из кода Go:

```bash
go get github.com/pressly/goose/v3
```

Комментарий:

```bash
# Эта команда добавляет зависимость goose в ваш Go-модуль
# Миграции можно будет запускать как из CLI, так и из Go-кода
```

### Структура директорий проекта

Рекомендуемая структура для миграций:

```text
your-project/
  cmd/
  internal/
  db/
    migrations/        # Здесь лежат файлы миграций
  config/
  main.go
```

Комментарий:

```text
# Каталог db/migrations будет единой точкой для всех SQL-миграций
# Инструмент goose будет сканировать его и искать файлы *.sql
```

Вы можете выбрать любое расположение, главное — придерживаться единого правила во всех окружениях.

### Настройка подключения к базе

Goose поддерживает разные способы передачи строки подключения. Один из удобных — использовать переменные окружения и флаг -dir.

Пример команды:

```bash
export DB_URL="postgres://user:pass@localhost:5432/mydb?sslmode=disable"

# Применить все доступные миграции
goose -dir ./db/migrations postgres "$DB_URL" up
```

Комментарий:

```bash
# export DB_URL — задаем строку подключения к базе через переменную окружения
# -dir ./db/migrations — путь к каталогу с миграциями
# postgres — драйвер/тип базы данных
# "$DB_URL" — сама строка подключения
# up — команда применить миграции 'вверх' до последней версии
```

---

## Создание первой миграции step-by-step

### Генерация файла миграции

Давайте создадим первую миграцию, которая добавит таблицу users.

Команда:

```bash
goose -dir ./db/migrations create create_users_table sql
```

Комментарий:

```bash
# create — команда создания нового файла миграции
# create_users_table — произвольное имя миграции (описание того, что она делает)
# sql — формат миграции (поддерживаются sql и go)
# goose автоматически сгенерирует файл с префиксом версии, например:
# 20260116123045_create_users_table.sql
```

### Структура SQL-миграции

Откройте созданный файл. Goose ожидает два блока:

- Up — для применения миграции;
- Down — для отката.

Пример файла:

```sql
-- +goose Up
-- Здесь мы создаем таблицу users с базовыми полями
CREATE TABLE users (
    id          SERIAL PRIMARY KEY,        -- Уникальный идентификатор
    email       TEXT NOT NULL UNIQUE,      -- Почта пользователя
    created_at  TIMESTAMP NOT NULL,        -- Время создания
    updated_at  TIMESTAMP NOT NULL         -- Время обновления
);

-- +goose Down
-- Здесь мы откатываем миграцию и удаляем таблицу
DROP TABLE IF EXISTS users;
```

Комментарии в SQL важны — они помогают быстро понять, что делает шаг, особенно при отладке или ревью.

### Применение миграции

Теперь давайте применим миграцию к базе:

```bash
goose -dir ./db/migrations postgres "$DB_URL" up
```

Комментарий:

```bash
# goose найдет все файлы миграций в ./db/migrations
# Определит текущую версию в таблице goose_db_version
# Применит все миграции, у которых версия больше текущей
# В нашем случае будет выполнен блок Up для create_users_table
```

После этого в базе появится:

- таблица users;
- служебная таблица goose_db_version с записью о примененной миграции.

---

## Пошаговая эволюция схемы на примере фичи

Представьте, что вам нужно добавить в систему поддержку профилей пользователей. Попробуем сделать это с использованием нескольких миграций step-by-step.

### Шаг 1 — добавление нового столбца в существующую таблицу

Начнем с простого: добавим username в таблицу users.

Создаем новую миграцию:

```bash
goose -dir ./db/migrations create add_username_to_users sql
```

Смотрите, я покажу вам, как заполнить файл:

```sql
-- +goose Up
-- Здесь мы добавляем новый столбец username в таблицу users
ALTER TABLE users
    ADD COLUMN username TEXT;

-- +goose Down
-- Здесь мы удаляем столбец username при откате миграции
ALTER TABLE users
    DROP COLUMN IF EXISTS username;
```

Применяем:

```bash
goose -dir ./db/migrations postgres "$DB_URL" up
```

Теперь в таблице users есть новое поле username.

### Шаг 2 — миграция данных

Допустим, у вас уже есть пользователи, и вы хотите заполнить username на основе email (часть до @).

Создадим еще одну миграцию:

```bash
goose -dir ./db/migrations create backfill_username_from_email sql
```

Теперь вы увидите, как это выглядит в коде:

```sql
-- +goose Up
-- Здесь мы заполняем username на основе части email до символа @
UPDATE users
SET username = split_part(email, '@', 1)
WHERE username IS NULL;

-- +goose Down
-- При откате мы просто обнуляем username, чтобы вернуть состояние до миграции
UPDATE users
SET username = NULL;
```

Комментарий:

- split_part — функция PostgreSQL, которая берет часть строки до @;
- важно, что миграция данных отделена от изменения структуры — это делает шаги более предсказуемыми и простыми для отката.

### Шаг 3 — добавление ограничений

Когда вы убедились, что все username заполнены и корректны, можно ужесточить схему.

Создадим миграцию:

```bash
goose -dir ./db/migrations create add_username_not_null_and_unique sql
```

Давайте посмотрим, что происходит в следующем примере:

```sql
-- +goose Up
-- Здесь мы делаем username обязательным и уникальным
ALTER TABLE users
    ALTER COLUMN username SET NOT NULL;

ALTER TABLE users
    ADD CONSTRAINT users_username_unique UNIQUE (username);

-- +goose Down
-- Здесь мы снимаем ограничения, возвращая столбец в исходное состояние
ALTER TABLE users
    DROP CONSTRAINT IF EXISTS users_username_unique;

ALTER TABLE users
    ALTER COLUMN username DROP NOT NULL;
```

Заметьте, мы не делаем это в одной миграции с добавлением столбца. Это классический пример безопасного step-by-step подхода:

1. Добавили столбец (структура).
2. Заполнили данные.
3. Ужесточили ограничения.

Такой подход позволяет деплоить код и миграции постепенно, не ломая существующую функциональность.

---

## Безопасная стратегия step-by-step при изменении схемы

Теперь давайте разберем типовой паттерн пошаговой миграции, которым удобно пользоваться:

### Шаг A — "расширить" (expand)

Сначала добавляются новые элементы схемы, не ломая старые:

- новые таблицы;
- новые столбцы (nullable или с дефолтами);
- новые индексы;
- новые ограничения, которые не конфликтуют с текущими данными.

Пример:

```sql
-- +goose Up
-- Добавляем новый столбец, но пока не делаем его обязательным
ALTER TABLE orders
    ADD COLUMN external_id TEXT;

-- +goose Down
-- При откате удаляем столбец
ALTER TABLE orders
    DROP COLUMN IF EXISTS external_id;
```

Код приложения при этом должен уметь работать и без нового столбца (на старой версии схемы), если вы раскатываете миграции после кода, или наоборот — терпеть его наличие, если миграции выкатываются до кода.

### Шаг B — миграция данных

После изменения структуры выполняется миграция данных:

- перенос данных из старого формата в новый;
- заполнение новых обязательных полей;
- нормализация данных.

Пример:

```sql
-- +goose Up
-- Заполняем внешний идентификатор для существующих записей
UPDATE orders
SET external_id = 'legacy-' || id
WHERE external_id IS NULL;

-- +goose Down
-- Очищаем внешний идентификатор при откате
UPDATE orders
SET external_id = NULL;
```

Важно: такие миграции старайтесь делать идемпотентными или максимально безболезненными при повторном выполнении, потому что откаты и повторные прогонки иногда случаются.

### Шаг C — "сжать" (contract)

Только после того, как новый код успешно работает с новой схемой, можно:

- сделать поля NOT NULL;
- удалить старые столбцы;
- удалить временные данные.

Пример:

```sql
-- +goose Up
-- Делаем external_id обязательным и удаляем старый столбец old_external_id
ALTER TABLE orders
    ALTER COLUMN external_id SET NOT NULL;

ALTER TABLE orders
    DROP COLUMN IF EXISTS old_external_id;

-- +goose Down
-- Возвращаем старое состояние
ALTER TABLE orders
    ADD COLUMN old_external_id TEXT;

ALTER TABLE orders
    ALTER COLUMN external_id DROP NOT NULL;
```

Такой expand-migrate-contract цикл — основа безопасных пошаговых миграций.

---

## Команды goose и управление версиями

### Основные команды

1. Применить все доступные миграции вверх:

```bash
goose -dir ./db/migrations postgres "$DB_URL" up
```

2. Применить только одну следующую миграцию:

```bash
goose -dir ./db/migrations postgres "$DB_URL" up-by-one
```

Комментарий:

```bash
# Полезно для постепенной отладки каждой миграции
```

3. Откатить последнюю миграцию:

```bash
goose -dir ./db/migrations postgres "$DB_URL" down
```

4. Откатить до конкретной версии:

```bash
goose -dir ./db/migrations postgres "$DB_URL" down-to 20260116123045
```

Комментарий:

```bash
# 20260116123045 — номер версии из имени файла миграции
# goose выполнит блоки Down для всех миграций с большей версией
```

5. Применить до конкретной версии:

```bash
goose -dir ./db/migrations postgres "$DB_URL" up-to 20260116123045
```

6. Увидеть текущую версию:

```bash
goose -dir ./db/migrations postgres "$DB_URL" status
```

Комментарий:

```bash
# status показывает список всех миграций и отметку — применена она или нет
# Это удобно для понимания, что творится в базе на конкретном окружении
```

### Применение миграций из Go-кода

Если вам нужно запускать миграции программно (например, при старте сервиса), можно использовать goose как библиотеку.

Пример:

```go
package main

import (
    "database/sql"
    "log"

    "github.com/pressly/goose/v3"

    _ "github.com/lib/pq" // Здесь мы подключаем драйвер postgres
)

func main() {
    // Здесь мы открываем соединение с базой
    db, err := sql.Open("postgres", "postgres://user:pass@localhost:5432/mydb?sslmode=disable")
    if err != nil {
        log.Fatalf("failed to open DB connection: %v", err)
    }
    defer db.Close()

    // Указываем директорию с миграциями
    migrationsDir := "./db/migrations"

    // Здесь мы применяем все миграции вверх
    if err := goose.Up(db, migrationsDir); err != nil {
        log.Fatalf("failed to apply migrations: %v", err)
    }

    // Если вы хотите применить миграции до конкретной версии:
    // targetVersion := int64(20260116123045)
    // if err := goose.UpTo(db, migrationsDir, targetVersion); err != nil {
    //     log.Fatalf("failed to migrate to version %d: %v", targetVersion, err)
    // }
}
```

Обратите внимание, как этот фрагмент кода решает задачу:

- он открывает соединение с базой;
- указывает путь к миграциям;
- применяет миграции при запуске сервиса.

Такой вариант удобно использовать в тестах или локально, но в продакшне чаще миграции запускают отдельным CI/CD шагом.

---

## Практические советы по организации миграций

### Единый источник правды

Храните все миграции в одном каталоге и в одном репозитории вместе с кодом. Это позволяет:

- синхронизировать версии кода и схемы;
- просматривать историю изменений через git;
- код-ревью миграций так же, как обычный код.

### Именование файлов миграций

Старайтесь называть миграции так, чтобы по имени было понятно, что именно происходит:

- 20260116120000_create_users_table.sql
- 20260116121000_add_username_to_users.sql
- 20260116122000_backfill_username_from_email.sql

Порядковый номер (timestamp) отвечает за порядок, а текстовая часть — за смысл.

### Маленькие атомарные шаги

Лучше сделать несколько небольших миграций, чем одну "гигантскую":

- проще ревью;
- легче откатываться;
- проще понимать, какая миграция вызвала проблему.

Пример:

- отдельно create_table;
- отдельно add_column;
- отдельно add_index;
- отдельно data_migration.

### Транзакции и длительные операции

Не все миграции одинаково безопасны. В PostgreSQL большинство DDL-операций можно обернуть в транзакции, и goose по умолчанию это делает. Но:

- длительные операции (rebuild больших индексов, масштабные обновления данных) могут занимать много времени;
- при долгой транзакции блокируются таблицы, что мешает работе приложения.

Рекомендации:

- разбивайте тяжелые миграции данных на батчи;
- по возможности используйте миграции, которые не блокируют чтение;
- для особо тяжелых операций иногда создают отдельные фоновые процессы, а миграции используют только для легких структурных изменений.

### Миграции и тесты

Хорошая практика — поднимать тестовую базу и прогонять по ней все миграции в CI перед запуском тестов.

Пример сценария:

1. Создать временную базу (Docker или in-memory).
2. Применить все миграции (goose up).
3. Прогнать юнит- и интеграционные тесты.

Так вы будете уверены, что:

- миграции применяются без ошибок;
- текущий код совместим с актуальной схемой.

---

## Ошибки и откаты в step-by-step миграциях

### Типичные ошибки при написании миграций

1. Неправильный порядок действий  
   Например, вы сначала делаете колонку NOT NULL, а потом заполняете данные. Это приведет к ошибке.

2. Небезопасные изменения "в лоб"  
   Удаление столбцов или таблиц без промежуточных шагов часто ломает старый код.

3. Миграции, зависящие от содержимого базы "здесь и сейчас"  
   Например, вы пишете сложный UPDATE, не учитывая редкие значения — и они ломают миграцию на одном из окружений.

4. Изменения большого объема данных в транзакции  
   Можно легко заблокировать таблицу на долгое время.

### Как безопасно откатываться

Если вы обнаружили ошибку:

1. Оцените, можно ли откатить последнюю миграцию (нет ли уже кода, который на нее опирается).
2. Если можно, выполните:

```bash
goose -dir ./db/migrations postgres "$DB_URL" down
```

3. Проверьте состояние схемы и данных.
4. Исправьте миграцию или создайте новую, которая корректирует проблему.

Важно: в продакшне откат — не всегда лучший вариант, особенно если миграция затронула данные, которые уже начали использоваться. Иногда лучше:

- оставить схему как есть;
- добавить новую "фиксящую" миграцию, которая исправит проблему.

---

## Работа с несколькими окружениями и командами

### Синхронизация окружений

Типичная схема:

- локальная разработка;
- dev / staging окружение;
- продакшн.

На каждом окружении:

- одна и та же директория миграций;
- свои строки подключения к базе;
- один и тот же порядок применения миграций.

Чтобы избежать рассинхронизации:

- не меняйте уже примененные миграции (не редактируйте Up/Down в старых файлах);
- если нужно изменить поведение — создайте новую миграцию;
- следите, чтобы порядок создания миграций не ломался при работе нескольких разработчиков (используйте timestamp в имени файла).

### Командная работа

Когда несколько разработчиков добавляют миграции:

- каждый создает свои миграции с уникальными timestamp;
- при мердже в main/ master все миграции просто сортируются по версии;

Если у двух миграций одинаковый timestamp (редко, но возможно), переименуйте одну из них, пересоздав файл миграции через goose create, чтобы версия стала уникальной.

---

## Пример полного цикла step-by-step изменения функции

Давайте разберем более сложный сценарий: вы хотите переименовать столбец в таблице, но не можете просто сделать ALTER TABLE RENAME COLUMN, потому что:

- у вас есть старый код, который читает старое имя;
- новый код будет читать новое имя.

Типичный безопасный цикл:

### Шаг 1 — добавить новый столбец

```bash
goose -dir ./db/migrations create add_new_column_profile_name sql
```

```sql
-- +goose Up
-- Добавляем новый столбец profile_name, но пока не трогаем старый name
ALTER TABLE users
    ADD COLUMN profile_name TEXT;

-- +goose Down
-- Удаляем profile_name при откате
ALTER TABLE users
    DROP COLUMN IF EXISTS profile_name;
```

### Шаг 2 — миграция данных

```bash
goose -dir ./db/migrations create backfill_profile_name_from_name sql
```

```sql
-- +goose Up
-- Переносим данные из старого столбца name в новый profile_name
UPDATE users
SET profile_name = name
WHERE profile_name IS NULL;

-- +goose Down
-- Возвращаем значения обратно в name при откате
UPDATE users
SET name = profile_name
WHERE name IS NULL AND profile_name IS NOT NULL;
```

Теперь:

- старый код продолжает использовать name;
- новый код может начать использовать profile_name.

### Шаг 3 — обновление приложения

Вы раскатываете новую версию сервиса:

- чтение идет из profile_name;
- запись идет и в name, и в profile_name, пока длится переходный период.

### Шаг 4 — очистка старого поля

Когда вы уверены, что все клиенты используют новый код, можно удалить старый столбец:

```bash
goose -dir ./db/migrations create drop_old_name_column sql
```

```sql
-- +goose Up
-- Удаляем устаревший столбец name
ALTER TABLE users
    DROP COLUMN IF EXISTS name;

-- +goose Down
-- Восстанавливаем столбец name, но без данных
ALTER TABLE users
    ADD COLUMN name TEXT;
```

Вот так пошаговая миграция помогает безопасно эволюционировать схему даже для "опасных" изменений.

---

В этой статье мы разобрали подход пошаговой миграции (step-by-step) на примере Go и инструмента goose:

- рассмотрели, зачем нужны миграции и как они организуют "ленту времени" схемы базы;
- посмотрели, как создать, применить и откатить миграции;
- прошли через практические сценарии: добавление столбцов, миграция данных, ужесточение ограничений;
- обсудили безопасный паттерн expand-migrate-contract;
- затронули вопросы транзакций, длительных операций и работы в команде.

Если вы будете мыслить миграциями как последовательностью небольших, контролируемых шагов, вам будет намного проще управлять схемой базы на реальных проектах, особенно в продакшн-среде.

---

## Частозадаваемые технические вопросы по теме и ответы

### Как запускать разные наборы миграций для разных баз (например, для нескольких микросервисов)

Создайте отдельные директории миграций для каждой базы, например db/user_service_migrations и db/order_service_migrations. В каждой — свой набор файлов и своя таблица версий в базе. При запуске используйте флаг -dir с нужным путем. В CI для каждого сервиса/базы запускайте goose с соответствующей директорией.

### Что делать, если миграция сломалась посередине и база в неизвестном состоянии

Сначала посмотрите статус через goose status и журнал базы. Если миграция была в транзакции, частичные изменения откатятся автоматически. Если операция была вне транзакции, восстановите консистентность вручную (через SQL), затем либо повторите миграцию, либо создайте новую "фиксирующую". Не редактируйте уже примененные миграции, чтобы не ломать другие окружения.

### Как обрабатывать несовместимые изменения схемы между версиями приложения

Используйте стратегию расширения и сжатия. Сначала добавляйте новые поля и данные, чтобы новая и старая версия кода могли работать параллельно. Только после полного деплоя всех инстансов с новым кодом удаляйте старые поля. Избегайте миграций, после которых старая версия кода перестает работать.

### Можно ли объединять несколько логических шагов в одну миграцию, чтобы уменьшить количество файлов

Технически можно, но это ухудшает управляемость. Лучше разделять: изменение структуры, миграция данных, ужесточение ограничений. Тогда проще откатить только изменение структуры или только миграцию данных и проще понять, какой именно шаг вызвал проблему.

### Как тестировать миграции локально без риска повредить основную базу

Используйте отдельную тестовую базу, например в Docker-контейнере. В docker-compose поднимайте контейнер с базой, указывайте отдельный DB_URL (например mydb_migrations_test) и прогоняйте goose up. После проверки можно базу просто удалить. Такой подход удобно автоматизировать в make-таргете или в отдельном скрипте.