---
metaTitle: Просмотр истории в Git с помощью git log
metaDescription: Подробное руководство по использованию git log - разбор ключей форматирования и фильтрации истории коммитов на практике
author: Олег Марков
title: Просмотр истории в Git с помощью git log
preview: Узнайте как эффективно просматривать историю коммитов в Git с помощью git log - от базового вывода до сложной фильтрации и кастомного форматирования
---

## Введение

Команда git log — это основной инструмент для просмотра истории изменений в репозитории. С ее помощью вы можете увидеть, кто и когда выполнял коммиты, какие файлы менялись, к какому ветвлению относится коммит, как связаны между собой ветки и многое другое.

Смотрите, я покажу вам, как с помощью git log шаг за шагом перейти от простого списка коммитов к удобным и наглядным представлениям истории, которые реально помогают в работе: при отладке, ревью, поиске багов и анализе изменений.

В этой статье вы разберете:

- базовое использование git log;
- настройки объема и порядка вывода;
- удобное форматирование строк коммитов;
- вывод истории в виде дерева веток;
- фильтрацию по автору, дате, файлам, словам в сообщениях;
- сравнение веток и ограничение области вывода;
- полезные комбинации с другими командами Git.

## Базовый вывод git log

### Самая простая форма

Начнем с самого простого варианта. Если просто выполнить в репозитории:

```bash
git log
```

вы увидите список коммитов в обратном хронологическом порядке (самый свежий сверху). Каждый блок обычно содержит:

- строку с хешем коммита;
- автора;
- дату;
- сообщение коммита.

Пример фрагмента вывода (он будет примерно таким):

```text
commit 9fceb02c1b0d0a5b1c1c6a8c9a1f81b7c5b5c1a
Author: Ivan Petrov <ivan@example.com>
Date:   Mon Nov 25 10:15:32 2024 +0300

    Исправлена ошибка в обработке запроса

commit 1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0
Author: Anna Ivanova <anna@example.com>
Date:   Sun Nov 24 18:02:11 2024 +0300

    Добавлен эндпоинт для получения статистики
```

Сейчас вывод достаточно подробный, но плохо помещается на экране при большой истории. Давайте сделаем его компактнее.

### Короткий формат — опция --oneline

Чтобы увидеть историю более компактно, удобно использовать опцию:

```bash
git log --oneline
```

Вывод будет примерно таким:

```text
9fceb02 Исправлена ошибка в обработке запроса
1a2b3c4 Добавлен эндпоинт для получения статистики
```

Обратите внимание:

- хеш сокращен до нескольких символов;
- показывается только первая строка сообщения коммита.

Такой вид очень удобен, когда вы хотите просто «пробежаться» по истории и понять общую картину.

### Количество выводимых коммитов

Часто нужно посмотреть не всю историю, а только последние несколько изменений. Для этого есть два привычных способа.

Через параметр -n:

```bash
git log -n 5     # Показать последние 5 коммитов
git log -5       # Короткая запись, то же самое
```

Или в сочетании с --oneline:

```bash
git log --oneline -5
```

Здесь мы ограничиваем вывод последними пятью коммитами и делаем формат компактным.

### Порядок вывода: от старых к новым

По умолчанию git log показывает коммиты от новых к старым. Если вы хотите увидеть историю в хронологическом порядке, используйте:

```bash
git log --reverse
```

Можно комбинировать:

```bash
git log --oneline --reverse
```

Теперь вы увидите историю от самого первого коммита к последнему.

## Настройка формата вывода

Стандартного формата часто не хватает: хочется видеть только нужную информацию, в определенном порядке, с цветами и понятными метками. Для этого в git log есть параметр --pretty.

### Предустановленные форматы: --pretty=oneline, short, medium, full, fuller

Смотрите, я покажу вам классический пример:

```bash
git log --pretty=oneline
```

Это похоже на --oneline, но технически немного другое: здесь можно тонко управлять форматом позже.

Некоторые готовые форматы:

```bash
git log --pretty=short
git log --pretty=medium     # формат по умолчанию
git log --pretty=full
git log --pretty=fuller
```

Они отличаются набором полей (кем создан коммит, кем применен, полная дата и так далее). Вы можете поэкспериментировать, чтобы увидеть разницу.

### Полностью настраиваемый формат: --pretty=format

Самая полезная возможность — это свой формат строк:

```bash
git log --pretty=format:"%h %an %ar %s"
```

Разберем, что здесь происходит:

- %h — сокращенный хеш коммита;
- %an — имя автора;
- %ar — относительное время (например, 2 hours ago);
- %s — тема (первая строка) сообщения коммита.

Пример результата:

```text
9fceb02 Ivan Petrov 2 hours ago Исправлена ошибка в обработке запроса
1a2b3c4 Anna Ivanova 1 day ago Добавлен эндпоинт для получения статистики
```

Теперь давайте посмотрим еще несколько полезных плейсхолдеров:

- %H — полный хеш;
- %ae — email автора;
- %cn — имя коммитера (того, кто применил коммит);
- %ce — email коммитера;
- %cd — дата коммита в читабельном виде;
- %d — ссылки (ветки, теги), указывающие на этот коммит;
- %p — родительские коммиты;
- %b — тело сообщения коммита (все строки кроме первой).

Пример более информативного формата:

```bash
git log --pretty=format:"%h %ad %an - %s" --date=short
```

Здесь:

- --date=short переводит дату в формат YYYY-MM-DD;
- строка становится компактной и удобной для просмотра.

### Добавление цветов в вывод

Цвет очень помогает быстро ориентироваться. Давайте добавим цвета в формат:

```bash
git log --pretty=format:"%C(yellow)%h%Creset %Cgreen%ad%Creset %Cblue%an%Creset - %s" --date=short
```

Здесь:

- %C(yellow) — установка желтого цвета;
- %Creset — сброс цвета к стандартному;
- %Cgreen, %Cblue — другие цвета.

Как видите, этот код выполняет задачу подсветки важных частей коммита: хеш, дата и автор становятся более заметными.

### Вывод только хешей — опция --format и --no-walk

Иногда нужно получить только список хешей, например, для передачи в скрипт. Покажу вам, как это сделать:

```bash
git log --format="%H"
```

Чтобы получить только один хеш, ближайший к HEAD:

```bash
git log -1 --format="%H"
```

Или, если вы хотите просто список коммитов без обхода графа в глубину, иногда удобно использовать:

```bash
git log --no-walk --oneline <commit1> <commit2>
```

Так вы увидите указанные коммиты, но без показа всей их истории.

## Просмотр истории как дерева

### Граф веток: --graph

Для понимания структуры ветвлений очень помогает графическое представление. В терминале это делается с помощью:

```bash
git log --oneline --graph
```

Вывод может выглядеть так:

```text
* 9fceb02 Исправлена ошибка в обработке запроса
*   6b5c123 Слияние ветки feature/login
|\
| * 3a4d567 Добавлена авторизация по токену
| * 1b2c345 Добавлена страница логина
* | 4c5d678 Фикс шаблонов в layout
|/
* a1b2c3d Инициализация проекта
```

Символы |, \, / и * показывают структуру ветвления и слияний.

Вы можете комбинировать граф с форматированием:

```bash
git log --graph --pretty=format:"%h %an %s" --date=short
```

Так вы получите и наглядное дерево, и понятный формат строк.

### Показать ветки и теги возле коммитов: --decorate

Чтобы видеть, какие ветки и теги указывают на конкретный коммит, используйте:

```bash
git log --oneline --decorate
```

Пример вывода:

```text
9fceb02 (HEAD -> main, origin/main) Исправлена ошибка в обработке запроса
6b5c123 (tag: v1.0.0) Слияние ветки feature/login
a1b2c3d (origin/develop, develop) Инициализация проекта
```

Теперь вы видите, где находятся HEAD, локальные ветки, удаленные ветки и теги.

Часто удобно сразу объединять все вместе:

```bash
git log --oneline --graph --decorate --all
```

Опция --all добавляет в граф все ветки (а не только текущую). Это хороший способ быстро увидеть общую картину всех веток в репозитории.

## Фильтрация истории

История в реальном проекте может быть очень длинной. Без фильтрации найти нужный коммит сложно, поэтому давайте разберем разные варианты ограничений.

### Фильтрация по автору

Если вам нужно увидеть только коммиты определенного автора, используйте:

```bash
git log --author="Ivan"
```

Важно:

- Git ищет по подстроке, поэтому достаточно части имени или email;
- можно использовать регулярные выражения.

Например:

```bash
git log --author="^Ivan Petrov" --oneline
```

Здесь регулярное выражение ^Ivan Petrov говорит: имя автора должно начинаться с «Ivan Petrov».

### Фильтрация по дате

Git позволяет указывать диапазоны дат в разных форматах. Давайте разберемся на примерах.

Последние два дня:

```bash
git log --since="2 days ago"
```

Начиная с определенной даты:

```bash
git log --since="2024-11-01"
```

До определенной даты:

```bash
git log --until="2024-11-15"
```

Коммиты в диапазоне:

```bash
git log --since="2024-11-01" --until="2024-11-15"
```

Можно комбинировать с --oneline или другими опциями:

```bash
git log --oneline --since="1 week ago" --author="Anna"
```

### Поиск по сообщению коммита: --grep

Иногда вы помните, что в сообщении коммита было ключевое слово. В этом случае пригодится опция --grep.

Пример:

```bash
git log --grep="bugfix" --oneline
```

Поиск по нескольким словам (по умолчанию «или»):

```bash
git log --grep="bug" --grep="fix" --oneline
```

Если вы хотите, чтобы совпали все grep одновременно (логическое «и»), добавьте:

```bash
git log --grep="bug" --grep="urgent" --all-match --oneline
```

Здесь будут показаны только те коммиты, в сообщении которых есть и bug и urgent.

### Фильтрация по файлам

Частая задача — посмотреть историю изменений конкретного файла или директории. Вот так это делается:

```bash
git log -- path/to/file.txt
```

Важно: опции пути идут после параметров git log. Если вы напишете:

```bash
git log path/to/file.txt
```

Git может интерпретировать это как ревизию, а не путь. Поэтому лучше всегда ставить двойной дефис:

```bash
git log -- path/to/file.txt
```

История по директории:

```bash
git log -- path/to/directory/
```

Как видите, этот фрагмент решает задачу локализации истории в конкретной части проекта.

### Объединение фильтров

Вы можете комбинировать фильтры по автору, дате, сообщению и файлам. Пример:

```bash
git log --oneline \
  --author="Ivan" \
  --since="2024-11-01" \
  --grep="hotfix" \
  -- path/to/file.txt
```

Здесь мы видим:

- коммиты Ивана;
- не старше 1 ноября 2024;
- в сообщении есть слово hotfix;
- коммит затрагивает конкретный файл.

## Ограничение области истории: диапазоны коммитов и веток

Иногда нужно посмотреть историю только между двумя точками, например, коммиты, которые есть в одной ветке и отсутствуют в другой.

### Диапазоны с помощью синтаксиса A..B и A...B

Давайте посмотрим, как это работает.

Коммиты, которые есть в B, но их нет в A:

```bash
git log A..B
```

Например:

```bash
git log main..feature/login --oneline
```

Это покажет коммиты, которые есть в ветке feature/login, но отсутствуют в main. Такой способ удобно использовать при подготовке к слиянию или ревью.

Симметричная разность (только уникальные для каждой ветки):

```bash
git log main...feature/login --oneline
```

Здесь будут показаны коммиты, которые находятся либо только в main, либо только в feature/login, но не в обоих одновременно.

### Отдельные коммиты: указание диапазона A..B с хешами

Вы можете использовать любые ревизии: ветки, теги, хеши.

Пример:

```bash
git log 1a2b3c4..9fceb02 --oneline
```

Здесь будут коммиты от (не включая) 1a2b3c4 до (включая) 9fceb02.

### История только до конкретного коммита

Если вы хотите посмотреть историю «на момент» определенного коммита, используйте:

```bash
git log <commit>
```

Например:

```bash
git log 1a2b3c4 --oneline
```

В этом случае будет показана история, заканчивающаяся на 1a2b3c4.

Вы также можете добавить опцию -p для просмотра диффов (об этом ниже), и увидеть, какие изменения привели к этому состоянию.

## Просмотр изменений вместе с историей: -p и --stat

Иногда важно не только знать, что был сделан коммит, но и какие строки изменились. Для этого у git log есть несколько полезных опций.

### Показать патчи для каждого коммита: -p

Опция -p показывает diff (патч) для каждого коммита:

```bash
git log -p
```

Если добавить --oneline, формат останется компактным для заголовков, но патч все равно будет выводиться:

```bash
git log -p --oneline
```

Обычно так выводить всю историю неудобно, поэтому чаще добавляют ограничение по количеству коммитов:

```bash
git log -p -3
```

Здесь показаны патчи только для последних трех коммитов.

### Статистика изменений: --stat

Опция --stat показывает сводку по изменениям в каждом коммите:

```bash
git log --stat
```

Вывод будет содержать:

- список файлов, измененных в коммите;
- число добавленных и удаленных строк;
- общую статистику в конце каждого блока.

Пример фрагмента:

```text
 app/controllers/users_controller.rb | 10 +++++-----
 app/views/users/show.html.erb       |  4 ++--
 2 files changed, 7 insertions(+), 7 deletions(-)
```

Если вы хотите совместить статистику с компактным заголовком:

```bash
git log --oneline --stat
```

Так вы видите короткую информацию о коммите и сразу же по каждому коммиту видите, какие файлы затронуты.

### Сравнение с git show

Команда git show показывает информацию только по одному коммиту (по умолчанию — по HEAD). По сути, это git log -1 -p с другим форматом по умолчанию.

Пример:

```bash
git show
```

Это удобно, когда вы хотите посмотреть детали последнего коммита, не просматривая всю историю.

## Удобные сочетания и алиасы

Когда вы набираете одни и те же длинные команды git log, есть смысл вынести их в алиасы. Но прежде чем к этому перейти, давайте посмотрим на несколько полезных сочетаний.

### Классический «обзор веток» в одной команде

В реальных проектах часто используют вот такую конструкцию:

```bash
git log --oneline --graph --decorate --all
```

- --oneline — компактный формат;
- --graph — дерево веток;
- --decorate — показывать ветки и теги;
- --all — выводить все ветки.

Это хороший способ быстро оценить структуру репозитория.

### История по конкретному файлу с диффами

Когда нужно понять, кто и как менял определенный файл:

```bash
git log -p -- path/to/file.txt
```

Здесь:

- git log -p показывает патчи;
- -- path/to/file.txt ограничивает историю только этим файлом.

### Только список файлов, меняемых в коммитах

Если вас интересует в основном состав файлов, а не строковый дифф, можно использовать:

```bash
git log --name-only
```

Или в сочетании с фильтром по автору:

```bash
git log --name-only --author="Ivan"
```

Тогда вы увидите историю коммитов с перечислением файлов, которые менялись в каждом из них.

### Создание алиасов для git log

Чтобы не вводить длинную команду каждый раз, можно добавить алиас в настройку Git. Для этого выполните:

```bash
git config --global alias.lg "log --oneline --graph --decorate --all"
```

Комментарии к коду:

```bash
git config --global alias.lg "log --oneline --graph --decorate --all"
# --global - сохраняет алиас в глобальной конфигурации пользователя
# alias.lg - имя алиаса, теперь можно вызывать "git lg"
# в кавычках - реальная команда, которая будет выполняться
```

Теперь вы можете просто написать:

```bash
git lg
```

и получите красивый граф истории по всем веткам.

Можно завести и другие варианты, например:

```bash
git config --global alias.l "log --oneline --decorate"
```

Тогда:

```bash
git l
```

будет выводить короткую историю по текущей ветке с указанием веток и тегов.

## Практические сценарии использования git log

Теперь давайте свяжем все опции в практические сценарии, с которыми вы будете сталкиваться в реальной работе.

### Сценарий 1. Подготовка к code review

Предположим, вы хотите посмотреть, какие коммиты есть в ветке feature, но их еще нет в main.

```bash
git log main..feature --oneline --stat
```

Комментарии:

```bash
git log main..feature --oneline --stat
# main..feature - коммиты, которые есть в feature, но отсутствуют в main
# --oneline - компактный список коммитов
# --stat - сводка по измененным файлам и числу строк
```

Так вы быстро оцениваете, сколько коммитов нужно ревьюить и какие файлы изменены.

### Сценарий 2. Поиск коммита, где появился баг

Вы подозреваете, что баг связан с изменениями в файле handlers.go за последнюю неделю. Давайте посмотрим:

```bash
git log -p --since="1 week ago" -- handlers/handlers.go
```

Комментарии:

```bash
git log -p --since="1 week ago" -- handlers/handlers.go
# -p - показывать патчи (диффы) для каждого коммита
# --since="1 week ago" - ограничиваемся неделей
# -- handlers/handlers.go - история только по этому файлу
```

Просматривая диффы, вы можете увидеть конкретное изменение, которое могло привести к багу.

### Сценарий 3. Анализ вклада конкретного разработчика

Допустим, вы хотите понять, какие изменения вносил конкретный разработчик за последний месяц.

```bash
git log --author="Anna" --since="1 month ago" --oneline --stat
```

Здесь вы увидите коммиты Анны, когда они были сделаны и какие файлы изменялись в каждом коммите.

### Сценарий 4. Анализ релиза между двумя тегами

У вас есть два тега — v1.0.0 и v1.1.0. Нужно понять, какие коммиты вошли в релиз v1.1.0 по сравнению с v1.0.0.

```bash
git log v1.0.0..v1.1.0 --oneline --stat
```

Так вы ясно видите список коммитов и их влияние на файлы. Это удобно использовать при составлении списка изменений (changelog).

### Сценарий 5. Быстрый обзор истории в большой команде

В проекте много веток, и вы хотите быстро увидеть общую картину, кто над чем работает:

```bash
git log --graph --oneline --decorate --all --since="2 weeks ago"
```

Комментарии:

```bash
git log --graph --oneline --decorate --all --since="2 weeks ago"
# --graph - показывает дерево ветвлений в виде текстового графа
# --oneline - компактный формат коммитов
# --decorate - подписывает ветки и теги
# --all - учитывать все ветки
# --since="2 weeks ago" - только последние две недели
```

Вы получаете дерево последних изменений по всем веткам и понимаете, где происходило активное развитие.

## Заключение

Команда git log — это гибкий и мощный инструмент для анализа истории изменений в репозитории. Вы можете начинать с простого вывода коммитов и постепенно добавлять:

- форматирование (через --oneline, --pretty=format);
- визуализацию графа веток (--graph, --decorate, --all);
- фильтрацию по автору, дате, сообщениям и файлам (--author, --since, --until, --grep, указание путей);
- просмотр диффов и статистики (-p, --stat, --name-only);
- диапазоны между ветками и тегами (A..B, A...B).

Чем лучше вы освоите git log, тем быстрее сможете находить нужные изменения, понимать структуру истории и разбираться в причинах багов. Важно не бояться комбинировать опции и постепенно выработать свои «любимые» команды, которые вы используете каждый день, а затем оформить их в алиасы.

## Частозадаваемые технические вопросы по теме и ответы

### Вопрос 1. Как вывести только коммиты, которые меняли определенные строки в файле?

Используйте комбинацию git log и git blame. Сначала найдите интересующие строки через git blame:

```bash
git blame -L 100,120 path/to/file.go
# -L 100,120 - диапазон строк 100-120
```

В выводе будут хеши коммитов, которые меняли эти строки. Затем для конкретного хеша можно посмотреть детали:

```bash
git show <hash>
```

Так вы видите историю именно нужного участка кода.

### Вопрос 2. Как исключить из истории коммиты с определенным словом в сообщении?

Используйте отрицательный поиск через --grep вместе с --invert-grep:

```bash
git log --grep="WIP" --invert-grep --oneline
```

Здесь в вывод не попадут коммиты, в сообщении которых есть WIP.

### Вопрос 3. Как показать только merge-коммиты или только обычные коммиты?

Для просмотра только merge-коммитов:

```bash
git log --merges --oneline
```

Для вывода обычных коммитов (не merge):

```bash
git log --no-merges --oneline
```

### Вопрос 4. Как посмотреть историю только по удаленным веткам?

Сначала убедитесь, что у вас обновлены ссылки на удаленные ветки:

```bash
git fetch --all --prune
```

Затем можно вывести историю по удаленным веткам:

```bash
git log --oneline --decorate --graph --remotes
```

Опция --remotes показывает только удаленные ветки.

### Вопрос 5. Как ограничить вывод git log шириной терминала или убрать постраничный просмотр?

По умолчанию Git может использовать пейджер (less). Чтобы отключить его и вывести все сразу:

```bash
git --no-pager log --oneline
```

Если вы хотите навсегда отключить пейджер для логов:

```bash
git config --global pager.log false
```

Теперь git log будет выводить историю без постраничной навигации.