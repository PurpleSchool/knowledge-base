---
metaTitle: Сегмент types - глубокий разбор types-segment в системах типизации
metaDescription: Разбор сегмента types - types-segment в системах типизации и сериализации данных - структура сегмента принципы работы и практические примеры
author: Олег Марков
title: Сегмент types - подробное руководство по types-segment для разработчиков
preview: Изучите сегмент types - types-segment - как он устроен какие задачи решает и как работать с ним на практике при описании и передаче типизированных данных
---

## Введение

Сегмент types (часто его называют types-segment) — это логический блок описания типов данных в бинарных или текстовых протоколах, форматах сериализации и внутренних метамоделях приложений. Его задача — собрать в одном месте информацию о том, **какие типы** вообще существуют в системе, из чего они состоят и как их можно однозначно интерпретировать при чтении или исполнении.

Смотрите, я сейчас буду опираться на обобщенную модель, которую вы можете встретить:

- в бинарных протоколах с явным описанием схемы;
- во внутренних форматах хранения метаданных (например, в системах плагинов);
- в движках, которые загружают описания сущностей и полей из внешних файлов.

Под названием types-segment часто понимают одинаковый по сути элемент структуры:

- отдельный блок в файле или потоке данных, в котором собраны объявления типов;
- таблица или массив описателей типов;
- набор записей, каждая из которых описывает один тип (структуру, перечисление, примитив и т.д.).

Давайте разбираться, как такой сегмент обычно устроен, какие задачи решает и как с ним можно работать в коде.

---

## Общая концепция сегмента types-segment

### Что такое сегмент типов

Сегмент типов — это:

- **Список всех типов**, которые может встретить парсер или рантайм в этом файле/модуле/потоке;
- **Справочник по идентификаторам типов**, чтобы по компактному ID можно было восстановить полное описание;
- **Связующее звено** между «сырыми» данными и их смыслом (поле номер 3 — это, например, `User`, а поле `age` — `int32`).

Обычно сегмент типов:

- располагается в **начале** или **в конце** файла;
- содержит **таблицу записей**, каждая запись описывает один тип;
- используется всеми остальными сегментами, которые ссылаются на типы по числовым ID или индексам.

### Задачи, которые решает types-segment

Смотрите, я перечислю ключевые задачи:

1. **Компактность**  
   Вместо того чтобы в каждом месте повторять полное имя типа и описания полей, форматы используют ссылку на тип по ID. Это уменьшает размер данных.

2. **Однозначность**  
   Описание типов хранится централизованно, поэтому двусмысленностей меньше: у конкретного ID всегда одна и та же структура.

3. **Расширяемость**  
   Можно добавлять новые типы, не меняя формат для старых данных, если соблюдать правила обратной совместимости.

4. **Возможность рефлексии**  
   Программа может «посмотреть» на сегмент типов и узнать, какие типы поддерживает файл, какие у них поля, какие типы у полей. Это особенно полезно в генераторах кода и при динамической работе с данными.

5. **Кросс-языковая совместимость**  
   Если схема описана один раз, по ней можно генерировать код на разных языках. А сам файл будет ссылаться только на ID типов.

---

## Типичная структура types-segment

Давайте смоделируем типичную структуру. Условный бинарный формат может содержать:

- заголовок файла;
- сегмент типов (types-segment);
- сегменты данных, которые ссылаются на типы.

### Высокоуровневая модель сегмента

Сегмент типов можно представить как массив записей:

- `typesCount` — количество типов;
- `types[]` — массив описаний типов.

Каждый тип обычно содержит:

- `TypeID` — числовой идентификатор типа;
- `Kind` — вид типа (struct, enum, alias, array и т.д.);
- `Name` — строковое имя типа;
- опциональные метаданные (версия, флаги, атрибуты);
- описание внутренней структуры (поля для struct, варианты для enum и т.д.).

Теперь вы увидите, как это выглядит в псевдоструктуре на примере, близком к Go-коду.

```go
// TypeKind описывает вид типа в сегменте types.
type TypeKind uint8

const (
    TypeKindPrimitive TypeKind = iota // Примитивный тип (int, string и т.п.)
    TypeKindStruct                    // Структура
    TypeKindEnum                      // Перечисление
    TypeKindArray                     // Массив фиксированной длины
    TypeKindSlice                     // Массив переменной длины
    TypeKindAlias                     // Псевдоним другого типа
)

// TypeDescriptor - единичная запись в types-segment.
type TypeDescriptor struct {
    ID       uint32    // Уникальный ID типа в рамках файла
    Kind     TypeKind  // Вид типа
    Name     string    // Имя типа, например "User"
    Version  uint16    // Версия описания типа
    Flags    uint16    // Битовые флаги особенностей
    Payload  any       // Дополнительные данные (поля, варианты enum и т.д.)
}
```

Комментарии в этом фрагменте показывают, как именно каждая часть записи отвечает за идентификацию и детализацию типа.

### Варианты payload для разных видов типов

Обычно `Payload` зависит от `Kind`. Давайте разберемся на примере нескольких часто встречающихся видов типов.

#### Структура (struct)

Для структуры нам нужно хранить список полей:

```go
// FieldDescriptor описывает одно поле в структуре.
type FieldDescriptor struct {
    Name       string // Имя поля, например "age"
    TypeID     uint32 // Ссылка на другой тип по ID
    Tag        string // Доп. атрибуты, например "json:age"
    IsOptional bool   // Может ли поле отсутствовать
    Offset     uint32 // Смещение в бинарном представлении (опционально)
}

// StructPayload - payload для типов вида Struct.
type StructPayload struct {
    Fields []FieldDescriptor // Поля структуры
}
```

Здесь я размещаю пример, чтобы вам было проще понять: каждое поле структуры не повторяет описание типа целиком, оно лишь ссылается на `TypeID`, который описан где-то в том же сегменте.

#### Перечисление (enum)

Для перечислений нужны варианты:

```go
// EnumVariant описывает одну константу перечисления.
type EnumVariant struct {
    Name  string // Имя константы, например "StatusActive"
    Value int64  // Значение, которое записывается в данные
}

// EnumPayload - payload для Enum.
type EnumPayload struct {
    BaseTypeID uint32        // На каком примитиве основан enum, например uint8
    Variants   []EnumVariant // Набор допустимых значений
}
```

#### Массивы и срезы

Массивы и срезы всегда ссылаются на тип элемента:

```go
// ArrayPayload - payload для массивов и срезов.
type ArrayPayload struct {
    ElemTypeID uint32 // Тип элемента
    Length     uint32 // Длина (для фиксированных массивов), 0 для среза
}
```

---

## Как сегмент types связывается с другими сегментами

### Идентификаторы типов

Главный механизм — это **идентификаторы типов**. В сегменте типов хранятся:

- `TypeID = 1` — `int32`
- `TypeID = 2` — `string`
- `TypeID = 3` — `User`
- `TypeID = 4` — `[]User` и т.д.

Во всех остальных сегментах эти ID используются вместо полного описания типа.

Давайте посмотрим, как это может использоваться в сегменте данных:

```go
// DataRecord - условная запись в сегменте данных.
type DataRecord struct {
    TypeID uint32 // Какой тип описывает payload
    Data   []byte // Сырые байты объекта
}
```

Когда вы читаете такой файл, порядок действий обычно такой:

1. Сначала читаете types-segment и строите в памяти карту:
   - ключ — `TypeID`;
   - значение — `TypeDescriptor`.
2. Потом читаете сегмент данных, видите `TypeID = 3`.
3. Находите описатель `TypeDescriptor{ID:3, Name:"User", Kind:Struct, ...}`.
4. На основании этого описания декодируете `Data` в нужную структуру.

---

## Пример: объявление сегмента types и использование в коде

Давайте разберемся на конкретном примере. Представим простую схему:

- Примитивы: `int32`, `string`;
- Структура `User` с полями:
  - `id` (int32)
  - `name` (string);
- Массив `[]User`.

### Описание типов в виде types-segment

Смотрите, я покажу вам, как можно смоделировать types-segment в Go-коде для такой схемы.

```go
// Предположим, у нас уже есть ID для примитивных типов.
const (
    TypeIDInt32  uint32 = 1
    TypeIDString uint32 = 2
)

const (
    TypeIDUser     uint32 = 3
    TypeIDUserList uint32 = 4
)

// Соберём types-segment в памяти.
func buildTypesSegment() []TypeDescriptor {
    // Описание типа User - структура с полями id и name.
    userType := TypeDescriptor{
        ID:   TypeIDUser,
        Kind: TypeKindStruct,
        Name: "User",
        Payload: StructPayload{
            Fields: []FieldDescriptor{
                {
                    Name:       "id",
                    TypeID:     TypeIDInt32, // cсылаемся на примитивный тип int32
                    Tag:        "json:id",
                    IsOptional: false,
                    Offset:     0,          // в бинарном формате поле идёт первым
                },
                {
                    Name:       "name",
                    TypeID:     TypeIDString, // cсылаемся на string
                    Tag:        "json:name",
                    IsOptional: false,
                    Offset:     4,           // предположим, что id занимает 4 байта
                },
            },
        },
    }

    // Описание типа []User - список пользователей.
    userListType := TypeDescriptor{
        ID:   TypeIDUserList,
        Kind: TypeKindSlice,
        Name: "[]User",
        Payload: ArrayPayload{
            ElemTypeID: TypeIDUser, // элемент списка - User
            Length:     0,          // 0 обозначает срез, а не фиксированный массив
        },
    }

    // Возвратим массив всех типов.
    return []TypeDescriptor{
        {
            ID:   TypeIDInt32,
            Kind: TypeKindPrimitive,
            Name: "int32",
        },
        {
            ID:   TypeIDString,
            Kind: TypeKindPrimitive,
            Name: "string",
        },
        userType,
        userListType,
    }
}
```

Как видите, этот код просто имитирует то, что обычно лежит в файле внутри types-segment: набор записей, связанных ссылками по ID.

---

## Чтение файла с types-segment и последующая декодировка

Теперь давайте перейдем к следующему шагу — как это использовать при чтении данных.

### Шаг 1. Построить индекс по TypeID

Обычно при чтении файла первым делом строят карту из `TypeID` в дескриптор типа. Это ускоряет поиск и упрощает последующую работу.

```go
// buildTypesIndex строит карту ID -> TypeDescriptor.
func buildTypesIndex(types []TypeDescriptor) map[uint32]TypeDescriptor {
    index := make(map[uint32]TypeDescriptor, len(types))
    for _, t := range types {
        // Здесь мы просто кладём дескриптор в карту,
        // предполагая, что ID уникален.
        index[t.ID] = t
    }
    return index
}
```

Смотрите, этот шаг кажется простым, но без него каждый раз пришлось бы проходить массив типов линейно.

### Шаг 2. Декодирование записей данных по TypeID

Теперь вы увидите, как это выглядит в коде: у нас есть `DataRecord`, и мы хотим декодировать `Data` в структуру `User`.

Для примера предположим такое бинарное представление:

- поле `id` (`int32`) — 4 байта, little-endian;
- поле `name` (`string`) — сначала `uint16` длины, затем байты UTF-8 строки.

```go
import (
    "encoding/binary"
    "fmt"
)

// User - целевая структура в приложении.
type User struct {
    ID   int32
    Name string
}

// decodeUser декодирует один объект типа User из байтов.
func decodeUser(data []byte) (User, error) {
    var u User

    // Проверяем, что данных хотя бы хватает на id и длину строки.
    if len(data) < 6 {
        return u, fmt.Errorf("data too short for User")
    }

    // Читаем id как int32.
    // binary.LittleEndian.Uint32 читает 4 байта и возвращает uint32,
    // затем мы приводим к int32.
    u.ID = int32(binary.LittleEndian.Uint32(data[0:4]))

    // Читаем длину строки name как uint16.
    nameLen := binary.LittleEndian.Uint16(data[4:6])

    // Проверяем, хватает ли байт на строку.
    if len(data) < int(6+nameLen) {
        return u, fmt.Errorf("data too short for name")
    }

    // Вырезаем подстроку нужной длины и конвертируем в string.
    nameBytes := data[6 : 6+nameLen]
    u.Name = string(nameBytes)

    return u, nil
}
```

Обратите внимание, как этот фрагмент кода решает задачу:

- схема (через types-segment) говорит, какие поля есть у `User` и в каком порядке они идут;
- на основе этой информации мы реализуем конкретный декодер.

В реальных системах такой декодер часто генерируется автоматически по types-segment, а не пишется вручную.

---

## Версионирование типов в types-segment

### Зачем нужен номер версии

В сегменте типов часто есть поле `Version`. Оно позволяет:

- изменять описание типа без «ломания» старых данных;
- поддерживать одновременное существование нескольких версий одного типа;
- постепенно мигрировать клиентов.

Например, вы можете завести следующую схему:

- `User v1` — поля `id`, `name`;
- `User v2` — поля `id`, `name`, `email`.

В файле types-segment при этом могут быть две записи с разными `Version`.

```go
userV1 := TypeDescriptor{
    ID:      10,
    Kind:    TypeKindStruct,
    Name:    "User",
    Version: 1,
    Payload: StructPayload{
        Fields: []FieldDescriptor{
            {Name: "id",   TypeID: TypeIDInt32},
            {Name: "name", TypeID: TypeIDString},
        },
    },
}

userV2 := TypeDescriptor{
    ID:      11,
    Kind:    TypeKindStruct,
    Name:    "User",
    Version: 2,
    Payload: StructPayload{
        Fields: []FieldDescriptor{
            {Name: "id",    TypeID: TypeIDInt32},
            {Name: "name",  TypeID: TypeIDString},
            {Name: "email", TypeID: TypeIDString},
        },
    },
}
```

Смотрите, файловый формат сам по себе не обязывает вас использовать только одну версию. Встречаются схемы, где в одном файле лежат данные разных версий, и это нормально, если рантайм способен с этим работать.

### Как обрабатывать разные версии

Обычно есть два варианта:

1. **Миграция при чтении**  
   При чтении объекта вы определяете, к какой версии относится тип (`Version`), и:
   - декодируете по старому описанию;
   - преобразуете в актуальную структуру в памяти (например, заполняете `email` пустой строкой).

2. **Поддержка нескольких версий в модели**  
   В коде существует несколько вариантов структуры, и рантайм выбирает нужную в зависимости от версии:

```go
// UserV1 - старая версия структуры.
type UserV1 struct {
    ID   int32
    Name string
}

// UserV2 - новая версия с добавленным email.
type UserV2 struct {
    ID    int32
    Name  string
    Email string
}
```

Часто используется гибридный подход: есть отдельные структуры для старых версий и актуальная бизнес-модель, в которую всё приводится после чтения.

---

## Связи между типами внутри types-segment

### Граф типов

Сегмент типов, по сути, — это **граф**: одни типы ссылаются на другие. Например:

- `User` ссылается на `string`, `int32`;
- `[]User` ссылается на `User`;
- `Order` ссылается на `User` и `OrderStatus` (enum).

При работе с таким графом иногда нужны операции:

- проверить, есть ли циклы;
- найти все типы, достижимые от корневого типа;
- удалить неиспользуемые типы (garbage collection типов).

### Проверка на циклы

Давайте разберемся на примере, как можно проверить наличие циклов в графе типов.  
Для простоты предположим:

- циклы разрешены только для ссылочных типов (например, через указатель);
- в нашем примере будем считать, что `FieldDescriptor` имеет флаг `IsPointer`.

```go
// isCyclic проверяет, есть ли циклические ссылки между типами.
// Здесь мы используем простой обход в глубину (DFS).
func isCyclic(
    typeID uint32,
    typesIndex map[uint32]TypeDescriptor,
    visiting map[uint32]bool,
    visited map[uint32]bool,
) bool {
    // Если тип уже полностью обработан - цикла нет.
    if visited[typeID] {
        return false
    }
    // Если мы снова попали в уже посещаемый в цепочке тип - цикл найден.
    if visiting[typeID] {
        return true
    }

    visiting[typeID] = true
    td := typesIndex[typeID]

    switch td.Kind {
    case TypeKindStruct:
        payload := td.Payload.(StructPayload)
        for _, f := range payload.Fields {
            // Для простоты считаем, что любые ссылки могут быть частью цикла.
            if isCyclic(f.TypeID, typesIndex, visiting, visited) {
                return true
            }
        }
    case TypeKindArray, TypeKindSlice:
        payload := td.Payload.(ArrayPayload)
        if isCyclic(payload.ElemTypeID, typesIndex, visiting, visited) {
            return true
        }
    // Для примитивов и enum цикл невозможен.
    }

    visiting[typeID] = false
    visited[typeID] = true
    return false
}
```

Смотрите, здесь важно:

- `visiting` хранит типы в текущем стеке вызовов;
- если мы снова попали в `typeID`, который уже находится в `visiting`, есть цикл.

---

## Оптимизация хранения и чтения types-segment

### Индексация по имени и по ID

Часто нужно быстро находить тип не только по ID, но и по имени. В этом случае полезно строить две карты:

```go
type TypesIndex struct {
    ByID   map[uint32]TypeDescriptor
    ByName map[string]TypeDescriptor
}

func buildFullTypesIndex(types []TypeDescriptor) TypesIndex {
    idx := TypesIndex{
        ByID:   make(map[uint32]TypeDescriptor, len(types)),
        ByName: make(map[string]TypeDescriptor, len(types)),
    }
    for _, t := range types {
        idx.ByID[t.ID] = t
        // Если есть несколько версий с одинаковым именем,
        // по имени можно хранить самую «актуальную» по какому-то правилу.
        if _, ok := idx.ByName[t.Name]; !ok || idx.ByName[t.Name].Version < t.Version {
            idx.ByName[t.Name] = t
        }
    }
    return idx
}
```

Теперь вы можете:

- быстро находить тип по ID при декодировании;
- быстро находить тип по имени при генерации кода или логике высокого уровня.

### Минимизация дублирования

Чтобы сегмент типов оставался компактным, часто применяют:

- **таблицу строк**: имена типов и полей выносятся в отдельный пул строк, а в types-segment хранятся только индексы;
- **таблицу примитивов**: вместо многократного дублирования описаний примитивных типов используется фиксированный набор ID.

Пример с пулом строк можно представить так:

```go
// StringPool - условная структура пула строк.
type StringPool struct {
    Items []string          // Массив уникальных строк
    Index map[string]uint32 // Обратная карта строка -> индекс
}

// getOrAdd возвращает индекс строки, добавляя её при необходимости.
func (p *StringPool) getOrAdd(s string) uint32 {
    if idx, ok := p.Index[s]; ok {
        return idx
    }
    idx := uint32(len(p.Items))
    p.Items = append(p.Items, s)
    if p.Index == nil {
        p.Index = make(map[string]uint32)
    }
    p.Index[s] = idx
    return idx
}
```

В таком подходе `FieldDescriptor` вместо `Name string` может содержать `NameIndex uint32`. Это уменьшает размер types-segment при большом числе однотипных имен.

---

## Проверка согласованности types-segment

### Валидация ссылок

После чтения types-segment полезно выполнить базовую проверку:

- все `TypeID`, на которые ссылаются поля и массивы, действительно описаны;
- нет дубликатов ID;
- нет конфликтов имен и версий по вашим внутренним правилам.

Вот пример простой валидации ссылок:

```go
// validateTypesSegment проверяет, что все ссылки на типы корректны.
func validateTypesSegment(types []TypeDescriptor) error {
    index := buildTypesIndex(types)

    // Проверка уникальности ID.
    if len(index) != len(types) {
        return fmt.Errorf("duplicate TypeID detected")
    }

    for _, td := range types {
        switch td.Kind {
        case TypeKindStruct:
            payload := td.Payload.(StructPayload)
            for _, f := range payload.Fields {
                if _, ok := index[f.TypeID]; !ok {
                    return fmt.Errorf("type %s refers to unknown TypeID %d",
                        td.Name, f.TypeID)
                }
            }
        case TypeKindArray, TypeKindSlice:
            payload := td.Payload.(ArrayPayload)
            if _, ok := index[payload.ElemTypeID]; !ok {
                return fmt.Errorf("array type %s refers to unknown elem TypeID %d",
                    td.Name, payload.ElemTypeID)
            }
        case TypeKindEnum:
            // Обычно enum ссылается только на базовый примитивный тип.
            payload := td.Payload.(EnumPayload)
            if _, ok := index[payload.BaseTypeID]; !ok {
                return fmt.Errorf("enum %s refers to unknown base TypeID %d",
                    td.Name, payload.BaseTypeID)
            }
        }
    }

    return nil
}
```

Смотрите, такая проверка помогает поймать ошибки в генераторе types-segment или в ручном описании схемы еще до того, как начнется работа с реальными данными.

---

## Практические советы по проектированию types-segment

### 1. Стабильные TypeID

Очень важно, чтобы `TypeID` были **стабильными во времени**. Если вы:

- перегенерируете types-segment;
- и при этом меняете `TypeID` без крайней необходимости,

то старые клиенты, ожидающие, что «3 — это User», будут ошибаться.

Рекомендуется:

- либо жёстко фиксировать `TypeID` в схеме;
- либо использовать явный реестр типов, где каждому имени навсегда соответствует ID.

### 2. Явное описание примитивов

Даже если кажется, что примитивы очевидны, лучше:

- явно завести дескрипторы для `int32`, `string` и т.п.;
- или хотя бы иметь заранее согласованный список их ID.

Это особенно важно, если:

- протокол нужно реализовать на нескольких языках;
- вы хотите использовать рефлексию и динамическую обработку.

### 3. Разумное использование версий

Не стоит создавать новую версию типа при каждом незначительном изменении. Обычно версию повышают, если:

- добавилось поле, которое не является опциональным;
- изменился тип существующего поля;
- изменился смысл поля (например, единицы измерения).

При этом старайтесь:

- не переиспользовать ID для нового типа;
- не менять задним числом определение старой версии.

### 4. Документация на уровне сегмента

Помимо чисто технических полей иногда полезно добавлять:

- комментарии к типам;
- комментарии к полям;
- метаданные для генераторов кода.

Можно хранить это в отдельном блоке, связанном с types-segment, или в самом `Payload` через дополнительные поля. Это упростит сопровождение схемы в долгосрочной перспективе.

### 5. Генерация кода из types-segment

Смотрите, именно сегмент типов чаще всего становится источником для генерации кода:

- структур данных;
- декодеров и энкодеров;
- вспомогательных утилит (валидаторов, конвертеров).

Типичный процесс:

1. Загружаем types-segment;
2. Строим индекс типов;
3. Проходим по всем `TypeDescriptor` и для каждого:
   - генерируем структуру или enum на целевом языке;
   - генерируем функции сериализации/десериализации;
   - пишем вспомогательный код.

Такой подход снижает количество ручного кода и синхронизационных ошибок между схемой и реализацией.

---

## Заключение

Сегмент types (types-segment) — это фундаментальный элемент многих форматов и протоколов, который определяет, **какие типы данных вообще существуют** и как с ними работать. Без него данные остаются просто последовательностью байтов или полей без чёткого смысла.

Вы рассмотрели:

- общую структуру types-segment и типичную модель `TypeDescriptor`;
- примеры описания структур, перечислений, массивов и срезов;
- механизм связки типов с сегментами данных через `TypeID`;
- основы версионирования типов и обработки разных версий;
- проверку согласованности и поиск циклов в графе типов;
- практические рекомендации по проектированию и использованию types-segment.

Ключевая мысль: хорошо спроектированный сегмент типов делает протокол:

- компактным;
- однозначным;
- расширяемым;
- удобным для генерации кода и инструментов.

Если вы проектируете собственный формат или протокол, логично начинать именно с продуманной структуры types-segment, а уже затем накладывать на него конкретное бинарное или текстовое представление.

---

## Частозадаваемые технические вопросы по теме и ответы

### Как хранить ссылки на типы между разными файлами с types-segment

Если один файл должен ссылаться на тип из другого файла, одного `TypeID` недостаточно, так как ID локальны. Используйте составной идентификатор:

- `Namespace` или `ModuleID` файла (например, хеш схемы или имя пакета);
- `TypeID` внутри этого модуля.

При чтении:

1. сначала регистрируете все модули и их types-segment в общем реестре;
2. при ссылке `ModuleID + TypeID` ищете нужный тип в соответствующем модуле.

### Как реализовать обратную совместимость при удалении поля из структуры

Удалённые поля не следует стирать из схемы задним числом. Вместо этого:

1. объявляете новое описание типа с увеличенной версией, где поле отсутствует;
2. при чтении старых данных заполняете «удалённое» поле значением по умолчанию или просто игнорируете его при маппинге в актуальную модель;
3. в коде декодера для старой версии просто не используете это поле дальше по цепочке.

### Можно ли динамически добавлять новые типы в types-segment на лету

Да, если формат и рантайм это поддерживают. Процесс обычно такой:

1. читаете существующий types-segment;
2. добавляете новые `TypeDescriptor` в конец списка, не меняя существующие ID;
3. обновляете индекс по ID и имени;
4. добавляете новый сегмент данных, который ссылается на новые типы.

Важно следить, чтобы старые клиенты, которые не знают о новых типах, либо не читали эти данные, либо корректно их пропускали.

### Как хранить generic-типы в types-segment

Обычно generic-типы «разворачивают» в конкретные инстансы:

- `List<User>` получает собственный `TypeID`;
- для instantiation указывают базовый generic-тип и список аргументов.

В `Payload` можно хранить:

- ссылку на generic-шаблон (`GenericBaseTypeID`);
- список `TypeID` параметров.  
Генераторы кода затем создают конкретные структуры или алиасы под каждый инстанс.

### Как тестировать корректность types-segment

Полезно иметь отдельный набор тестов, который:

1. загружает эталонный types-segment;
2. прогоняет валидацию ссылок и поиск циклов;
3. генерирует код по этому сегменту;
4. сериализует и десериализует тестовые объекты;
5. сравнивает результаты с ожидаемыми структурами.  

Такой контур тестов помогает поймать ошибки в схеме, генераторе и рантайме до выката в прод.