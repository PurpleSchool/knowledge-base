---
metaTitle: Слой widgets в архитектуре фронтенда widgets-layer
metaDescription: Разбираем что такое слой widgets в архитектуре приложений widgets-layer - принципы структуры примеры кода и практические рекомендации по организации интерфейсных виджетов
author: Олег Марков
title: Слой widgets - widgets-layer в архитектуре фронтенда
preview: Подробно разбираем слой widgets в архитектуре widgets-layer - назначение структура примеры кода и лучшие практики использования в реальных проектах
---

## Введение

Слой widgets (widgets-layer) обычно появляется в архитектурах типа Feature-Sliced Design или близких к нему подходах, где фронтенд делится на уровни ответственности. Смотрите, мы сейчас шаг за шагом разберем, зачем нужен этот слой, чем он отличается от других уровней, как правильно его организовать и как не превратить его в "свалку компонентов".

Если говорить просто, widgets — это слой интеграции. На нем вы собираете готовые пользовательские блоки из более низкоуровневых сущностей: страниц, фич, сущностей и базовых компонентов. Эти блоки уже можно переиспользовать в разных частях приложения, но они еще не тянут на полноценные страницы.

Чтобы работать со слоем widgets уверенно, важно понимать:

- какую ответственность он на себя берет;
- из чего можно и из чего нельзя собирать виджеты;
- как правильно структурировать файлы и модули;
- как оформлять публичный API виджета;
- какие зависимости ему разрешены, а какие нет.

Об этом и будет статья.  

---

## Что такое слой widgets в архитектуре

### Общая идея слоя widgets

Слой widgets отвечает за готовые фрагменты интерфейса, которые:

- состоят из нескольких фич, сущностей и компонентов;
- сами по себе не являются страницами;
- могут использоваться на разных страницах;
- обладают своей внутренней логикой и состоянием.

Давайте разберем пример. Представьте виджет "UserProfileCard":

- он может показываться на странице профиля пользователя;
- он может показываться в боковой панели;
- он может использовать разные фичи (например, кнопку "Подписаться" или "Отправить сообщение");
- он может комбинировать данные из нескольких сущностей (user, stats, achievements).

То есть "UserProfileCard" — это типичный виджет. Он уже не простая "кнопка" или "карточка", но и не полноценная страница.

### Место widgets-layer в общей архитектуре

Если описать архитектуру сверху вниз, то схема часто выглядит так:

- app — инициализация приложения, роутинг, глобальные провайдеры;
- processes — долгоживущие бизнес-процессы (например, онбординг);
- pages — страницы, завязанные на роуты;
- widgets — повторно используемые интерфейсные блоки;
- features — оформленные пользовательские сценарии (actions, flows);
- entities — бизнес-сущности (User, Product, Cart);
- shared — базовые, переиспользуемые вещи (UI-kit, хелперы и тд).

Здесь widgets занимают место между pages и features:

- pages собирают целую страницу (layout, SEO, data fetching уровня страницы);
- widgets собирают куски интерфейса, которые одна страница может использовать несколько раз, а другая — тоже может переиспользовать;
- features отвечают за конкретные действия пользователя ("добавить в корзину", "подписаться", "отправить форму").

Как видите, виджеты — это составные интерфейсные элементы, которые помогают не дублировать один и тот же "кусок страницы" в разных местах.

---

## Основная ответственность и границы widgets-layer

### Основные задачи widgets

Слой widgets решает несколько ключевых задач:

1. **Инкапсуляция сложной UI-композиции**  
   Вы объединяете несколько фич и сущностей в один логичный блок с понятным API. Снаружи остается только один компонент и его пропсы.

2. **Повторное использование фрагментов интерфейса**  
   Один и тот же виджет можно использовать:
   - на разных страницах;
   - в разных процессах;
   - в разных контекстах (например, embed-версия на стороннем сайте).

3. **Упрощение кода страниц**  
   Страница не должна знать о том, как устроен сложный блок. Она просто подключает несколько виджетов и размещает их.

4. **Локализация логики отображения**  
   Весь "решающий" код, какой фиче где отображаться, остается внутри виджета. Страница только передает данные и настройки.

### Что не должен делать слой widgets

Чтобы не размазать ответственность, важно понимать, чего в widgets быть не должно:

- **Не реализовать бизнес-логику домена с нуля**  
  Логика домена и сценариев должна быть во `features` и `entities`. Виджет ее только комбинирует.

- **Не ходить напрямую в API "как попало"**  
  Если вы по архитектуре загружаете данные через слои entities/features/pages — продолжайте это делать. Виджет не должен сам изобретать новый способ.

- **Не становиться копией pages**  
  Виджет не должен повторять страницу. Если у вас виджет размером почти как страница — возможно, это должна быть отдельная страница или процесс.

- **Не зависеть от слоев выше**  
  Виджет не должен тянуть зависимости из `pages`, `processes` или `app`. Это нарушает направленность зависимостей.

---

## Структура проекта и расположение widgets

### Базовая структура слоя widgets

Обычно слой widgets располагается в отдельной директории на верхнем уровне проекта. Например:

- src  
  - app  
  - pages  
  - widgets  
    - user-profile  
    - cart-summary  
    - sidebar-menu  
  - features  
  - entities  
  - shared  

Каждый виджет — это отдельный модуль в папке `widgets`, со своим:

- корневым компонентом;
- внутренними подкомпонентами;
- стилями;
- тестами;
- типами;
- утилитами (если они нужны только внутри этого виджета).

Пример структуры одного виджета:

- widgets  
  - user-profile  
    - ui  
      - UserProfile.tsx  
      - AvatarWithStatus.tsx  
    - model  
      - hooks.ts  
      - selectors.ts  
    - lib  
      - formatters.ts  
    - index.ts  

Здесь главное — разделить:

- публичный API всего виджета (обычно в index.ts);
- внутренние детали реализации (ui, model, lib).

### Публичный API виджета

Публичный API обычно сводится к экспорту одного или нескольких компонентов и типов, которые можно использовать на страницах или в других виджетах.

Например, index.ts может выглядеть так:

```ts
// widgets/user-profile/index.ts

// Экспортируем главный виджет
export { UserProfile } from './ui/UserProfile'

// Экспортируем типы пропсов, чтобы страница могла их типизировать
export type { UserProfileProps } from './ui/UserProfile'
```

Внешний код будет использовать только этот файл, не залезая в структуру внутри:

```ts
// pages/profile/ui/ProfilePage.tsx

import { UserProfile } from 'widgets/user-profile'

export const ProfilePage = () => {
  // Здесь мы просто используем виджет
  return (
    <div>
      {/* Виджет "профиль пользователя" */}
      <UserProfile userId="123" />
    </div>
  )
}
```

Такой подход помогает при рефакторинге: если вы меняете внутреннюю структуру виджета, другие слои не пострадают, пока вы сохраняете публичный API.

---

## Разрешенные и запрещенные зависимости для widgets-layer

### Разрешенные зависимости

Слой widgets может зависеть от:

- `features` — для подключения сценариев (кнопки действий, формы и тд);
- `entities` — для работы с бизнес-сущностями (User, Product, Order);
- `shared` — для UI-компонентов, утилит, хелперов, API-клиентов;
- других `widgets` — но здесь нужно быть осторожным, чтобы не создать циклические зависимости.

Смотрите, как это может выглядеть в коде:

```ts
// widgets/cart-summary/ui/CartSummary.tsx

import { Cart } from 'entities/cart'
import { CheckoutButton } from 'features/checkout'
import { Card, Text } from 'shared/ui'

// Здесь виджет собирает сущность Cart, фичу CheckoutButton и базовые компоненты Card, Text
```

### Запрещенные зависимости

Виджет не должен зависеть от:

- `pages` — страница может использовать виджет, но не наоборот;
- `processes` — длительные процессы не должны быть внутри виджета;
- `app` — глобальная инициализация, роутинг и провайдеры не должны импортироваться в виджете напрямую (кроме строго обусловленных случаев, например, `useTranslation` из глобального провайдера, но и это часто выносится в shared).

Если вам вдруг хочется импортировать что-то из pages в виджет — это явный сигнал, что архитектура "ломается". Лучше подумать, не стоит ли вынести нужный код на слой ниже (в widgets, features или entities).

---

## Примеры реализации виджетов

### Простой виджет на основе сущности

Давайте начнем с базового примера. Виджет "UserProfile" показывает карточку пользователя и статистику.

```tsx
// widgets/user-profile/ui/UserProfile.tsx

import { FC } from 'react'
import { UserCard, useUser } from 'entities/user'
import { Card, Spinner } from 'shared/ui'

// Описываем пропсы виджета
export type UserProfileProps = {
  userId: string // Идентификатор пользователя
}

export const UserProfile: FC<UserProfileProps> = ({ userId }) => {
  // Здесь мы используем хук из слоя entities
  const { data: user, isLoading } = useUser(userId)

  // Пока данные грузятся - показываем спиннер
  if (isLoading) {
    return (
      <Card>
        {/* Компонент загрузки из shared */}
        <Spinner />
      </Card>
    )
  }

  // Если пользователя нет - можно вернуть null или заглушку
  if (!user) {
    return (
      <Card>
        {/* Здесь мы показываем сообщение об отсутствии данных */}
        Пользователь не найден
      </Card>
    )
  }

  // Когда данные загружены - показываем карточку пользователя
  return (
    <Card>
      {/* UserCard - компонент сущности User */}
      <UserCard user={user} />
    </Card>
  )
}
```

Комментарии к коду:

- Виджет принимает только `userId`;
- сам обращается к слою `entities` через `useUser`;
- использует компонент `UserCard` из `entities/user`;
- использует общий UI-компонент `Card` из `shared/ui`.

Такой виджет можно переиспользовать где угодно, где нужен профиль пользователя.

### Виджет, который собирает несколько фич

Теперь давайте посмотрим пример посложнее. Виджет "ProductDetails" может:

- показывать данные товара;
- позволять добавить в корзину;
- позволять добавить товар в избранное.

```tsx
// widgets/product-details/ui/ProductDetails.tsx

import { FC } from 'react'
import { ProductCard, useProduct } from 'entities/product'
import { AddToCartButton } from 'features/cart/add-to-cart'
import { ToggleFavoriteButton } from 'features/favorites/toggle-favorite'
import { Card, Spinner, Stack } from 'shared/ui'

type ProductDetailsProps = {
  productId: string
}

export const ProductDetails: FC<ProductDetailsProps> = ({ productId }) => {
  // Получаем данные товара из слоя entities
  const { data: product, isLoading } = useProduct(productId)

  if (isLoading) {
    return (
      <Card>
        <Spinner />
      </Card>
    )
  }

  if (!product) {
    return (
      <Card>
        Товар не найден
      </Card>
    )
  }

  return (
    <Card>
      {/* Stack - это просто layout-компонент для вертикального расположения */}
      <Stack direction="column" gap={16}>
        {/* Отображаем основную информацию о товаре */}
        <ProductCard product={product} />

        {/* Блок действий с товаром */}
        <Stack direction="row" gap={8}>
          {/* Кнопка "Добавить в корзину" из слоя features */}
          <AddToCartButton productId={product.id} />

          {/* Кнопка "Избранное" также из слоя features */}
          <ToggleFavoriteButton productId={product.id} />
        </Stack>
      </Stack>
    </Card>
  )
}
```

Как видите, этот виджет объединяет:

- сущность `Product` (данные и отображение);
- фичи `AddToCart` и `Favorites`;
- базовые UI-компоненты для компоновки.

Страница может просто подключить этот виджет, не заботясь о том, какие конкретно фичи внутри него используются.

---

## Работа с состоянием внутри виджета

### Где хранить состояние

Виджет может иметь состояние:

- локальное (через React useState/useReducer);
- получаемое из стора (Redux, Zustand, Effector и тд) через слой `entities` или `features`;
- комбинированное (локальное состояние виджета плюс данные из стора).

Важно правило: **виджет не должен "изобретать свой стор" отдельно от архитектуры**, он должен использовать уже выбранный подход проекта.

### Пример локального состояния в виджете

Давайте сделаем простой виджет "CollapsibleUserProfile", который показывает или скрывает профиль пользователя.

```tsx
// widgets/collapsible-user-profile/ui/CollapsibleUserProfile.tsx

import { FC, useState } from 'react'
import { UserProfile } from 'widgets/user-profile'
import { Button } from 'shared/ui'

type CollapsibleUserProfileProps = {
  userId: string
}

export const CollapsibleUserProfile: FC<CollapsibleUserProfileProps> = ({ userId }) => {
  // Локальное состояние, отвечает за открыт или закрыт блок
  const [isOpen, setIsOpen] = useState(true)

  return (
    <div>
      {/* Кнопка переключения состояния */}
      <Button onClick={() => setIsOpen(!isOpen)}>
        {isOpen ? 'Скрыть профиль' : 'Показать профиль'}
      </Button>

      {/* Если состояние isOpen истинно - рендерим вложенный виджет */}
      {isOpen && (
        <div style={{ marginTop: 16 }}>
          <UserProfile userId={userId} />
        </div>
      )}
    </div>
  )
}
```

Здесь вы видите:

- виджет использует другой виджет (`UserProfile`);
- добавляет локальное поведение (сворачивание/разворачивание);
- все это не требует обращения к глобальному стору.

Такой подход полезен, когда логика касается только отображения и не является частью бизнес-логики.

---

## Взаимодействие widgets с другими слоями

### Widgets и pages

Страницы используют виджеты как строительные блоки. Давайте посмотрим пример страницы профиля:

```tsx
// pages/profile/ui/ProfilePage.tsx

import { UserProfile } from 'widgets/user-profile'
import { UserOrders } from 'widgets/user-orders'
import { Layout } from 'shared/ui'

// Компонент страницы, принимающий props из роутера
export const ProfilePage = () => {
  const userId = 'current' // В реальном приложении это может быть из auth или роутера

  return (
    <Layout>
      {/* В шапке можем показать виджет профиля */}
      <UserProfile userId={userId} />

      {/* Ниже - виджет заказов пользователя */}
      <UserOrders userId={userId} />
    </Layout>
  )
}
```

Видите, как страница становится "композицией виджетов". Внутренние детали (какие фичи используются, как данные подгружаются внутри виджета) — спрятаны.

### Widgets и features

Виджет может использовать несколько фич одновременно. Например, виджет "AuthPanel" может:

- показывать форму логина;
- показывать кнопку выхода;
- показывать переключатель языка.

```tsx
// widgets/auth-panel/ui/AuthPanel.tsx

import { FC } from 'react'
import { LoginForm } from 'features/auth/login'
import { LogoutButton } from 'features/auth/logout'
import { ChangeLanguageSelect } from 'features/i18n/change-language'
import { useAuth } from 'entities/auth'
import { Card, Stack } from 'shared/ui'

export const AuthPanel: FC = () => {
  // Хук авторизации из entities или features
  const { isAuth } = useAuth()

  return (
    <Card>
      <Stack direction="column" gap={16}>
        {/* Фича смены языка */}
        <ChangeLanguageSelect />

        {/* В зависимости от состояния auth показываем разные фичи */}
        {isAuth ? (
          // Если пользователь авторизован - показываем кнопку выхода
          <LogoutButton />
        ) : (
          // Если нет - показываем форму входа
          <LoginForm />
        )}
      </Stack>
    </Card>
  )
}
```

Так виджет инкапсулирует несколько сценариев и предоставляет простой интерфейс: вы просто рендерите `<AuthPanel />`.

---

## Паттерны проектирования для widgets-layer

### Паттерн "виджет как композиция"

Смотрите, самый частый паттерн: виджет представляет собой композицию нескольких блоков:

- данные из entities;
- действия из features;
- UI-скелет из shared.

Такой подход:

- облегчает переиспользование;
- делает код страниц более чистым;
- позволяет тестировать виджет отдельно.

### Паттерн "контейнер + презентационный компонент"

Иногда удобно разделять виджет на:

- контейнер, который работает с данными и состоянием;
- презентационный компонент, который только отображает.

Покажу вам, как это реализовано на практике.

```tsx
// widgets/user-profile/ui/UserProfileContainer.tsx

import { FC } from 'react'
import { useUser } from 'entities/user'
import { Spinner } from 'shared/ui'
import { UserProfileView } from './UserProfileView'

type UserProfileContainerProps = {
  userId: string
}

export const UserProfileContainer: FC<UserProfileContainerProps> = ({ userId }) => {
  const { data: user, isLoading } = useUser(userId)

  if (isLoading) {
    return <Spinner />
  }

  if (!user) {
    return <div>Пользователь не найден</div>
  }

  // Передаем данные во "view" компонент
  return <UserProfileView user={user} />
}
```

```tsx
// widgets/user-profile/ui/UserProfileView.tsx

import { FC } from 'react'
import { User } from 'entities/user'
import { Card, Text } from 'shared/ui'

type UserProfileViewProps = {
  user: User
}

export const UserProfileView: FC<UserProfileViewProps> = ({ user }) => {
  return (
    <Card>
      {/* Здесь мы просто отображаем данные, без загрузки или ошибок */}
      <Text>{user.name}</Text>
      <Text>{user.email}</Text>
    </Card>
  )
}
```

Такой подход упрощает тестирование и переиспользование view-компонента, например, в другом виджете, где данные уже загружены.

---

## Организация импорта и именование виджетов

### Именование

Рекомендации, которые часто помогают:

- использовать смысловые, а не технические имена:
  - `user-profile`, `cart-summary`, `auth-panel`, `sidebar-menu`;
- отдавать предпочтение `kebab-case` для директорий и `PascalCase` для компонентов;
- избегать нейтральных названий вроде `MainWidget` или `Widget1`.

Хорошие примеры имен:

- `widgets/user-profile`
- `widgets/product-recommendations`
- `widgets/notifications-panel`

### Путь импорта

Чтобы упростить работу с виджетами, удобно настроить алиасы в сборщике (Webpack, Vite, TypeScript, etc). Например:

- `widgets/*` → `src/widgets/*`

Тогда импорт выглядит аккуратно:

```ts
// Импорт виджета через алиас widgets
import { ProductDetails } from 'widgets/product-details'
```

---

## Тестирование виджетов

### Что тестировать в widgets-layer

Виджеты обычно тестируются на уровне:

- рендера с моками данных и зависимостей;
- отображения правильных элементов в зависимости от состояния;
- корректной интеграции фич (например, вызов нужных колбеков).

Давайте разберемся на примере. Пусть у нас есть виджет "NotificationsPanel", показывающий список уведомлений и кнопку "Отметить все прочитанными".

Предположим, в тесте мы:

- мокаем хук `useNotifications`;
- проверяем, что фича `MarkAllAsReadButton` рендерится;
- проверяем, что список уведомлений отображается.

Псевдокод (без конкретного тестового фреймворка):

```ts
// widgets/notifications-panel/ui/NotificationsPanel.test.tsx

// Здесь мы импортируем тестовую библиотеку
import { render, screen } from '@testing-library/react'
// Импортируем сам виджет
import { NotificationsPanel } from './NotificationsPanel'
// Мокаем хук из entities
import { useNotifications } from 'entities/notification'

// Подготавливаем мок для useNotifications
jest.mock('entities/notification')

test('рендерит список уведомлений и кнопку', () => {
  // Настраиваем мок, чтобы вернуть тестовые данные
  ;(useNotifications as jest.Mock).mockReturnValue({
    data: [
      { id: '1', text: 'Первое уведомление' },
      { id: '2', text: 'Второе уведомление' },
    ],
    isLoading: false,
  })

  // Рендерим виджет
  render(<NotificationsPanel />)

  // Проверяем, что тексты уведомлений отобразились
  expect(screen.getByText('Первое уведомление')).toBeInTheDocument()
  expect(screen.getByText('Второе уведомление')).toBeInTheDocument()

  // Проверяем наличие кнопки "Отметить все прочитанными"
  expect(screen.getByText('Отметить все прочитанными')).toBeInTheDocument()
})
```

Комментарии:

- мы не тестируем внутреннюю реализацию `useNotifications` — это забота слоя `entities`;
- мы тестируем, что виджет правильно реагирует на данные из этого хука;
- мы проверяем, что фича `MarkAllAsReadButton` доступна в разметке.

---

## Типичные ошибки при работе со слоем widgets и как их избежать

### Ошибка 1. Смешивание ответственности pages и widgets

Проблема: страница практически не содержит кода, а весь код внутри одного "супер-виджета", который выглядит как страница.

Как избежать:

- следите, чтобы страница:
  - отвечала за роутинг и layout;
  - собирала несколько виджетов и, возможно, пару простых фич;
- если виджет становится слишком большим, подумайте, не разбить ли его на несколько виджетов и вынести часть логики на страницу.

### Ошибка 2. Обратные зависимости (widgets → pages)

Проблема: виджет импортирует что-то из `pages` (например, хук роутера, объявленный на слое app/pages).

Как избежать:

- используйте абстракции в `shared` или `features`, если нужна навигация или другая глобальная функциональность;
- если логика действительно специфична для конкретной страницы, возможно, она должна остаться на странице, а не в виджете.

### Ошибка 3. Виджеты без четкого публичного API

Проблема: внешние слои импортируют внутренние файлы виджета напрямую (`widgets/user-profile/ui/UserProfile`), вместо обращения через `widgets/user-profile`.

Риски:

- вы теряете контроль над внешним контрактом;
- при рефакторинге ломаются "случайные" места.

Решение:

- экспортируйте публичные компоненты и типы через `index.ts`;
- внутри проекта используйте только путь `widgets/user-profile`.

### Ошибка 4. Слишком "умные" виджеты

Проблема: виджет берет на себя и загрузку данных, и бизнес-логику, и еще хранит кэш самостоятельно.

Решение:

- выносите бизнес-логику в `features` и `entities`;
- оставляйте виджету роль интегратора.

---

## Практические рекомендации по внедрению widgets-layer

### С чего начать, если у вас уже есть монолитные страницы

Если у вас уже есть большие компоненты страниц, можно постепенно выделять виджеты:

1. Найдите повторяющиеся блоки интерфейса на разных страницах.
2. Выделите их в отдельные компоненты.
3. Определите, какие зависимости у этих блоков:
   - если они тянут фичи и сущности — это кандидат на виджет;
   - если только UI-компоненты — это скорее элемент слоя `shared/ui`.
4. Перенесите эти компоненты в `widgets`, организуйте публичный API через `index.ts`.
5. Обновите страницы, чтобы использовать новые виджеты.

### Как понять, что блок интерфейса — это виджет

Хорошие признаки:

- блок используется минимум в двух местах;
- блок комбинирует несколько фич, сущностей или сложных UI-компонентов;
- блок имеет понятный смысл с точки зрения пользователя (например, "панель уведомлений", "панель авторизации", "рекомендации товаров").

Если блок небольшой и не тянет на "смысловой модуль", его место, скорее всего, в `shared/ui`.

---

## Заключение

Слой widgets (widgets-layer) — это важный интеграционный уровень в архитектуре фронтенда, который помогает:

- собирать повторно используемые фрагменты интерфейса;
- инкапсулировать комбинации фич и сущностей;
- держать страницы "тонкими" и читаемыми;
- поддерживать направленность зависимостей.

Когда вы проектируете виджеты, полезно помнить:

- виджет — это не страница, а часть страницы;
- виджет может зависеть только от слоев ниже и "соседних" виджетов;
- публичный API виджета должен быть четким и стабильным;
- внутренняя структура виджета (ui, model, lib) должна быть спрятана за index.ts.

Используя widgets-layer, вы получаете более модульное, предсказуемое и масштабируемое приложение, в котором каждый слой выполняет свою роль, а код проще понимать и поддерживать.

---

## Частозадаваемые технические вопросы по widgets-layer

### Как передавать данные в виджет — через пропсы или через глобальное состояние

Если данные уже лежат в глобальном сторе и доступны через хук слоя entities или features, удобнее забирать их внутри виджета. Если данные уникальны для конкретного контекста (например, `initialFilters` для списка товаров), лучше передать их через пропсы. Практика часто комбинирует оба подхода — статические настройки через пропсы, динамические данные через стор.

### Можно ли вызывать роутер (navigate) внутри виджета

Можно, но аккуратно. Если ваш проект использует роутер на слое app и вы обернули его в хелпер из shared (например, `useAppNavigation`), то виджет может использовать этот хелпер. Главное — не импортировать непосредственно `pages` или специфичные для страницы компоненты. Навигация в ответ на действие пользователя — нормальная ответственность виджета.

### Можно ли один виджет вкладывать в другой

Да, это нормально и часто полезно. Но следите, чтобы не создавать циклические зависимости. Если два виджета начинают зависеть друг от друга, стоит вынести общую часть в третий виджет или на слой ниже (features/entities) и использовать его в обоих местах.

### Как поступать с асинхронной загрузкой данных в виджете

Обычно данные загружаются через хуки из слоя entities или features, которые уже инкапсулируют работу с API. Виджет просто вызывает хук, обрабатывает состояния `loading` `error` `data` и отображает соответствующее UI. Не стоит реализовывать прямые запросы к API внутри widgets, если они не обернуты в единый подход проекта.

### Как организовать стили для виджетов

Стили виджета лучше хранить вместе с ним в его директории, например рядом с ui-компонентами. Подход к стилям (CSS Modules, styled-components, Tailwind и тд) выбирается на уровне проекта. Главное — не утягивать в виджет глобальные стили, специфичные для страниц. Если стиль нужен во многих виджетах, выносите его в shared/ui или shared/styles.