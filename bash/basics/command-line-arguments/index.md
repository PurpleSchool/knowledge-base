---
metaTitle: Параметры командной строки в Bash — $1, $@, getopts и валидация
metaDescription: Полное руководство по аргументам Bash-скриптов: позиционные параметры, флаги, getopts, проверка входа и безопасная обработка.
author: Олег Марков
title: Параметры командной строки в Bash — полный разбор
preview: Разберём, как принимать и валидировать аргументы в Bash: от простых $1/$2 до флагов через getopts, чтобы скрипты были предсказуемыми.
---

## Введение

Параметры командной строки делают скрипт переиспользуемым: один и тот же файл можно запускать в разных режимах, на разных окружениях и с разными входными данными.

## Позиционные параметры

При запуске:

```bash
./deploy.sh prod eu-central-1
```

внутри скрипта доступны:

- `$0` — имя скрипта;
- `$1`, `$2`, ... — аргументы по позиции;
- `$#` — количество аргументов;
- `$@` — все аргументы списком.

Пример:

```bash
#!/usr/bin/env bash
set -euo pipefail

env_name="${1:-}"
region="${2:-}"

[[ -n "$env_name" ]] || { echo "Usage: $0 <env> <region>" >&2; exit 1; }
[[ -n "$region" ]] || { echo "Usage: $0 <env> <region>" >&2; exit 1; }

echo "Deploy to $env_name in $region"
```

## Почему важно использовать `"$@"`

Если нужно пробросить аргументы дальше, делай так:

```bash
some_command "$@"
```

Это сохраняет границы аргументов (особенно со пробелами). `"$*"` ведёт себя иначе и обычно не подходит.

## Обработка флагов через getopts

Для флагов `-e`, `-r`, `-h` используй `getopts`:

```bash
#!/usr/bin/env bash
set -euo pipefail

env_name=""
region=""

while getopts ":e:r:h" opt; do
  case "$opt" in
    e) env_name="$OPTARG" ;;
    r) region="$OPTARG" ;;
    h)
      echo "Usage: $0 -e <env> -r <region>"
      exit 0
      ;;
    \?)
      echo "Unknown option: -$OPTARG" >&2
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires a value" >&2
      exit 1
      ;;
  esac
done

[[ -n "$env_name" && -n "$region" ]] || {
  echo "Usage: $0 -e <env> -r <region>" >&2
  exit 1
}

echo "Deploy to $env_name in $region"
```

## Валидация аргументов

Минимум, который стоит делать всегда:

1. Проверить количество аргументов.
2. Проверить обязательные параметры на пустоту.
3. Проверить формат (например, число, путь, окружение).
4. Печатать понятный `Usage` в stderr при ошибке.

## Типовые паттерны

### Значение по умолчанию

```bash
timeout="${1:-30}"
```

### Проверка числа

```bash
[[ "$timeout" =~ ^[0-9]+$ ]] || { echo "timeout must be number" >&2; exit 1; }
```

### Сдвиг параметров

`shift` убирает обработанный аргумент и двигает остальные.

## Частые ошибки

- чтение `$1` без проверки, что он передан;
- потеря аргументов из-за отсутствия кавычек;
- смешивание позиционных параметров и флагов без чёткой схемы;
- отсутствие help/usage.

## Вывод

Грамотная работа с аргументами — основа надёжного CLI-скрипта. Для простых сценариев хватает `$1/$2` + валидация, для гибких интерфейсов используй `getopts` и всегда добавляй понятный `Usage`.
