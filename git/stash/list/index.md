---
metaTitle: Список сохранений в Git - git stash list
metaDescription: Разбираем как работать со списком временных сохранений в Git - команда git stash list фильтрация поиск и управление отложенными изменениями на практике
author: Олег Марков
title: Список сохранений в Git - git stash list
preview: Узнайте как с помощью git stash list просматривать и упорядочивать временные сохранения в Git - разберем формат вывода фильтрацию и практические сценарии использования
---

## Введение

Команда git stash часто выручает, когда нужно срочно переключиться на другую задачу, не теряя текущих незаконченных изменений. Вы откладываете изменения в «тайник» (stash), переключаетесь на другую ветку, что‑то делаете, а потом возвращаетесь и забираете сохраненное.

Но как понять, какие именно временные сохранения уже есть, что в них лежит и какое из них вам сейчас нужно? Для этого и существует команда git stash list.

Смотрите, здесь мы подробно разберем, как работает список сохранений в Git, как читать его вывод, как искать нужный stash по сообщению, ветке или файлам, а также как управлять этим списком, не запутываясь со временем.

---

## Что такое git stash list и зачем он нужен

Команда git stash list показывает все отложенные изменения (stash’и), которые вы ранее сохранили с помощью git stash (или git stash save в старых версиях). Каждый такой stash — это отдельный набор изменений, связанный с конкретным состоянием репозитория в определенный момент.

Проще говоря, git stash list отвечает на вопросы:

- Сколько у вас сейчас временных сохранений
- В каком порядке вы их создавали
- К какой ветке они относятся
- Какое сообщение вы указали при сохранении
- Какой идентификатор использовать, чтобы применить или удалить конкретный stash

Базовая команда очень проста:

```bash
git stash list
```

Но за этим простым выводом скрывается много полезной информации, которую важно научиться читать. Давайте разберемся на примерах.

---

## Формат вывода git stash list

### Стандартный формат строки списка

Запустите:

```bash
git stash list
```

Пример вывода:

```bash
stash@{0}: WIP on feature/auth: 7c9f2a1 Add login form layout
stash@{1}: WIP on main: 1a2b3c4 Fix typo in README
stash@{2}: On bugfix/session: 8f9a0b1 Handle expired sessions
```

Разберем первую строку по частям:

```text
stash@{0}: WIP on feature/auth: 7c9f2a1 Add login form layout
^--------^ ^------------------^ ^----^ ^-----------------------^
    1                2           3              4
```

1. `stash@{0}`  
   - Это идентификатор stash’а.  
   - `{0}` — самый свежий stash, `{1}` — предыдущий и так далее.  
   - Вы будете использовать его в командах `git stash show`, `git stash apply`, `git stash drop` и т.д.

2. `WIP on feature/auth`  
   - `WIP` означает Work In Progress — незавершенная работа.  
   - `on feature/auth` — имя ветки, на которой вы были, когда создавали этот stash.

3. `7c9f2a1`  
   - Сокращенный хеш коммита, относительно которого были сделаны изменения.  
   - Помогает понять, в каком контексте создавался stash.

4. `Add login form layout`  
   - Сообщение коммита, на основе которого создавался stash.  
   - Это не ваше описание stash’a, а именно сообщение коммита, который был HEAD в момент сохранения.

Если вы явно указывали сообщение для stash, например:

```bash
git stash push -m "Хотфикс стилей формы"
```

То вывод будет выглядеть так:

```bash
stash@{0}: On feature/auth: Хотфикс стилей формы
```

Обратите внимание, как это меняет строку: теперь текст после `:` — это уже ваше сообщение stash’a, а не WIP/коммит.

---

## Создание stash’ей и их влияние на список

### Базовое создание stash

Чтобы что‑то появилось в git stash list, нужно сначала создать хотя бы одно временное сохранение:

```bash
git stash
// Сохраняем все отслеживаемые и измененные файлы в stash
```

После этого:

```bash
git stash list
// Увидите один элемент stash@{0}
```

### Использование git stash push с сообщением

Сейчас более предпочтительно использовать явную форму:

```bash
git stash push -m "Черновик обработки ошибок в API"
// -m позволяет задать понятное сообщение
```

Потом в списке:

```bash
git stash list
// Вывод будет содержать ваше сообщение, что облегчает поиск нужного stash
```

### Сохранение только части изменений

Вы можете заранее решить, что именно попадет в stash. Например:

```bash
git stash push -m "Только backend изменения" backend/
// Сохраняем изменения только в каталоге backend

git stash push -m "Черновик верстки" frontend/
// Сохраняем изменения только в каталоге frontend
```

Теперь в списке будет два разных stash’a с разными сообщениями, и по ним проще ориентироваться:

```bash
git stash list
// Вы увидите два stash@{0}, stash@{1} с разными текстами
```

Здесь удобно сразу придумать хорошие описания, чтобы через пару дней вы не тратили время на угадывание.

---

## Как ссылаться на конкретный stash из списка

### Ссылки по индексу stash@{N}

Самый частый способ — использовать индекс из списка:

```bash
git stash show stash@{1}
// Показываем, какие файлы и изменения есть во втором по счету stash

git stash apply stash@{2}
// Применяем третий по счету stash, оставляя его в списке

git stash drop stash@{0}
// Удаляем самый новый stash из списка
```

Смотрите, я покажу вам, как это выглядит в реальной последовательности:

```bash
git stash push -m "Черновик логики авторизации"
git stash push -m "Черновик верстки формы"

git stash list
// Предположим, вывод:
// stash@{0}: On feature/auth: Черновик верстки формы
// stash@{1}: On feature/auth: Черновик логики авторизации

git stash apply stash@{1}
// Применяем более старый stash с логикой авторизации
```

### Ссылки по имени ветки и хешу

Иногда вы видите в выводе часть строки и хотите работать с ней через git show. Например:

```bash
stash@{0}: WIP on main: 1a2b3c4 Fix config
```

Вы можете обратиться к объекту коммита внутри stash напрямую:

```bash
git show stash@{0}
// Покажет diff изменений, как если бы это был обычный коммит
```

Но именно для управления stash в обычных командах лучше всегда использовать полную форму `stash@{N}`, а не какие‑то частичные идентификаторы, чтобы избежать путаницы.

---

## Изучение содержимого stash’ей из списка

### Краткий обзор изменений

Чтобы понять, что именно лежит в конкретном stash, используйте:

```bash
git stash show stash@{0}
// По умолчанию покажет список измененных файлов без подробностей
```

Пример вывода:

```text
 src/auth/login.go | 10 ++++++++--
 src/auth/ui.html  |  5 ++++-
 2 files changed, 12 insertions(+), 3 deletions(-)
```

Здесь вы видите только суммарную статистику по файлам.

### Полный diff конкретного stash

Если нужно увидеть все изменения детально, добавьте флаг `-p`:

```bash
git stash show -p stash@{0}
// -p (или --patch) показывает полный патч, как в git diff
```

Пример:

```diff
diff --git a/src/auth/login.go b/src/auth/login.go
index 1234567..89abcde 100644
--- a/src/auth/login.go
+++ b/src/auth/login.go
@@ -10,6 +10,10 @@ func Login() {
-   // TODO implement
+   // Временная заглушка для авторизации
+   // Здесь позже будет полноценная логика
}
```

Комментарии в коде помогут вам вспомнить, на чем вы остановились, поэтому не забывайте добавлять их при разработке.

### Просмотр всех stash’ей по очереди

Иногда удобно быстро пробежаться по всем stash’ам:

```bash
git stash list | cut -d: -f1 | while read s; do
  echo "=== $s ==="
  git stash show -p "$s"
done
// Здесь мы:
// 1. Берем список stash’ей
// 2. Оставляем только идентификатор до первого двоеточия
// 3. Для каждого показываем подробный diff
```

Так вы увидите все сохраненные изменения, не вызывая git stash show вручную на каждый.

---

## Фильтрация и форматирование списка сохранений

По умолчанию git stash list выводит только базовую информацию. Но вы можете настроить формат и фильтры, чтобы список был более удобен.

### Кастомный формат через --pretty

Команда git stash list поддерживает опцию `--pretty`, как и многие команды Git. Пример:

```bash
git stash list --pretty="%gd %cr %gs"
// %gd - сокращенный ref (например, stash@{0})
// %cr - время в относительном формате (2 hours ago)
// %gs - заголовок сообщения
```

Пример вывода:

```text
stash@{0} 30 minutes ago Черновик верстки формы
stash@{1} 2 hours ago Черновик логики авторизации
stash@{2} 3 days ago Хотфикс стилей формы
```

Так вы сразу видите, насколько старое каждое временное сохранение.

Еще один полезный формат:

```bash
git stash list --pretty="%gd %h %an %ar %gs"
// %h  - сокращенный хеш объекта
// %an - автор
// %ar - относительное время (как %cr)
```

### Сортировка по дате (через git log‑подобный вывод)

Команда git stash list опирается на обычный механизм отображения reflog, поэтому порядок stash’ей всегда от самого нового к самому старому. Изменить этот порядок непосредственно через git stash list нельзя, но вы можете дополнительно обрабатывать вывод.

Например, если хотите видеть stash’и с датой в более удобном виде:

```bash
git stash list --date=iso --pretty="%gd %cd %gs"
// %cd - дата коммита в заданном формате
```

---

## Использование git log для углубленного анализа stash’ей

git stash list — это, по сути, удобная обертка вокруг reflog для специальной ссылки refs/stash. Иногда полезно использовать git log, чтобы гибко фильтровать stash’и.

### Просмотр stash через git log

Попробуйте:

```bash
git log -g refs/stash --oneline --decorate
// -g говорит git log использовать reflog
// refs/stash - специальная ссылка, где хранятся stash’и
```

Вы увидите историю stash’ей как историю коммитов, с хешами и датами.

### Фильтрация по сообщениям

Если вы помните часть сообщения, используйте:

```bash
git log -g refs/stash --grep="верстки" --oneline
// Покажет только те stash’и, где в сообщении есть слово "верстки"
```

Зная хеш, вы можете потом обратиться к stash напрямую:

```bash
git show <hash>
// Просмотр содержимого этого stash объекта
```

Хотя в большинстве повседневных случаев достаточно обычного git stash list, этот подход полезен в сложных ситуациях, когда stash’ей уже десятки.

---

## Работа со списком сохранений: применение, возврат, удаление

Хотя основная тема статьи — список сохранений, невозможно полноценно описать git stash list, не затронув команды, которые используют этот список. Давайте кратко пройдемся по ним с акцентом на связь с индексами stash@{N}.

### Применение изменений из stash

Список дает вам идентификатор, а применять вы будете так:

```bash
git stash apply stash@{0}
// Применяет изменения, но не удаляет сам stash из списка
```

Если индекс не указать, Git возьмет `stash@{0}` по умолчанию:

```bash
git stash apply
// Эквивалентно git stash apply stash@{0}
```

Если после применения все прошло успешно, можно удалить уже ненужное сохранение:

```bash
git stash drop stash@{0}
// Удаляем запись из списка
```

### Одновременное применение и удаление: git stash pop

Команда git stash pop использует тот же список, но работает чуть агрессивнее:

```bash
git stash pop stash@{1}
// Применяет изменения из stash@{1} и сразу удаляет его из списка
```

Без аргумента:

```bash
git stash pop
// Эквивалентно apply + drop для stash@{0}
```

Здесь важно быть аккуратнее. Если при pop возникнут конфликты, stash уже будет удален. В отличие от apply, который сохраняет запись, пока вы не убедитесь, что все применилось корректно.

### Удаление отдельных сохранений

Вы уже видели базовый пример:

```bash
git stash drop stash@{2}
// Удаляем конкретный stash
```

Если хотите убрать сразу все временные сохранения:

```bash
git stash clear
// Очищает весь список stash’ей
```

Перед clear имеет смысл вывести список и убедиться, что там нет ничего важного:

```bash
git stash list
// Проверьте, что все stash’и действительно больше не нужны
```

---

## Практические сценарии использования git stash list

### Переключение задач без потери контекста

Представьте, вы работали в ветке feature/auth, сделали несколько черновиков верстки и логики, но внезапно нужно переключиться на main и срочно исправить баг.

Типичный сценарий:

```bash
// Находитесь в feature/auth с незакоммиченными изменениями
git stash push -m "Черновик логики авторизации"
git stash push -m "Черновик верстки формы"

// Переключаетесь на main
git checkout main

// Делаете хотфикс
// ...
git commit -am "Хотфикс NPE при логине"
```

После этого, чтобы вернуться к своим изменениям, вы смотрите список:

```bash
git stash list
// Видите два stash’а с понятными сообщениями
```

Теперь вы спокойно решаете, с чего продолжить, например:

```bash
git checkout feature/auth
git stash apply stash@{1}
// Берете сначала логику, потом, при необходимости, верстку
```

Здесь список — это ваш навигатор по отложенным задачам.

### Разделение больших изменений на логические части

Бывает, вы начали делать крупную фичу, но понимаете, что изменения лучше разделить на несколько коммитов. git stash list может помочь вам контролировать этапы.

Смотрите, пример:

```bash
// 1. Сначала изменили модели
git stash push -m "Изменения моделей пользователя"

// 2. Потом доработали контроллеры
git stash push -m "Обновление контроллеров авторизации"

// 3. Наконец, поправили тесты
git stash push -m "Актуализация тестов"
```

Теперь в списке:

```bash
git stash list
// Видно три отдельных этапа работы
```

Дальше вы можете применять их по одному и оформлять аккуратными коммитами:

```bash
git stash apply stash@{2}
// Применили изменения моделей
git commit -am "Рефакторинг моделей пользователя"

git stash apply stash@{1}
// Контроллеры
git commit -am "Обновление логики авторизации"

// И так далее
```

Список позволяет не потеряться в нескольких временных сохранениях и пошагово восстанавливать нужные части работы.

### Работа в разных ветках с общим stash списком

Важно понимать: список сохранений в Git хранится на уровне репозитория, а не ветки. Поэтому git stash list всегда общий для всех веток в данном репозитории.

Например:

```bash
// На ветке feature/a
git stash push -m "Черновик A"

// Переключаемся на feature/b
git checkout feature/b

git stash push -m "Черновик B"

git stash list
// Вы увидите оба stash’а - и для A и для B
```

Поэтому особенно важно давать хорошее описание каждому stash’у, чтобы по списку было сразу понятно, к какой задаче он относится.

---

## Советы по эффективному использованию git stash list

### Используйте осмысленные сообщения

Да, git stash по умолчанию ставит WIP‑сообщения, но лучше один раз подумать и явно задать текст:

```bash
git stash push -m "auth - новая валидация формы логина"
git stash push -m "ui - экспериментальный макет модального окна"
```

В списке сразу будет ясно, что где лежит:

```bash
git stash list
// stash@{0}: On feature/ui: ui - экспериментальный макет модального окна
// stash@{1}: On feature/auth: auth - новая валидация формы логина
```

### Не копите десятки stash’ей без необходимости

git stash list легко разрастается, если вы постоянно что‑то откладываете и не возвращаетесь. В определенный момент список становится шумом.

Простой подход:

- После успешного применения стэша — удаляйте его (`drop` или используйте `pop`)
- Регулярно просматривайте список и чистите явно устаревшее (`git stash clear` после проверки)

### Проверяйте содержимое перед применением

Перед тем как применять старый stash, особенно в ветку, которая уже сильно изменилась, посмотрите, что внутри:

```bash
git stash show -p stash@{3}
// Убедитесь, что изменения логично лягут на текущее состояние кода
```

Это помогает избежать неожиданных конфликтов или неожиданно устаревших изменений.

---

## Заключение

Команда git stash list — это ваш основной инструмент для навигации по временным сохранениям в Git. Она показывает:

- Полный список stash’ей с индексами
- Ветку, в которой был создан каждый stash
- Сообщение (либо стандартное WIP, либо ваше собственное)
- Контекст, в котором создавался stash

Когда вы понимаете, как читать этот список и как с ним работать, использование git stash перестает быть рискованной «черной коробкой» с потерянными изменениями и превращается в удобный рабочий инструмент для управления незавершенной работой.

Старайтесь:

- Давать stash’ам понятные сообщения
- Регулярно проверять список и очищать старое
- Использовать идентификаторы `stash@{N}` осознанно
- Смотреть содержимое stash перед применением, особенно если он старый

Так вы сможете безопасно откладывать работу, быстро переключаться между задачами и при этом сохранять полный контроль над всеми временными сохранениями.

---

## Частозадаваемые технические вопросы по теме и ответы

### Как посмотреть содержимое всех stash’ей разом, но без полного diff

Вам не нужен полный патч, только список файлов. Можно использовать цикл по списку:

```bash
git stash list | cut -d: -f1 | while read s; do
  echo "=== $s ==="
  git stash show "$s"
// Для каждого stash выводим только сводку по файлам
done
```

Так вы быстро получите обзор, какие файлы менялись в каждом сохранении.

### Как найти stash, в котором есть изменения по конкретному файлу

Полезен перебор с grep по имени файла:

```bash
git stash list | cut -d: -f1 | while read s; do
  git stash show "$s" --name-only | grep -q "src/auth/login.go" && echo "$s"
// Для каждого stash смотрим список файлов и ищем нужный
done
```

В результате вы получите идентификаторы тех stash’ей, где затронут этот файл.

### Как вывести список stash’ей только для определенной ветки

Git хранит stash’и общим списком, но можно отфильтровать по имени ветки в описании:

```bash
git stash list | grep "On feature/auth"
// Показаны только те строки, где был создан stash на ветке feature/auth
```

Если вы используете единый префикс в сообщениях, можно фильтровать и по нему.

### Как узнать точную дату создания stash’а

Используйте форматированный вывод:

```bash
git stash list --date=iso --pretty="%gd %cd %gs"
// %cd выводит дату создания в ISO формате
```

Так вы увидите точное время создания каждого временного сохранения.

### Можно ли переименовать уже существующий stash в списке

Напрямую — нет, Git не предоставляет команды для изменения сообщения stash. Но можно сделать обходной путь:

```bash
git stash show -p stash@{2} | git apply -R
// Восстанавливаем чистое состояние (если нужно)

git stash show -p stash@{2} | git apply
git stash push -m "Новое осмысленное сообщение"
// Создаем новый stash с теми же изменениями, но другим описанием

git stash drop stash@{2}
// Удаляем старый stash
```

По сути вы воссоздаете тот же набор изменений с новым именем.