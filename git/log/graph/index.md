---
metaTitle: Графический просмотр истории в Git с помощью git log --graph
metaDescription: Разберитесь как использовать git log --graph для наглядного просмотра истории коммитов веток и слияний в Git - получите практические примеры и удобные шаблоны команд
author: Олег Марков
title: Графический просмотр истории в Git - git log --graph
preview: Узнайте как визуально анализировать историю репозитория с помощью git log --graph - научитесь читать ветвления слияния и настраивать вывод под свои задачи
---

## Введение

Графический просмотр истории с помощью git log --graph — это один из самых удобных способов понять, что происходило с вашим репозиторием: когда ветки расходились, где были выполнены merge или rebase, какие коммиты входят в конкретную ветку и как они связаны между собой.

Команда git log по умолчанию показывает список коммитов в текстовом виде. Но как только вы добавляете опцию --graph, история превращается в компактную ASCII-схему. Смотрите, я покажу вам, как это помогает:

- вы видите не просто последовательность коммитов, а «карту» ветвлений;
- вы быстро замечаете, где случились слияния;
- вы понимаете, почему какая-то ветка не содержит нужный вам коммит;
- вы можете визуально проверить результат rebase или merge.

Давайте разбираться, как устроен git log --graph, какие есть режимы отображения, как настроить удобные сокращенные команды и как читать сложные графы в реальных проектах.

## Что делает опция --graph в git log

### Базовый принцип работы

Опция --graph добавляет к обычному выводу git log текстовое представление графа коммитов слева от каждой строки. Git строит дерево (на самом деле ацикличный граф) родительских связей между коммитами и рисует его с помощью символов:

- `*` — конкретный коммит;
- `|` — вертикальная линия, продолжающая ветку;
- `\` и `/` — ветвления и слияния;
- иногда `+` или другие комбинации символов — в сложных случаях переплетений веток.

Посмотрите на простой пример. Допустим, у вас есть репозиторий с веткой main и ответвлением feature:

```bash
git log --graph
```

Пример вывода (Git может оформить чуть по-другому, но общий принцип сохраняется):

```text
*   commit a1b2c3d
|\  Merge branch 'feature'
| | 
| * commit 9f8e7d6
| | Author: ...
| | 
| * commit 8a7b6c5
|/  Author: ...
|   
*   commit 7c6b5a4
|   Author: ...
|
*   commit 6b5a4c3
    Author: ...
```

Здесь вы видите:

- две ветки истории (main и feature);
- отдельные коммиты ветки feature, которые позже были слиты в основной поток;
- merge-коммит, у которого два родителя (отсюда раздвоение линий).

### Отличие от обычного git log

Если выполнить просто:

```bash
git log
```

вы увидите линейный список коммитов. При merge-коммитах будет указано, что это merge, но визуального понимания ветвления не будет.

С git log --graph вы видите, как эти merge и ветки реально связаны: на каких коммитах они разошлись, в каких точках слились, какие ветки продолжаются отдельно.

### Почему граф получается не строго «деревом»

Теоретически история коммитов — это направленный ациклический граф, а не дерево:

- у каждого коммита один или несколько родителей (merge-коммиты имеют двух и более родителей);
- у одного родителя может быть несколько «детей» (из одного коммита может ответвляться несколько веток).

Поэтому визуально вы видите именно граф связей, а не строгое дерево. Git логически «укладывает» его в текстовые строки так, чтобы максимально сохранить читаемость, но порядок можно менять с помощью разных опций, о которых мы поговорим дальше.

## Базовые примеры использования git log --graph

### Самый простой вызов

Начнем с минимального рабочего варианта:

```bash
git log --graph
```

Так вы получите:

- граф истории;
- полный вывод по каждому коммиту (хеш, автор, дата, сообщение);
- стандартную сортировку по времени (от более новых к более старым).

Часто такой вывод получается слишком «шумным», поэтому сразу имеет смысл добавить минимум настройки формата.

### Добавляем сокращенный формат: --oneline

На практике почти всегда удобнее использовать вместе с --graph опцию --oneline, чтобы каждый коммит показывался в одной строке:

```bash
git log --graph --oneline
```

Как это выглядит:

```text
*   a1b2c3d Merge branch 'feature'
|\  
| * 9f8e7d6 Add API for search
| * 8a7b6c5 Fix bug in parser
|/  
* 7c6b5a4 Update documentation
* 6b5a4c3 Initial commit
```

Здесь вы видите:

- сокращённый хеш коммита;
- первую строку сообщения коммита;
- граф ветвлений слева.

Это уже очень полезный вариант для быстрого анализа структуры истории.

### Добавляем информацию о ветках: --decorate

Еще один важный флаг — --decorate. Он показывает имена веток и тегов, которые указывают на конкретный коммит:

```bash
git log --graph --oneline --decorate
```

Пример вывода:

```text
*   a1b2c3d (HEAD -> main, origin/main) Merge branch 'feature'
|\  
| * 9f8e7d6 (tag: v1.1.0) Add API for search
| * 8a7b6c5 Feature scaffold
|/  
* 7c6b5a4 (origin/old-main) Old main branch
* 6b5a4c3 Initial commit
```

Смотрите, что добавилось:

- HEAD -> main — текущая ветка и позиция HEAD;
- origin/main — удаленная ветка на сервере;
- tag: v1.1.0 — тег, привязанный к коммиту.

Такой формат уже можно считать «рабочим стандартом» для ежедневной работы.

### Комбинированный удобный вариант

Часто используют такой набор опций:

```bash
git log --graph --oneline --decorate --all
```

Разберемся по частям:

- --graph — рисует граф;
- --oneline — компактный формат одной строкой;
- --decorate — показывает имена веток/тегов;
- --all — показывает историю не только текущей ветки, но всех ссылок (ветки, теги, удаленные ветки).

Теперь вы увидите весь репозиторий целиком и сможете визуально отследить, как ваши ветки связаны между собой.

## Как читать вывод git log --graph

### Основные элементы графа

Чтобы вам было проще, давайте разберем типичный фрагмент вывода:

```text
*   a1b2c3d (HEAD -> main) Merge branch 'feature'
|\  
| * 9f8e7d6 (feature) Implement search
| * 8a7b6c5 Add basic search models
|/  
* 7c6b5a4 Refactor core module
* 6b5a4c3 Initial commit
```

Обратите внимание на несколько моментов:

- каждая ветка отображается своей вертикальной колонкой;
- символ `*` — это конкретный коммит;
- линии `|` — продолжение ветки вверх или вниз;
- комбинация `|\` — означает, что один из родителей merge-коммита находится в соседней колонке;
- `|/` — место, где ветка сливается с основной линией.

Граф читается сверху вниз: наиболее новые коммиты — вверху, старые — внизу. Связи между коммитами показываются линиями.

### Как понять, где какая ветка

Смотрите на правую часть строки с --decorate:

```text
* 9f8e7d6 (feature) Implement search
```

Это значит:

- ветка feature указывает на коммит 9f8e7d6;
- линия в этой колонке представляет историю ветки feature;
- если вы пойдете вниз по столбцу, вы увидите предыдущие коммиты этой ветки (до точки ветвления).

Для удаленных веток:

```text
* a1b2c3d (origin/main) ...
```

Здесь origin/main — ветка на удаленном репозитории origin.

### Merge-коммиты и их родители

Merge-коммит — это узел с двумя (или более) родителями. В графе это выглядит примерно так:

```text
*   a1b2c3d (HEAD -> main) Merge branch 'feature'
|\  
| * 9f8e7d6 (feature) Implement search
| * 8a7b6c5 Add basic search models
|/  
* 7c6b5a4 Refactor core module
```

Здесь:

- main указывает на merge-коммит;
- один из родителей — предыдущий коммит в main (7c6b5a4);
- второй родитель — вершина ветки feature (9f8e7d6).

Линии `|\` и `|/` дают вам понять, где именно «вошла» ветка feature в основную историю.

### Как увидеть точку разветвления ветки

Чтобы найти место, где ветка feature отделилась от main, вам нужно спуститься вниз по соответствующей колонке feature до того момента, когда линии веток «разойдутся».

Посмотрите на пример:

```text
*   a1b2c3d (HEAD -> main) Merge branch 'feature'
|\  
| * 9f8e7d6 (feature) Implement search
| * 8a7b6c5 Add basic search models
|/  
* 7c6b5a4 Refactor core module
* 6b5a4c3 Initial commit
```

Здесь видно, что ветка feature ответвилась где-то после коммита 7c6b5a4 (линии разделяются) и развивалась отдельно до merge-коммита.

## Полезные флаги и комбинации для git log --graph

### Настраиваем формат вывода: --pretty

Если --oneline вам не хватает (нужно видеть автора, дату), но стандартный формат слишком громоздкий, вы можете использовать --pretty.

Например:

```bash
git log --graph --pretty=format:"%h %ad %an %d %s" --date=short
```

Разберем формат:

- %h — короткий хеш;
- %ad — дата авторства;
- %an — имя автора;
- %d — декорации (ветки, теги);
- %s — сообщение коммита;
- --date=short — дата в формате YYYY-MM-DD.

Теперь вы увидите сжатый, но информативный вывод. Обратите внимание на кавычки — внутри них мы настраиваем формат, а git log слева добавляет граф.

Комментарии к примеру:

```bash
git log --graph \
  --pretty=format:"%h %ad %an %d %s" \  # Определяем, какие поля коммита печатать
  --date=short                           # Сокращенный формат даты
```

### Ограничение числа коммитов: -n

Чтобы не утонуть в истории, часто ограничивают количество коммитов:

```bash
git log --graph --oneline -20
```

Здесь вы увидите только 20 последних коммитов, но граф при этом сохранится.

### Фильтрация по веткам и диапазонам

Вы можете строить граф не по всему репозиторию, а по конкретным веткам или диапазонам:

```bash
git log --graph --oneline main
```

Покажет только историю ветки main.

```bash
git log --graph --oneline main..feature
```

Покажет коммиты, которые есть в feature, но отсутствуют в main. Граф при этом поможет понять, где эта развилка.

Комментарии:

```bash
git log --graph --oneline main..feature
# Показывает только те коммиты, которые:
# - лежат в истории feature
# - но не входят в историю main
```

Вы также можете задать диапазон по хешам:

```bash
git log --graph --oneline a1b2c3d..HEAD
```

### Фильтрация по файлам

Если вас интересует история конкретного файла, граф тоже может помочь:

```bash
git log --graph --oneline --decorate -- path/to/file.txt
```

Git покажет только те коммиты, которые изменяли указанный файл, но при этом сохранив структуру веток там, где это возможно.

Комментарии:

```bash
git log --graph --oneline -- path/to/file.txt
# Важно - перед путём к файлу стоит двойное тире
# Оно отделяет список опций от списка путей
```

### Фильтрация по автору и сообщению

Вы можете искать по автору:

```bash
git log --graph --oneline --author="Иван"
```

И по содержимому сообщений:

```bash
git log --graph --oneline --grep="bugfix"
```

Граф при этом останется, но в выборку попадут только подходящие коммиты.

## Настройка удобных alias для git log --graph

### Зачем нужны alias

Если каждый раз вводить длинную команду вида:

```bash
git log --graph --oneline --decorate --all
```

это быстро надоедает. Гораздо удобнее сделать алиас, например `git lg`, который будет запускать преднастроенный вывод.

### Создаем alias через git config

Давайте создадим простой алиас lg:

```bash
git config --global alias.lg "log --graph --oneline --decorate --all"
```

Комментарии:

```bash
git config --global alias.lg "log --graph --oneline --decorate --all"
# --global - сохраняем алиас в глобальной конфигурации пользователя
# alias.lg - имя алиаса (git lg)
# В кавычках - команда, которая будет выполняться
```

Теперь вы можете просто писать:

```bash
git lg
```

и получать удобный граф всей истории.

### Несколько уровней детализации

Часто разработчики создают несколько алиасов с разной степенью детализации. Например:

```bash
git config --global alias.lg "log --graph --oneline --decorate"
git config --global alias.lga "log --graph --oneline --decorate --all"
git config --global alias.lgd "log --graph --pretty=format:'%h %ad %an %d %s' --date=short"
```

Использование:

- git lg — история текущей ветки;
- git lga — история всех веток;
- git lgd — более детальный вывод с датой и автором.

### Проверяем, где хранятся алиасы

Чтобы посмотреть, как именно сохранен алиас, вы можете открыть файл конфигурации:

```bash
git config --global --edit
```

Там вы увидите блок:

```text
[alias]
    lg = log --graph --oneline --decorate --all
    lga = log --graph --oneline --decorate --all
    lgd = log --graph --pretty=format:'%h %ad %an %d %s' --date=short
```

Вы можете редактировать эти строки вручную, если вам так удобнее.

## Расширенные сценарии использования git log --graph

### Проверка результата rebase

После rebase часто хочется убедиться, что история стала линейной и ожидаемой. Для этого очень удобно использовать граф:

```bash
git log --graph --oneline --decorate
```

Если вы делали rebase feature на main, посмотрите:

- исчезли ли merge-коммиты, которые были до rebase;
- идет ли ветка feature теперь как «продолжение» main без развилок;
- нет ли неожиданных «петель» или дублей.

Если вы видите линейную историю без лишних ответвлений, rebase, скорее всего, прошел так, как вы ожидали.

### Анализ конфликтных merge

Когда при merge возникают конфликты, иногда полезно посмотреть, что именно произошло в истории:

```bash
git log --graph --oneline --decorate --all
```

Посмотрите:

- от каких коммитов расходятся конфликтующие ветки;
- какие изменения были сделаны в каждой ветке после разветвления;
- нет ли уже другого merge, который мог повлиять на текущий конфликт.

Так вы лучше поймете, какие изменения реально надо согласовать.

### Поиск «висящих» веток и забытых фич

Команда:

```bash
git log --graph --oneline --decorate --all
```

показывает все ветки, в том числе:

- старые feature-ветки;
- ветки, которые уже давно не сливались с main;
- «висящие» ветки, забытые кем-то из команды.

Вы можете визуально увидеть, что, например, ветка feature/old-search «оторвалась» от main очень давно и ее изменения никогда не попадали в основную ветку.

### Сравнение удаленной и локальной истории

Чтобы понять, чем ваша локальная ветка отличается от удаленной (например, origin/main), можно посмотреть на граф:

```bash
git log --graph --oneline --decorate --all
```

И визуально:

- найти расхождение между main и origin/main;
- увидеть, сколько коммитов вы сделали локально;
- понять, есть ли на сервере новые коммиты, которых нет у вас.

Если вы видите, что origin/main идет «выше» или «боком» от вашей локальной main, значит, на сервере есть новые коммиты.

## Полезные шаблоны и практические примеры

### Классический «набор дежурного Dev»

Смотрите набор команд, который часто используют в повседневной работе:

```bash
# История текущей ветки, компактно
git log --graph --oneline --decorate

# История всех веток
git log --graph --oneline --decorate --all

# История файла
git log --graph --oneline --decorate -- path/to/file

# Что отличает мою ветку от main
git log --graph --oneline main..
```

Комментарии:

```bash
git log --graph --oneline main..
# Показывает все коммиты, которые есть в текущей ветке
# но отсутствуют в main
```

### Диагностика «куда пропал мой коммит»

Представьте ситуацию: вы уверены, что сделали коммит, но в main его нет. Давайте разберемся:

1. Сначала смотрим общий граф:

   ```bash
   git log --graph --oneline --decorate --all
   ```

2. Находим по сообщению или хешу нужный коммит.
3. Смотрим, на какую ветку указывает этот коммит (например, feature/experiment).
4. Видим, что ветка так и не была слита в main.

Графически это будет выглядеть как отдельная «веточка», которая не доходит до main. Так вы быстро понимаете, что нужно сделать merge или rebase, а не искать загадочную «пропажу» внутри main.

### Понимание влияния rebase на историю

Допустим, вы сделали rebase feature на main:

```bash
git checkout feature
git rebase main
```

Теперь вы хотите понять, что изменилось. Сравним граф до и после.

До rebase:

```text
* c3c3c3c (feature) New feature part 2
* b2b2b2b New feature part 1
| * aaaa111 (main) Some change in main
|/  
* 9999999 Common base
```

После rebase:

```text
* d4d4d4d (feature) New feature part 2
* e3e3e3e New feature part 1
* aaaa111 (main) Some change in main
* 9999999 Common base
```

Как видите, ветка feature теперь «сидит» поверх main, без явного ответвления. Старые коммиты b2b2b2b и c3c3c3c заменены новыми e3e3e3e и d4d4d4d, но содержательно изменения совпадают.

Граф позволяет это буквально увидеть глазами.

### Быстрый просмотр истории для код-ревью

Перед ревью часто хочется посмотреть изменения по конкретной ветке:

```bash
git log --graph --oneline main..feature
```

Так вы увидите:

- только те коммиты, которые добавляет ветка feature;
- их порядок;
- отсутствие в этом списке «лишних» merge-коммитов из main (если вы аккуратно делали rebase).

Это особенно удобно, когда вы ревьюите чужую ветку и хотите понять общий контекст.

## Практические советы по работе с git log --graph

### Используйте alias, а не длинные команды

Если вы вызывали одну и ту же комбинацию флагов больше трёх раз — это хороший сигнал оформить ее в алиас. Так вы:

- уменьшите количество опечаток;
- сделаете команды короче и понятнее;
- сможете стандартизировать подход в команде (все используют одинаковый формат вывода).

### Не бойтесь --all, но фильтруйте при необходимости

--all дает полную картину по репозиторию, но в больших проектах вывод может быть очень масштабным. В таких случаях удобно:

- ограничивать число коммитов флагом -n;
- фильтровать по ветке или диапазону;
- использовать grep и другие фильтры.

Например:

```bash
git log --graph --oneline --decorate --all -50
```

Покажет только 50 последних коммитов по всем веткам.

### Запоминайте визуальные паттерны

Со временем вы начнете узнавать по графу разные «паттерны»:

- «ёлочка» — много коротких feature-веток, которые быстро сливаются в main;
- «длинная параллельная ветка» — отдельная линия разработчика или долгий эксперимент;
- «запутанная паутина merge» — признаки того, что слишком часто делали merge вместо аккуратного rebase.

Это помогает быстро оценить состояние репозитория и культуру работы с ветками в команде.

### Комбинируйте с другими командами Git

git log --graph — это не отдельный инструмент, а часть «набора» Git. Вы можете:

- сначала посмотреть граф;
- затем перейти к git show конкретного коммита;
- или к git diff между двумя точками;
- или к git blame по файлу, если нужно понять, кто внес изменения.

Например:

```bash
git log --graph --oneline --decorate
# Находим нужный хеш, допустим 9f8e7d6

git show 9f8e7d6
# Смотрим подробности этого коммита
```

Вместе эти команды дают вам отличный инструмент для анализа истории.

## Заключение

Графический просмотр истории с помощью git log --graph — это простой, но очень мощный инструмент. Он не требует установки дополнительных программ, работает в любом терминале и дает наглядное представление о структуре репозитория.

Вы можете:

- видеть ветвления, слияния и точки разветвления;
- понимать, какие ветки продолжаются, а какие уже слиты;
- отслеживать влияние rebase и merge на историю;
- быстро находить «забытые» ветки и коммиты.

Комбинируя --graph с флагами --oneline, --decorate, --all, а также с фильтрацией по веткам, авторам, файлам и диапазонам, вы получаете гибкий инструмент, который легко подстроить под свой стиль работы.

Настроив несколько удобных alias (например, git lg, git lga), вы сможете пользоваться графическим логом постоянно, почти не задумываясь о длинных командах. Со временем чтение таких графов становится привычным, и вы начнете гораздо лучше понимать историю своего кода и структуру командной разработки.

## Частозадаваемые технические вопросы по теме и ответы

### Как сделать так, чтобы git log --graph всегда показывал цветной вывод

Цвет сильно облегчает чтение графа. Вы можете включить цветной лог по умолчанию:

```bash
git config --global color.ui auto
git config --global color.log always
```

Комментарии:

```bash
git config --global color.ui auto   # Включаем цвета для большинства команд
git config --global color.log always # Лог всегда в цвете, если терминал поддерживает
```

После этого git log --graph будет подсвечивать ветки, хеши и сообщения.

### Как настроить свой формат alias с цветами для git log --graph

Вы можете использовать встроенные плейсхолдеры цветов:

```bash
git config --global alias.lgc "log --graph --pretty=format:'%Cred%h%Creset %Cblue%an%Creset %Cgreen%ad%Creset %C(yellow)%d%Creset %s' --date=short"
```

Комментарии:

```bash
# %Cred ... %Creset - красный цвет
# %Cblue - синий
# %Cgreen - зеленый
# %C(yellow) - желтый
```

Теперь git lgc будет показывать красиво оформленный цветной лог.

### Почему git log --graph показывает слишком много «мусорных» веток и как их скрыть

Часто --all отображает старые или служебные ветки. Можно ограничить список:

1. Не использовать --all, а явно указывать интересующие ветки:

   ```bash
   git log --graph --oneline --decorate main develop
   ```

2. Для локального «скрытия» удалённых веток, которые уже удалены на сервере, выполните:

   ```bash
   git fetch --prune
   ```

Комментарии:

```bash
git fetch --prune
# Удаляет локальные ссылки на те удаленные ветки
# которые уже были удалены на сервере
```

### Как показать граф только для коммитов после определенной даты

Используйте фильтр по дате:

```bash
git log --graph --oneline --since="2024-01-01"
```

Или более гибко:

```bash
git log --graph --oneline --since="2 weeks ago"
```

Комментарии:

```bash
--since="2024-01-01"     # Все коммиты начиная с указанной даты
--since="2 weeks ago"    # Все коммиты за последние две недели
```

### Как вывести граф в файл и потом просматривать его

Вы можете перенаправить вывод в текстовый файл:

```bash
git log --graph --oneline --decorate --all > history.txt
```

Комментарии:

```bash
# Сохраняем граф истории в файл history.txt
# Потом можно открыть его в любом текстовом редакторе
# или переслать коллегам для анализа истории
```