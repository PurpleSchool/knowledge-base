---
metaTitle: Vue DevTools - полный разбор инструментов разработчика для Vue
metaDescription: Подробное руководство по Vue DevTools - установка настройка и практическое использование для отладки компонентов хранилища и производительности
author: Олег Марков
title: Vue DevTools - как эффективно отлаживать приложения на Vue
preview: Узнайте как использовать Vue DevTools - от базовой навигации по дереву компонентов до профилирования производительности и анализа Pinia Vuex и событий
---

## Введение

Vue DevTools — это официальный набор инструментов разработчика для Vue, который встраивается в браузер и помогает вам разбираться в том, что происходит внутри приложения. С его помощью вы можете:

- смотреть дерево компонентов и их пропсы;
- отслеживать состояние (data, computed, refs, reactive-объекты);
- наблюдать за событиями и эмитами;
- анализировать хранилище (Vuex, Pinia);
- профилировать производительность и время рендера;
- отслеживать роутинг и навигацию.

Смотрите, я покажу вам, как Vue DevTools можно превратить в постоянный «монитор» состояния вашего приложения, а не просто в инструмент для редкой отладки.

Давайте последовательно разберем установку, основные панели, типичные сценарии использования и несколько менее очевидных возможностей, которые часто остаются незамеченными.

## Установка и первые шаги

### Варианты установки

Сейчас Vue DevTools можно использовать в нескольких вариантах:

1. Расширение для браузера:
   - Chrome / Chromium-браузеры (Chrome Web Store)
   - Firefox (Firefox Add-ons)

2. Стационарное (standalone) приложение:
   - Отдельное ডেস্কтоп-приложение, которое подключается к вашему приложению через WebSocket.
   - Удобно, если у вас:
     - мобильное приложение на WebView;
     - Electron;
     - необычная окружение, где расширение работает нестабильно.

3. Встроенный девтул в Vite / Nuxt DevTools (для некоторых шаблонов):
   - В браузере открывается отдельная вкладка с инструментами, интегрированными в dev-сервер.

### Как установить расширение

Для большинства случаев вам будет достаточно браузерного расширения.

#### Chrome / Edge / Brave

1. Откройте магазин Chrome Web Store.
2. Найдите Vue.js devtools.
3. Установите расширение.
4. Перезапустите браузер (иногда это необходимо, чтобы вкладка появилась в DevTools).

#### Firefox

1. Откройте Firefox Add-ons.
2. Найдите Vue.js devtools.
3. Установите и включите дополнение.

После установки вы увидите новую вкладку в инструментах разработчика браузера: Vue или Vue Devtools. Иногда она прячется под стрелкой с дополнительными вкладками.

### Когда приложение «не видит» Vue DevTools

Бывает, вы открываете DevTools, а вкладки Vue нет, хотя расширение установлено. Давайте разберемся, что проверить:

1. Приложение действительно на Vue?
   - Убедитесь, что на странице есть Vue-приложение (например, приложение на React не появится в Vue DevTools).

2. Версия Vue:
   - Для Vue 2 и Vue 3 используются разные режимы подключения, но современные версии DevTools поддерживают обе.
   - Если у вас очень старая версия Vue 2, возможна несовместимость.

3. Режим продакшена:
   - Vue DevTools по умолчанию не активируется в production-сборке (особенно это актуально для Vue 2).
   - Для Vue 3 обычно тоже рекомендуется работать в dev-сборке, чтобы получить максимум информации.

4. Если у вас Vite / Nuxt:
   - Убедитесь, что dev-сервер запущен в режиме разработки.
   - Для Nuxt 3 часто удобнее использовать встроенный Nuxt DevTools: там Vue DevTools уже интегрирован.

Если приложение настолько минималистично, что на момент открытия страницы Vue еще не инициализировался (например, динамический импорт), попробуйте перезагрузить страницу, уже имея открытый Vue DevTools.

## Обзор интерфейса Vue DevTools

Когда Vue DevTools «подцепился» к странице, вы увидите несколько основных вкладок. Обычно это:

- Components (Компоненты)
- Pinia или Vuex (в зависимости от используемого хранилища)
- Router (если используется vue-router)
- Timeline или Events (для событий и измерения времени)
- Performance (в некоторых версиях и конфигурациях)

Давайте подробно пройдемся по ключевым.

## Панель Components — сердце Vue DevTools

### Дерево компонентов

Вкладка Components показывает древовидную структуру компонентов вашего приложения. Это практически «карта» того, как сейчас выглядит ваш интерфейс.

Вы увидите:

- корневой компонент (обычно `App`);
- дочерние компоненты;
- вложенность, которая соответствует тому, как они отрисованы на странице.

Смотрите, я покажу вам, что полезно сразу настроить:

- поисковая строка: вы можете найти компонент по имени (например, `UserCard`);
- фильтр: можно скрывать служебные компоненты (например, `<KeepAlive>` или `<Transition>`), чтобы дерево было чище.

### Просмотр пропсов и состояния

Когда вы кликаете по конкретному компоненту в дереве слева, справа открывается панель с его состоянием:

- Props
- Data
- Computed
- Refs
- Inject / Provide
- Emits (в новых версиях)
- Hooks (жизненный цикл; иногда отображается как список вызванных хуков)

Давайте разберемся на примере простого компонента.

#### Пример компонента

Предположим, у вас есть компонент:

```vue
<script setup>
// Здесь мы импортируем необходимые функции из Vue
import { ref, computed } from 'vue'

// Здесь мы объявляем пропс, который приходит от родителя
const props = defineProps({
  initialCount: {
    type: Number,
    default: 0,
  },
})

// Локальное состояние счетчика
const count = ref(props.initialCount)

// Вычисляемое свойство на основе локального состояния
const doubled = computed(() => count.value * 2)

// Метод, который обновляет состояние
function increment() {
  count.value++
}
</script>

<template>
  <div>
    <p>Count: {{ count }}</p>
    <p>Doubled: {{ doubled }}</p>
    <button @click="increment">+</button>
  </div>
</template>
```

Как это будет видно в Vue DevTools:

- В дереве компонентов вы выберете этот компонент (например, `Counter`).
- В блоке Props увидите `initialCount` и его значение.
- В блоке Data/Refs — `count`.
- В блоке Computed — `doubled`.

Обратите внимание, как удобно, что вы можете:

- смотреть текущее значение;
- изменять его прямо из DevTools (двойной клик по значению или иконка редактирования).

### Редактирование состояния прямо в DevTools

Вы можете изменять значения:

- props (если родитель их не перезаписывает каждый рендер);
- data / refs;
- значения внутри реактивных объектов.

Например, если `count` сейчас равен 5, вы можете вручную поменять его на 100 и сразу увидеть, как изменился интерфейс.

Это особенно полезно, когда вы:

- воспроизводите сложные сценарии;
- тестируете крайние случаи (например, очень большие числа или пустые значения);
- проверяете, как связано между собой несколько computed-свойств.

### Просмотр и отладка provide/inject

Если вы используете механизм provide / inject, Vue DevTools показывают:

- что компонент получил через inject;
- иногда (в зависимости от версии и структуры) можно проследить, кто был источником provide.

Например:

```ts
// Здесь мы определяем ключ для provide/inject
const ThemeSymbol = Symbol('theme')

// Родительский компонент
provide(ThemeSymbol, 'dark')

// Дочерний компонент
const theme = inject(ThemeSymbol, 'light') // запасное значение
```

В DevTools вы увидите, что в дочернем компоненте значение `theme` равно `dark`. Это помогает проверять, что вы действительно получили то, что ожидали, особенно в сложной иерархии компонентов.

## Просмотр и отладка событий (emits)

Компоненты во Vue общаются с родителями через события, которые вы вызываете внутри дочернего компонента.

### Где смотреть события

В современных версиях Vue DevTools есть несколько мест, где можно увидеть события:

1. Внутри конкретного компонента:
   - список `Emits` (определенные события);
   - иногда — история вызовов (в Timeline или Events-панели).

2. На вкладке Timeline / Events:
   - последовательность срабатываний событий, с временными метками.

Давайте посмотрим, как это выглядит на примере.

#### Пример компонента с событиями

```vue
<script setup>
// Определяем, какие события может эмитить компонент
const emit = defineEmits(['update:modelValue', 'submit'])

// Метод, который эмитит событие изменения значения
function onInputChange(value) {
  // Сообщаем родителю о новом значении
  emit('update:modelValue', value)
}

// Метод, который эмитит событие отправки
function onSubmit() {
  // Сообщаем родителю, что форма отправлена
  emit('submit')
}
</script>

<template>
  <div>
    <input
      type="text"
      @input="onInputChange($event.target.value)"
    />
    <button @click="onSubmit">Send</button>
  </div>
</template>
```

Когда вы будете взаимодействовать с этим компонентом:

- в панели компонента могут отобразиться события, которые он эмитит;
- в Timeline вы увидите последовательность:
  - `update:modelValue` (с payload — введенным текстом);
  - `submit` при клике на кнопку.

Это очень удобно, когда «ничего не происходит» в родителе: вы можете проверить, эмитится ли событие вообще, и с какими данными.

## Работа с состоянием: Vuex и Pinia

Vue DevTools умеют глубоко интегрироваться с хранилищами:

- Vuex (для проектов на Vue 2 и части проектов на Vue 3);
- Pinia (рекомендуемое хранилище для Vue 3).

Теперь вы увидите, как DevTools превращаются в настоящий time-travel debugger.

### Vuex: мутации и действия

Если вы используете Vuex, во вкладке Vuex (или отдельной вкладке Store) вы увидите:

- текущее состояние (state) дерева;
- список зарегистрированных модулей;
- историю мутаций;
- в некоторых режимах — действия (actions).

Покажу вам, как это реализовано на практике.

#### Пример Vuex-хранилища

```js
// Здесь мы создаем хранилище Vuex
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export const store = new Vuex.Store({
  state: {
    count: 0,          // Глобальное состояние счетчика
  },
  mutations: {
    increment(state) {
      // Мутация, которая увеличивает счетчик
      state.count++
    },
    setCount(state, value) {
      // Мутация, которая устанавливает конкретное значение
      state.count = value
    },
  },
  actions: {
    asyncIncrement({ commit }) {
      // Асинхронное действие, которое через таймер вызывает мутацию
      setTimeout(() => {
        commit('increment')
      }, 1000)
    },
  },
})
```

В Vue DevTools:

- во вкладке Vuex вы увидите `state.count`;
- при каждом `commit('increment')` в истории появится запись:
  - тип: `increment`;
  - новые и старые значения.

Вы можете:

- «перематывать» состояние назад, выбирая предыдущие мутации;
- смотреть, какие значения были до и после.

Это помогает воспроизводить баги: вы можете повторить последовательность действий и увидеть, на каком шаге состояние «сломалось».

### Pinia: state, getters и actions

Pinia гораздо теснее интегрирован с Vue 3 и Composition API. DevTools для Pinia удобнее и нагляднее.

#### Пример Pinia-стора

```ts
// Здесь мы создаем стор Pinia
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0,              // Состояние счетчика
  }),
  getters: {
    // Вычисляемое свойство на основе state
    doubled: (state) => state.count * 2,
  },
  actions: {
    increment() {
      // Синхронное действие, меняющее состояние
      this.count++
    },
    async incrementAfterDelay() {
      // Асинхронное действие, которое меняет состояние позднее
      await new Promise((resolve) => setTimeout(resolve, 1000))
      this.count++
    },
  },
})
```

В DevTools появляется вкладка Pinia, где вы увидите:

- список стооров (по ID, здесь `counter`);
- состояние (state);
- getters;
- действия (actions) с историей их вызова (если включен лог действий).

Давайте посмотрим, что происходит в следующем сценарии:

1. Вы вызываете `increment()` несколько раз.
2. Потом `incrementAfterDelay()`.

В DevTools:

- состояние `count` будет изменяться пошагово;
- в истории действий вы увидите последовательность `counter/increment`, `counter/incrementAfterDelay`;
- вы можете посмотреть payload (если вы передавали аргументы в actions).

Это очень полезно, когда:

- вы не уверены, какой стор вообще меняет значение;
- где-то в actions вызывается несколько мутаций, и вы хотите понять порядок.

### Редактирование состояния Pinia прямо в DevTools

Одно из больших удобств Pinia — вы можете напрямую менять state стора внутри DevTools.

Например:

- изменить `count` с 5 на 999;
- сразу увидеть, как меняются все зависимые computed’ы и интерфейс.

Если включен плагин Pinia с синхронизацией через DevTools, вы можете даже записывать и воспроизводить последовательности изменений (похожий на time-travel debugging Vuex, но проще).

## Панель Router — навигация и история

Если вы используете vue-router (v3 или v4), Vue DevTools покажут:

- текущий маршрут (path, params, query);
- историю навигации;
- информацию о переходах (откуда — куда).

Давайте разберемся на примере простой конфигурации.

```ts
// Здесь мы настраиваем vue-router
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  { path: '/', name: 'home', component: () => import('./Home.vue') },
  { path: '/user/:id', name: 'user', component: () => import('./User.vue') },
]

export const router = createRouter({
  history: createWebHistory(),
  routes,
})
```

В DevTools на вкладке Router вы увидите:

- текущий маршрут, например:
  - name: `user`
  - path: `/user/42`
  - params: `{ id: "42" }`
  - query: `{ page: "2" }` (если есть)
- предыдущий маршрут, откуда мы пришли;
- последовательность переходов (если вы переходили по нескольким страницам).

Это помогает отладить:

- неправильные параметры маршрута;
- неожиданные query-параметры;
- циклическую навигацию (если маршрут постоянно редиректит).

Вы можете даже программно инициировать переходы и сразу видеть, как они отражаются в DevTools.

## Панель Timeline и отладка производительности

Вкладка Timeline (или Events) показывает последовательность различных событий:

- рендеры компонентов;
- обновления состояния;
- эмит-события;
- действия хранилища (Vuex/Pinia);
- навигацию роутера.

Теперь вы увидите, какие части приложения действительно перерисовываются, а какие остаются неизменными.

### Типовой сценарий использования Timeline

Представьте, что при вводе текста в поле у вас «лагует» весь интерфейс. Вы хотите понять:

- какие компоненты обновляются;
- сколько времени занимают рендеры.

Шаги работы с Timeline:

1. Откройте вкладку Timeline.
2. Включите нужные фильтры (например, Render, Component updates).
3. Выполните проблемное действие (введите текст).
4. Посмотрите, какие компоненты обновились и сколько времени это заняло.

Вы можете обнаружить, что:

- вместе с полем ввода обновляется огромный список элементов;
- при каждом вводе текста ререндерится компонент, который не должен зависеть от этого состояния.

Обратите внимание, как Timeline помогает находить такие неочевидные связи между состоянием и рендером.

## Работа с несколькими экземплярами приложений

Иногда на одной странице может быть несколько Vue-приложений:

- встраиваемые виджеты;
- микрофронтенды;
- несколько независимых корневых приложений.

Vue DevTools позволяет переключаться между ними. В панели обычно есть селектор приложения (dropdown), в котором вы можете выбрать:

- App 1 — например, основной SPA;
- App 2 — виджет комментариев;
- App 3 — админская панель, встроенная в страницу.

Это важно, когда вы:

- отлаживаете модуль, встроенный в чужую страницу;
- работаете над системой с микрофронтендами, где каждый модуль — собственное Vue-приложение.

## Работа с Composition API и script setup

В приложениях на Vue 3 с Composition API может казаться, что все состояние «спрятано» внутри `setup`. Vue DevTools умеет корректно отображать:

- reactive-объекты;
- ref;
- computed;
- методы и функции.

Смотрите, я покажу вам, как это выглядит на примере чуть более сложного компонента.

```vue
<script setup>
// Здесь мы импортируем функции реактивности
import { reactive, ref, computed } from 'vue'

// Локальное состояние формы, обернутое в reactive
const form = reactive({
  firstName: '',
  lastName: '',
})

// Отдельный ref для статуса загрузки
const isSubmitting = ref(false)

// Вычисляемое свойство, зависящее от нескольких полей
const fullName = computed(() => {
  // Склеиваем имя и фамилию в одну строку
  return `${form.firstName} ${form.lastName}`.trim()
})

// Асинхронный метод отправки формы
async function submitForm() {
  // Включаем индикатор загрузки
  isSubmitting.value = true
  try {
    // Здесь могла бы быть отправка на сервер
    await new Promise((resolve) => setTimeout(resolve, 500))
  } finally {
    // В любом случае выключаем индикатор загрузки
    isSubmitting.value = false
  }
}
</script>

<template>
  <form @submit.prevent="submitForm">
    <input v-model="form.firstName" placeholder="First name" />
    <input v-model="form.lastName" placeholder="Last name" />
    <p>Full name: {{ fullName }}</p>
    <button type="submit" :disabled="isSubmitting">
      Save
    </button>
  </form>
</template>
```

В DevTools:

- в блоке Refs вы увидите `isSubmitting`;
- в блоке Computed — `fullName`;
- в блоке Data/State — `form` как объект с полями `firstName` и `lastName`.

Вы можете менять значения прямо в DevTools:

- поменять `form.firstName` и сразу увидеть обновление `fullName`;
- установить `isSubmitting` в `true`, чтобы проверить, как ведет себя интерфейс.

## Инспекция элементов в DOM и переход к компоненту

Vue DevTools позволяет связать визуальный элемент на странице с его компонентом.

Обычно есть иконка «Inspect DOM» (лупа или курсор). Когда вы ее активируете:

1. Наводите мышку на элемент в окне браузера.
2. DevTools подсвечивает соответствующий компонент в дереве Components.
3. Вы можете кликнуть — и сразу перейти к этому компоненту.

Это особенно удобно, когда:

- компонент глубоко вложен и вы не хотите вручную искать его в дереве;
- вы работаете над версткой и хотите быстро найти, где находится логика этого блока.

Обратите внимание, как этот инструмент экономит время: вместо долгих поисков по дереву вы просто кликаете по нужному элементу на странице.

## Настройки и полезные опции Vue DevTools

В Vue DevTools есть настройки, которые влияют на поведение:

- Автоподключение к приложениям:
  - автоматически выбирать первое найденное приложение Vue;
  - или ждать, пока вы сами выберете.

- Отображение имен компонентов:
  - использовать `name` из компонента;
  - отображать «ничейные» компоненты (анонимные) с генерацией имени.

- Скрытие или показ служебных компонентов:
  - `KeepAlive`, `Transition`, `Suspense` и другие.

- Экспорт / импорт сессии:
  - в некоторых версиях можно экспортировать историю состояния или записанный профайл рендера.

Если вы работаете над большим приложением, имеет смысл потратить несколько минут и настроить DevTools под себя: убрать лишнее, включить нужные панели и логирование.

## Практические сценарии использования Vue DevTools

Теперь давайте сосредоточимся на типичных задачах, которые вы будете решать почти каждый день.

### Сценарий 1: «Почему у меня не обновляется интерфейс?»

Шаги отладки:

1. Откройте панель Components.
2. Найдите нужный компонент (через поиск по имени или инспектор).
3. Посмотрите:
   - состояние (data/refs);
   - props;
   - computed.

Проверьте:

- действительно ли меняется состояние, от которого зависит шаблон;
- не кешируется ли computed, если вы ожидаете пересчет;
- не приходит ли неправильный prop от родителя.

Иногда бывает, что вы меняете не тот объект или не то поле, которое связано с шаблоном. Vue DevTools помогают визуально увидеть, какие именно поля меняются.

### Сценарий 2: «Почему родитель не получает событие?»

Шаги:

1. Откройте компонент-источник события.
2. Проверьте, какие события он декларирует (Emits).
3. Включите Timeline / Events.
4. Выполните действие, которое должно эмитить событие.

Если событие не появляется:

- значит, оно вообще не эмитится (ошибка в коде, другое имя события);
- вы можете добавить лог прямо в код, но часто достаточно увидеть отсутствие события в DevTools.

Если событие есть в DevTools, но родитель не реагирует:

- возможно, вы слушаете другое имя события;
- или используете неверный синтаксис (например, не учитываете `update:modelValue` и `v-model`).

### Сценарий 3: «Почему состояние в хранилище не то, что я ожидаю?»

Для Vuex:

1. Откройте вкладку Vuex.
2. Посмотрите историю мутаций.
3. Выберите конкретную мутацию и изучите:
   - old state;
   - new state.

Вы можете:

- перематывать состояние назад;
- смотреть, какая именно мутация изменила нужное поле.

Для Pinia:

1. Откройте вкладку Pinia.
2. Найдите нужный стор.
3. Смотрите историю действий (если включено логирование).
4. Изучите текущее значение state и getters.

Иногда оказывается, что:

- изменение было выполнено в неожиданном месте;
- одно действие перезаписало результат другого.

Vue DevTools здесь играет роль «черного ящика», который фиксирует все изменения.

### Сценарий 4: «Оптимизация производительности»

Шаги:

1. Откройте панель Performance / Timeline.
2. Включите запись (Record).
3. Выполните пользовательский сценарий:
   - скролл;
   - ввод текста;
   - открытие модального окна.
4. Остановите запись.
5. Посмотрите:
   - какие компоненты рендерятся чаще всего;
   - где возникают «длинные» операции.

Если вы видите, что при вводе в одном поле обновляется десяток несвязанных компонентов, это повод:

- перепроверить, не делитесь ли вы лишним состоянием через provide/inject или глобальный стор;
- оптимизировать вычисляемые свойства;
- использовать мемоизацию и разделение компонентов.

## Заключение

Vue DevTools — это не просто «еще одна вкладка» в браузере, а полноценный инструмент управления состоянием и поведением Vue-приложений. Когда вы начинаете использовать его регулярно, многие задачи по отладке и анализу перестают быть «магией» и превращаются в последовательность понятных шагов:

- посмотреть, как устроено дерево компонентов;
- проверить, какие значения сейчас в props, data, computed;
- увидеть историю действий и мутаций в хранилище;
- отследить события и навигацию;
- замерить, что именно замедляет интерфейс.

Здесь важно не только знать, какие панели существуют, но и вырабатывать привычку:

- всегда начинать поиск проблемы с просмотра реального состояния в DevTools;
- не полагаться только на `console.log`, а использовать специализированные вкладки для хранилища, роутера и компонентов;
- использовать инспектор DOM, чтобы быстрее находить нужный компонент.

Так вы будете гораздо увереннее в том, что происходит в вашем приложении, и сможете быстрее находить и устранять проблемы даже в сложных проектах.

## Частозадаваемые технические вопросы по Vue DevTools

### Как подключить Vue DevTools к приложению на мобильном устройстве (WebView, мобильный браузер)?

1. Установите standalone-версию Vue DevTools (через npm или официальный репозиторий).
2. Запустите ее локально (обычно это десктопное приложение или dev-сервер).
3. Настройте приложение так, чтобы:
   - оно подключалось к DevTools по указанному хосту и порту (часто `localhost:8098`, но для мобильного устройства это будет IP вашей машины в сети).
4. Откройте приложение на мобильном устройстве в одной сети с компьютером.
5. Убедитесь, что мобильное устройство может достучаться до IP компьютера и порта DevTools.

### Почему Vue DevTools не работает в production-сборке?

1. В большинстве конфигураций Vue DevTools отключается в продакшене ради безопасности и производительности.
2. Для отладки production-проблем:
   - соберите dev-версию приложения с теми же данными и окружением;
   - используйте Vue DevTools там.
3. Если вам критично включать DevTools в продакшене:
   - для Vue 2 была опция `Vue.config.devtools = true`;
   - для Vue 3 используйте рекомендованные в официальной документации подходы и учитывайте риски.

### Как отлаживать серверный рендеринг (SSR) с помощью Vue DevTools?

1. SSR отрисовывает HTML на сервере, но гидратация и дальнейшее поведение происходят в браузере.
2. Vue DevTools работают после того, как приложение «гидратировалось» на клиенте.
3. Для отладки:
   - запустите SSR-приложение в dev-режиме;
   - откройте страницу в браузере;
   - дождитесь завершения гидратации;
   - используйте Vue DevTools как обычно.
4. Проблемы именно серверного рендера (до гидратации) удобнее отлаживать через логи сервера и тесты.

### Как включить логирование Pinia-экшенов в Vue DevTools?

1. Убедитесь, что используете актуальную версию Pinia и Vue DevTools.
2. При создании стора:
   - по умолчанию DevTools интеграция включена;
   - если вы отключали ее, верните настройки по умолчанию или явно включите `devtools: true` в опциях стора или приложения.
3. В DevTools во вкладке Pinia включите отображение историй действий (есть соответствующая настройка/фильтр).
4. После этого каждый вызов action будет отображаться с именем стора, названием экшена и аргументами.

### Как отладить компоненты, написанные на TypeScript, через Vue DevTools?

1. TypeScript компилируется в обычный JavaScript, Vue DevTools работают уже с результатом компиляции.
2. Убедитесь, что:
   - вы сохраняете корректные имена компонентов (`name` или имена файлов, особенно при `script setup`);
   - sourcemaps включены в конфигурации сборки (Vite, Webpack).
3. В DevTools вы увидите компоненты и состояние так же, как в JavaScript-проектах.
4. Для соответствия между кодом в редакторе и компонентом в DevTools ориентируйтесь на:
   - имя компонента;
   - путь до файла (часто DevTools его показывает);
   - структуру дерева компонентов, совпадающую с вашей архитектурой.