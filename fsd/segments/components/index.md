---
metaTitle: Сегмент components - архитектура и использование компонента components-segment
metaDescription: Подробное руководство по сегменту components - объяснение что такое components-segment как он работает и как использовать его в проектах
author: Олег Марков
title: Сегмент components - компонент components-segment в современных интерфейсах
preview: Разбор сегмента components и компонента components-segment - структура назначение основные сценарии использования и практические примеры интеграции
---

## Введение

Сегмент `components` и конкретный компонент `components-segment` часто встречаются в современных дизайн-системах и UI-библиотеках. Обычно под ним понимают модуль, который отвечает за отображение и управление "сегментированным" интерфейсом: вкладками, фильтрами, переключателями режимов, навигационными группами.

Если упростить, `components-segment` — это компонент, который разбивает контент или набор опций на логические сегменты и позволяет пользователю быстро переключаться между ними. С его помощью удобно:

- переключать режимы отображения (список / таблица / карточки);
- управлять фильтрами (например, "Все", "Активные", "Архив");
- организовывать компактную навигацию внутри блока;
- строить сегментированные контролы, похожие на переключатель вкладок.

Давайте разберем, как обычно устроен `components-segment`, какие возможности он предоставляет, и посмотрим на практические примеры интеграции в интерфейс.

## Общая концепция сегмента components и компонента components-segment

### Что такое сегмент components

Сегмент `components` — это логический раздел в кодовой базе или репозитории, в котором хранятся переиспользуемые UI-компоненты. Часто он является частью общей дизайн-системы или библиотеки интерфейсных компонентов.

Как правило, в сегменте `components`:

- каждый компонент вынесен в отдельную директорию;
- компоненты независимы друг от друга, но могут использовать общие утилиты и базовые элементы;
- все компоненты следуют единым правилам: соглашения об именовании, API, стилизации, тестировании.

Компонент `components-segment` — один из таких элементов. Его задача — дать единый стандарт для "сегментированных" интерфейсов.

### Роль компонента components-segment

`components-segment` обычно решает следующие задачи:

- Группирует связанные опции или состояния.
- Отображает их в виде горизонтального или вертикального списка сегментов.
- Управляет активным сегментом (внутри себя или через внешний стейт).
- Триггерит события при переключении сегмента.
- Обеспечивает единый стиль и поведение для всех сегментированных контролов в системе.

Смотрите, я покажу вам типичный сценарий: у вас есть страницы "Сегодня", "Неделя" и "Месяц" в календаре. Вы могли бы сделать три кнопки, но куда лучше — единый компонент `components-segment`, который:

- отрисует три сегмента;
- подсветит текущий;
- отправит событие при смене;
- обеспечит доступность, фокус и консистентную стилизацию.

## Базовый API компонента components-segment

Давайте разберемся, как обычно выглядит API компонента на примере условной реализации на React. Даже если вы используете другую технологию, структура будет похожей.

### Основные пропсы

Чаще всего `components-segment` принимает такие параметры:

- `value` — текущий активный сегмент (контролируемый режим).
- `defaultValue` — начальный активный сегмент (неконтролируемый режим).
- `onChange` — колбэк, вызываемый при смене сегмента.
- `options` или `items` — список сегментов для отображения.
- `size` — размер компонента (small, medium, large).
- `disabled` — отключение всего компонента.
- `multiple` (опционально) — поддержка множественного выбора.
- `orientation` — направление (горизонтальное или вертикальное).
- `fullWidth` — растянуть сегменты на всю ширину контейнера.

Пример декларативного использования:

```tsx
// Пример использования компонента components-segment
// Здесь мы создаем три сегмента и управляем активным снаружи

import { Segment } from 'components-segment';

function ViewSwitcher() {
  // Здесь мы храним текущее состояние выбранного сегмента
  const [mode, setMode] = useState<'list' | 'grid' | 'table'>('list');

  return (
    <Segment
      value={mode}                     // Текущий выбранный сегмент
      onChange={setMode}               // Колбэк при смене сегмента
      options={[
        { value: 'list', label: 'Список' },
        { value: 'grid', label: 'Сетка' },
        { value: 'table', label: 'Таблица' },
      ]}
      size="medium"                    // Размер компонента
      fullWidth                        // Займет всю доступную ширину
    />
  );
}
```

Как видите, компонент ведет себя как обычный контрол ввода, только вместо одного элемента он рендерит группу сегментов.

### Структура options

Список сегментов почти всегда представляет собой массив объектов. Давайте посмотрим детальнее:

```ts
// Описание типа опции сегмента
type SegmentOption = {
  value: string;              // Уникальное значение сегмента
  label: ReactNode;           // Подпись (может быть текстом или JSX)
  disabled?: boolean;         // Отключен ли конкретный сегмент
  icon?: ReactNode;           // Иконка слева или справа от текста
  tooltip?: string;           // Подсказка при наведении
  dataTestId?: string;        // Атрибут для тестов
};
```

Такой формат дает гибкость: вы можете добавить иконку, подсказку или отдельный атрибут для автотестов без изменения основного поведения.

Теперь вы увидите, как это выглядит в реальном примере:

```tsx
// Пример со списком опций и расширенными полями

const segmentOptions: SegmentOption[] = [
  {
    value: 'all',
    label: 'Все',
    icon: <AllIcon />,
  },
  {
    value: 'active',
    label: 'Активные',
    icon: <ActiveIcon />,
    tooltip: 'Только активные элементы', // Подсказка при наведении
  },
  {
    value: 'archived',
    label: 'Архив',
    disabled: true,                      // Сегмент недоступен для выбора
  },
];
```

## Контролируемый и неконтролируемый режимы

### Контролируемый режим (через value)

Контролируемый режим означает, что вы владеете состоянием компонента. `components-segment` в этом случае просто сообщает, что пользователь выбрал другой сегмент, а вы сами решаете, что с этим делать.

```tsx
// Контролируемый режим использования сегмента

function FilterSegment() {
  const [filter, setFilter] = useState<'all' | 'open' | 'closed'>('all');

  const handleChange = (nextValue: string) => {
    // Здесь вы можете выполнить дополнительные действия
    // Например, запросить новые данные с сервера
    setFilter(nextValue as typeof filter);
  };

  return (
    <Segment
      value={filter}               // Состояние контролируется снаружи
      onChange={handleChange}      // Обработчик выбора
      options={[
        { value: 'all', label: 'Все' },
        { value: 'open', label: 'Открытые' },
        { value: 'closed', label: 'Закрытые' },
      ]}
    />
  );
}
```

Обратите внимание, что в контролируемом режиме:

- без `onChange` компонент не сможет изменить значение;
- `value` всегда источник истины.

### Неконтролируемый режим (через defaultValue)

Если вам не нужен явный контроль состояния, можно использовать `defaultValue`. Тогда компонент будет сам хранить текущее значение внутри себя.

```tsx
// Неконтролируемый режим - компонент сам хранит активный сегмент

function SimpleSegment() {
  return (
    <Segment
      defaultValue="all"          // Начальное значение
      options={[
        { value: 'all', label: 'Все' },
        { value: 'fav', label: 'Избранные' },
      ]}
      onChange={(value) => {
        // Этот колбэк не обязателен, но полезен для логгирования
        console.log('Выбран сегмент', value);
      }}
    />
  );
}
```

Этот подход удобен для простых интерфейсов, где нет сложного состояния или синхронизации с URL.

## Стилизация и размеры компонента

### Предустановленные размеры

Чаще всего `components-segment` имеет несколько предустановленных размеров. Названия могут отличаться, но логика похожа:

- small — компактный;
- medium — стандартный;
- large — крупный.

Давайте посмотрим, как это выглядит:

```tsx
// Демонстрация разных размеров компонента

<Segment
  size="small"
  defaultValue="list"
  options={[
    { value: 'list', label: 'Список' },
    { value: 'grid', label: 'Сетка' },
  ]}
/>

<Segment
  size="medium"
  defaultValue="grid"
  options={[
    { value: 'list', label: 'Список' },
    { value: 'grid', label: 'Сетка' },
  ]}
/>

<Segment
  size="large"
  defaultValue="list"
  options={[
    { value: 'list', label: 'Список' },
    { value: 'grid', label: 'Сетка' },
  ]}
/>
```

Как видите, API остается одинаковым, меняется только визуальное оформление.

### Растягивание по ширине

Опция `fullWidth` делает сегменты равномерно распределенными по доступной ширине контейнера. Это удобно, когда `components-segment` — основной контрол в верхней части страницы или виджета.

```tsx
// Растягиваем сегменты по всей ширине контейнера

<Segment
  fullWidth                    // Все сегменты занимают полную ширину
  defaultValue="week"
  options={[
    { value: 'day', label: 'День' },
    { value: 'week', label: 'Неделя' },
    { value: 'month', label: 'Месяц' },
  ]}
/>
```

Если `fullWidth` отключен, ширина каждого сегмента определяется его содержимым.

### Кастомная стилизация

В реальных дизайн-системах часто доступен проп `className` или `classes`, чтобы вы могли аккуратно переопределять стили.

```tsx
// Кастомные классы для контейнера и элементов сегмента

<Segment
  value={mode}
  onChange={setMode}
  options={segmentOptions}
  className="view-mode-segment"              // Класс для корневого контейнера
  itemClassName="view-mode-segment__item"    // Класс для каждого сегмента
/>
```

Давайте разберемся, почему лучше использовать классы, а не инлайновые стили:

- классы проще переиспользовать;
- вы можете подключать тему (light/dark);
- изменения легче поддерживать и ревьюить в CSS/SCSS.

## Множественный выбор и специальные режимы

Иногда `components-segment` поддерживает не только одиночный выбор, но и множественный (как набор чекбоксов), или особые режимы работы. Это зависит от реализации, но общие принципы можно описать.

### Множественный выбор (multiple)

Предположим, у компонента есть проп `multiple`. Тогда он может возвращать массив значений.

```tsx
// Пример множественного выбора с помощью сегмента

function MultiFilterSegment() {
  const [selected, setSelected] = useState<string[]>(['all']);

  const handleChange = (values: string[]) => {
    // Здесь мы можем, например, обновить фильтр в сторе
    setSelected(values);
  };

  return (
    <Segment
      multiple                        // Включаем поддержку множественного выбора
      value={selected}                // Активные сегменты - массив
      onChange={handleChange}         // Колбэк получает массив значений
      options={[
        { value: 'all', label: 'Все' },
        { value: 'errors', label: 'Ошибки' },
        { value: 'warnings', label: 'Предупреждения' },
      ]}
    />
  );
}
```

Обратите внимание на два момента:

- тип значения меняется с `string` на `string[]`;
- логика обработчика должна ожидать массив.

### Режим выбора с обязательным значением

Некоторые реализации `components-segment` не позволяют снять выбор со всех сегментов. То есть всегда должен быть выбран хотя бы один. Это важно продумать, если вы ожидаете поведение, похожее на переключатель радио-кнопок.

Если же система поддерживает Сброс, то чаще всего он реализуется через специальный сегмент с value вроде `none` или отдельной кнопкой.

```tsx
// Сегмент с возможностью сброса через отдельную кнопку

function ResettableSegment() {
  const [value, setValue] = useState<string | null>('all');

  const handleReset = () => {
    setValue(null);                    // Сбрасываем выбранный сегмент
  };

  return (
    <>
      <Segment
        value={value ?? undefined}     // Если null - передаем undefined
        onChange={setValue}
        options={[
          { value: 'all', label: 'Все' },
          { value: 'fav', label: 'Избранные' },
        ]}
      />
      <button onClick={handleReset}>
        Сбросить фильтр
      </button>
    </>
  );
}
```

Здесь я размещаю пример, чтобы вам было проще увидеть общий паттерн: логика сброса вынесена за пределы компонента.

## Обработка событий и интеграция с бизнес-логикой

### Колбэк onChange

Событие `onChange` — основной способ интегрировать `components-segment` с логикой приложения. Через него вы:

- обновляете стейт;
- отправляете события в аналитики;
- грузите данные;
- меняете URL (query-параметры).

Давайте разберемся на примере:

```tsx
// Интеграция сегмента с загрузкой данных и аналитикой

function TicketsSegment() {
  const [status, setStatus] = useState('open');

  const handleChange = (nextStatus: string) => {
    // Обновляем локальное состояние
    setStatus(nextStatus);

    // Запрашиваем новые данные
    fetchTickets({ status: nextStatus });

    // Логируем событие в аналитику
    analytics.track('ticket_status_change', { status: nextStatus });
  };

  return (
    <Segment
      value={status}
      onChange={handleChange}
      options={[
        { value: 'open', label: 'Открытые' },
        { value: 'in_progress', label: 'В работе' },
        { value: 'done', label: 'Завершенные' },
      ]}
    />
  );
}
```

Как видите, `components-segment` выступает только триггером — бизнес-логика остается в вашем коде.

### Синхронизация с URL

Один из популярных сценариев — когда активный сегмент отражает состояние, записанное в адресной строке (например, `?view=list`).

```tsx
// Синхронизация сегмента с query-параметром URL

function ViewSegmentWithUrl() {
  const location = useLocation();          // Хук вашего роутера
  const navigate = useNavigate();

  const params = new URLSearchParams(location.search);
  const view = params.get('view') || 'list';

  const handleChange = (nextView: string) => {
    const nextParams = new URLSearchParams(location.search);
    nextParams.set('view', nextView);

    navigate({
      pathname: location.pathname,
      search: nextParams.toString(),
    });
  };

  return (
    <Segment
      value={view}
      onChange={handleChange}
      options={[
        { value: 'list', label: 'Список' },
        { value: 'board', label: 'Доска' },
      ]}
    />
  );
}
```

Обратите внимание, как этот фрагмент кода решает типичную задачу: состояние сегмента становится частью URL, а значит — легко шарится и сохраняется при перезагрузке.

## Доступность и управление с клавиатуры

### Роль и aria-атрибуты

Хорошая реализация `components-segment` учитывает требования доступности:

- использует правильные роли (`radiogroup`, `radio` или `tablist`, `tab`);
- выставляет `aria-pressed`, `aria-selected`, `aria-disabled`;
- корректно обрабатывает фокус.

Если вы делаете собственную реализацию, вот базовый набросок:

```tsx
// Упрощенный пример разметки сегментов с aria-атрибутами

function AccessibleSegment({ value, onChange, options }: Props) {
  return (
    <div role="radiogroup">
      {options.map(option => {
        const isActive = option.value === value;

        return (
          <button
            key={option.value}
            role="radio"                       // Сообщаем, что это радио-кнопка
            aria-checked={isActive}           // Активно ли значение
            aria-disabled={option.disabled}   // Недоступно ли значение
            disabled={option.disabled}
            onClick={() => !option.disabled && onChange(option.value)}
          >
            {option.label}
          </button>
        );
      })}
    </div>
  );
}
```

Этот пример не претендует на полноту, но задает базовый ориентир.

### Управление с клавиатуры

Пользователь должен иметь возможность:

- перейти на компонент с помощью Tab;
- переключать сегменты стрелками (влево/вправо или вверх/вниз);
- активировать сегмент клавишей Enter или Пробел.

Если библиотека, которую вы используете, уже решает эти задачи, вам достаточно следовать документации. Если вы реализуете поведение сами, важно не забыть о корректной обработке `onKeyDown`.

```tsx
// Обработка клавиатуры для переключения сегментов

const handleKeyDown = (event: KeyboardEvent<HTMLButtonElement>, index: number) => {
  if (event.key === 'ArrowRight') {
    // Переход к следующему сегменту
  }
  if (event.key === 'ArrowLeft') {
    // Переход к предыдущему сегменту
  }
};
```

## Паттерны использования в интерфейсе

### Сегмент как переключатель режимов отображения

Один из наиболее частых кейсов — смена вида списка: таблица, плитка, доска.

```tsx
// Переключатель режимов отображения задачи

function TaskViewSegment() {
  const [view, setView] = useState<'board' | 'list'>('board');

  return (
    <>
      <Segment
        value={view}
        onChange={setView}
        options={[
          { value: 'board', label: 'Доска', icon: <BoardIcon /> },
          { value: 'list', label: 'Список', icon: <ListIcon /> },
        ]}
      />

      {view === 'board' && (
        // Здесь мы рендерим представление в виде доски
        <BoardView />
      )}

      {view === 'list' && (
        // Здесь мы рендерим представление в виде списка
        <ListView />
      )}
    </>
  );
}
```

Давайте посмотрим, что происходит в этом примере:

- сегмент управляет только значением `view`;
- остальная логика рендера зависит от этого значения;
- компонент получается простым и предсказуемым.

### Сегмент как фильтр по статусу или типу

Еще один типовой сценарий — высокоуровневый фильтр по статусам.

```tsx
// Фильтр статусов задач с помощью сегмента

function StatusFilterSegment({ onFilterChange }: { onFilterChange: (status: string) => void }) {
  const [status, setStatus] = useState('all');

  const handleChange = (nextStatus: string) => {
    setStatus(nextStatus);
    onFilterChange(nextStatus);
  };

  return (
    <Segment
      value={status}
      onChange={handleChange}
      options={[
        { value: 'all', label: 'Все' },
        { value: 'open', label: 'Открытые' },
        { value: 'closed', label: 'Закрытые' },
      ]}
    />
  );
}
```

Покажу вам, как это реализовано на практике: компонент фильтра можно многократно переиспользовать на разных страницах, передавая свой `onFilterChange`.

### Сегмент как часть формы

В формах `components-segment` может заменять группу радио-кнопок.

```tsx
// Использование сегмента внутри формы

function SettingsForm() {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  const handleSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    // Здесь вы отправляете выбранную тему на сервер
    saveSettings({ theme });
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>Тема интерфейса</label>

      <Segment
        value={theme}
        onChange={value => setTheme(value as typeof theme)}
        options={[
          { value: 'light', label: 'Светлая' },
          { value: 'dark', label: 'Темная' },
        ]}
      />

      <button type="submit">Сохранить</button>
    </form>
  );
}
```

Как видите, `components-segment` встраивается в любую форму, где вам нужен выбор одного значения из нескольких.

## Архитектура и технические детали реализации

### Разделение на контейнер и элемент сегмента

Хорошая внутренняя реализация компонента обычно разделяет:

- родительский контейнер (Segment / SegmentGroup);
- дочерние элементы (SegmentItem).

Даже если снаружи вы работаете через `options`, внутри может быть примерно так:

```tsx
// Внутренняя архитектура компонента сегмента (упрощенная)

function Segment({ value, onChange, options }: Props) {
  return (
    <div className="segment">
      {options.map(option => (
        <SegmentItem
          key={option.value}
          isActive={option.value === value}
          disabled={option.disabled}
          onClick={() => onChange(option.value)}
        >
          {option.label}
        </SegmentItem>
      ))}
    </div>
  );
}

function SegmentItem({ isActive, disabled, onClick, children }: ItemProps) {
  const className = [
    'segment__item',
    isActive && 'segment__item--active',
    disabled && 'segment__item--disabled',
  ]
    .filter(Boolean)
    .join(' ');

  return (
    <button
      type="button"
      className={className}
      disabled={disabled}
      onClick={onClick}
    >
      {children}
    </button>
  );
}
```

Давайте разберемся, чем полезна такая архитектура:

- проще тестировать каждую часть отдельно;
- логика выделения и отключения сосредоточена в одном месте;
- можно добавлять дополнительные фичи (иконки, бейджи) без переписывания ядра.

### Обработка edge-кейсов

При реализации `components-segment` стоит учесть:

- что делать, если `value` не входит в список `options`;
- как вести себя, если пришел пустой массив `options`;
- что происходит, если `options` меняются динамически.

Часто в таких случаях:

- активное значение сбрасывается на первый доступный сегмент;
- компонент вообще не отображается, если нет опций;
- разработчик получает предупреждение (в dev-режиме).

## Типичные ошибки при использовании components-segment

### Ошибка 1: Непоследовательное управление состоянием

Проблема: одновременно использовать `value` и `defaultValue`.

```tsx
// Плохой пример - одновременное использование value и defaultValue

<Segment
  value={value}
  defaultValue="all"         // Лишнее поле, в контролируемом режиме не работает
  onChange={setValue}
  options={options}
/>
```

Решение:

- используйте либо контролируемый, либо неконтролируемый режим;
- не смешивайте `value` и `defaultValue`.

### Ошибка 2: Отсутствие onChange в контролируемом режиме

Проблема: передают `value`, но забывают `onChange`. Компонент становится "заблокированным": пользователь кликает, но ничего не меняется.

```tsx
// Плохой пример - нет onChange

<Segment
  value={value}
  options={options}
/>
```

Решение: всегда передавайте `onChange`, если управляете `value`.

### Ошибка 3: Несоответствие типов значения

Проблема: значение сегмента не совпадает по типу с ожидаемым типом состояния.

```tsx
// Опасный пример - несоответствие типов

const [view, setView] = useState<'list' | 'grid'>('list');

<Segment
  value={view}
  onChange={setView}              // Тип onChange: (value: 'list' | 'grid') => void
  options={[
    { value: 'list', label: 'Список' },
    { value: 'grid', label: 'Сетка' },
    { value: 'table', label: 'Таблица' }, // Лишнее значение, которого нет в типе
  ]}
/>
```

Решение:

- согласуйте типы `value` и возможных значений в `options`;
- при необходимости сузьте тип или добавьте защиту (например, проверку перед `setView`).

### Ошибка 4: Игнорирование disabled

Проблема: в обработчиках клика не проверяется флаг `disabled`.

```tsx
// Неполная обработка disabled

<SegmentItem
  disabled={option.disabled}
  onClick={() => onChange(option.value)}   // Даже отключенный сегмент будет менять значение
/>
```

Решение:

```tsx
// Корректная обработка disabled

<SegmentItem
  disabled={option.disabled}
  onClick={() => {
    if (!option.disabled) {
      onChange(option.value);
    }
  }}
/>
```

## Заключение

Сегмент `components` служит местом, где собраны переиспользуемые элементы интерфейса, а `components-segment` — один из ключевых компонентов этого набора. Он помогает структурировать интерфейс, разбивая его на логические сегменты, и обеспечивает единое поведение для переключателей режимов, фильтров и вкладок.

Мы разобрали:

- что такое `components-segment` и какую задачу он решает;
- типичный API и пропсы компонента;
- различия между контролируемым и неконтролируемым режимами;
- подходы к стилизации, работе с несколькими сегментами и сбросу;
- интеграцию с бизнес-логикой и URL;
- базовые принципы доступности и управления с клавиатуры;
- частые ошибки и способы их избежать.

Используя эти принципы, вы сможете уверенно внедрять `components-segment` в свои проекты, делая интерфейсы более структурированными и понятными для пользователей.

## Частозадаваемые технические вопросы по теме

### Как динамически менять список сегментов в components-segment

Если список сегментов приходит с сервера или зависит от другого состояния, вы можете передавать в `options` вычисляемое значение. Главное — следить за актуальностью `value`.

Мини-инструкция:

1. Храните `options` в состоянии или вычисляйте через `useMemo`.
2. После изменения `options` проверьте, что текущее `value` входит в новый список.
3. Если нет — сбросьте `value` на первый доступный сегмент или `null`.

### Как тестировать components-segment с помощью Jest и Testing Library

Для тестирования:

1. Добавьте к сегментам `data-testid` через поле `dataTestId` в `options`.
2. В тесте находите элемент по `getByTestId`.
3. Используйте `userEvent.click`, чтобы эмулировать выбор.
4. Проверяйте, что вызывается `onChange` с ожидаемым значением или что изменился текст активного сегмента.

### Как интегрировать components-segment с Redux или другим стором

Подход:

1. Храните активное значение сегмента в сторе (`segmentSlice` или аналог).
2. В `mapStateToProps`/хуке `useSelector` вытаскивайте `value`.
3. В `onChange` диспатчьте действие `setSegment(nextValue)`.
4. Остальной UI подписывайте на это значение через стор.

### Как сделать debounce при смене сегмента для запросов на сервер

Если при смене сегмента вы отправляете запрос:

1. Внутри `onChange` обновляйте локальное состояние сегмента сразу.
2. Для запроса используйте `useEffect` с зависимостью от значения сегмента.
3. Добавьте debounce через `setTimeout` или готовый хук `useDebounce`, чтобы не слать запрос на каждый быстрый клик.

### Как использовать components-segment в SSR-приложении

Рекомендации:

1. Избегайте чтения `window` и `document` внутри компонента сегмента.
2. Если состояние зависит от URL, инициализируйте его на стороне сервера из параметров запроса.
3. Убедитесь, что начальное значение `value` на сервере и клиенте совпадает, иначе получите гидратационные предупреждения.