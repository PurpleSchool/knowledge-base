---
metaTitle: Рефакторинг под Feature-Sliced Design для фронтенд проектов
metaDescription: Подробное руководство по рефакторингу существующего фронтенда под Feature-Sliced Design - стратегии этапы и практические примеры
author: Олег Марков
title: Рефакторинг под Feature-Sliced Design - пошаговое руководство
preview: Узнайте как постепенно перевести проект на Feature-Sliced Design без простоя и переписывания с нуля - с примерами кода и практическими советами
---

## Введение

Рефакторинг под Feature-Sliced Design (FSD) почти никогда не бывает «зеленым полем». Чаще всего у вас уже есть живой проект на React или другом фреймворке, с монолитной структурой `components`, `pages`, может быть с папкой `store` для Redux, и всё это давно обросло зависимостями.

Смотрите, в этой статье я покажу вам, как перевести такой проект на Feature-Sliced Design без тотальной переписки и длительного заморозки разработки. Мы разберем:

- какие подходы к рефакторингу подходят под FSD;
- какие шаги выполнять в каком порядке;
- как безопасно переносить модули;
- как бороться с «god-components» и «shared hell»;
- как выстраивать границы между слоями и срезами;
- как не сломать продукт и командные процессы.

Я буду опираться на опыт реальных миграций и постараюсь показывать решения на небольших, но показательных примерах.

## Подходы к рефакторингу под Feature-Sliced Design

### Почему нельзя просто «переложить папки»

Частая ошибка – взять текущую структуру и просто разложить её по слоям FSD: `entities`, `features`, `widgets`, `pages`, `shared`. Формально структура станет «похожей» на FSD, но вы не получите главного – управляемых зависимостей и явных границ.

Важно понимать, что FSD – это не только папки, но и:

- правила направлений зависимостей;
- единицы функциональности (срезы / модули) вокруг предметной области;
- принципы инкапсуляции (что можно реэкспортировать, а что оставить приватным).

Поэтому рефакторинг под FSD – это скорее переразбиение системы на модули, чем переименование директорий.

### Стратегии миграции: Big Bang vs Инкрементально

Давайте кратко сравним два подхода.

#### Big Bang (полная миграция за один заход)

- Вы останавливаете добавление фич (или почти останавливаете).
- Полностью перекладываете архитектуру.
- Затем несколько недель разгребаете баги.

Проблемы:

- высокий риск сбоев;
- сложно синхронизировать большую команду;
- слишком много изменений в одном релизе.

Этот путь иногда возможен для небольших pet-проектов, но почти неприменим для коммерческого продукта.

#### Инкрементальный рефакторинг

- Вы постепенно выделяете FSD-слои и срезы;
- старый и новый стилe живут рядом;
- новые фичи делаются уже по FSD;
- старые части пересобираются по мере необходимости.

Этот подход лучше подходит под реальные команды. На нем мы и сосредоточимся.

## Базовые принципы безопасного рефакторинга

### Принцип 1. Структура поверх логики

На первых шагах вы почти не трогаете бизнес-логику. Ваша цель –:

- завести минимальную FSD-структуру;
- начать изолировать фичи и сущности;
- настроить пути импортов и линтинг.

Вы можете думать так: сначала вы создаете «каркас» дома, а потом уже начинаете переставлять мебель.

### Принцип 2. «Островки» FSD внутри монолита

На реальном проекте удобно действовать так:

1. В корне проекта создаете папку `src/app` (если её нет).
2. Внутри – базовые слои FSD: `shared`, `entities`, `features`, `widgets`, `pages`, `processes` (если нужны).

Например:

src/  
├── app/  
│   ├── providers/  
│   ├── index.tsx  
│   ├── styles/  
│   └── router/  
├── shared/  
├── entities/  
├── features/  
├── widgets/  
├── pages/  
└── processes/

3. Все новые фичи создаете уже в этих папках.
4. Старый код трогаете только когда реально до него доходит очередь (bugfix, изменение, оптимизация).

Так вы постепенно увеличиваете «остров» FSD, пока он не поглотит монолит.

### Принцип 3. Сначала границы, потом оптимизация

На первом этапе ключевая задача – провести границы:

- выделить сущности (users, products, orders);
- выделить «событийные» фичи (login, add-to-cart, change-password);
- отрезать общие UI-компоненты и утилиты в `shared`.

При этом не гонитесь за идеальной декомпозицией. Важно хотя бы грубо выделить модули, а уже потом уточнять их границы.

## Этапы рефакторинга под Feature-Sliced Design

### Этап 1. Анализ текущего проекта

#### Шаг 1. Карта зависимостей

Перед тем как переносить код, полезно понять, как он сейчас связан. Вы можете:

- собрать простую карту руками;
- или использовать инструменты визуализации зависимостей (depcruise и аналоги).

Обычно вы увидите:

- огромную папку `components`;
- плотную связанность между страницами и «общими» компонентами;
- бизнес-логику, разбросанную по контейнерам и хукам.

Отсюда вы начинаете выделять кандидатов на `entities`, `features` и `shared`.

#### Шаг 2. Выделение доменных сущностей

Смотрите, попробуйте ответить на вопросы:

- с какими основными объектами работает продукт (user, product, cart, order, project и т.п.);
- какие действия чаще всего совершаются над ними (login, purchase, edit, delete).

Обычно из этого набора рождаются:

- слои `entities/<entityName>`;
- слой `features/<actionName>-<entityName>`.

Например:

- сущность: `User` → `entities/user`;
- действие: вход в систему → `features/auth-by-email`;
- действие: редактирование профиля → `features/update-user-profile`.

### Этап 2. Подготовка структуры и инфраструктуры

#### Шаг 1. Создание слоев FSD

Создайте базовую структуру в корне `src`:

src/  
├── app/  
├── shared/  
├── entities/  
├── features/  
├── widgets/  
├── pages/  
└── processes/

Пока что папки могут быть пустыми или почти пустыми. Главное – чтобы они существовали и по ним уже можно было ориентироваться.

#### Шаг 2. Настройка алиасов импортов

Теперь важно сделать так, чтобы новые модули не использовали относительные пути типов `../../../shared/ui/Button`. Это усложняет навигацию и ломается при перемещениях.

Обычно используют алиасы:

- `@app/*`
- `@shared/*`
- `@entities/*`
- `@features/*`
- `@widgets/*`
- `@pages/*`
- `@processes/*`

Покажу вам, как это можно настроить, например, в TypeScript и webpack.

Пример `tsconfig.json`:

```json
{
  "compilerOptions": {
    "baseUrl": "src",
    "paths": {
      "@app/*": ["app/*"],
      "@shared/*": ["shared/*"],
      "@entities/*": ["entities/*"],
      "@features/*": ["features/*"],
      "@widgets/*": ["widgets/*"],
      "@pages/*": ["pages/*"],
      "@processes/*": ["processes/*"]
    }
  }
}
```

Теперь давайте настроим webpack:

```js
// webpack.config.js

const path = require('path');

module.exports = {
  // ...другие настройки
  resolve: {
    extensions: ['.ts', '.tsx', '.js', '.jsx'],
    alias: {
      // Здесь мы связываем алиасы с реальными путями
      '@app': path.resolve(__dirname, 'src/app'),
      '@shared': path.resolve(__dirname, 'src/shared'),
      '@entities': path.resolve(__dirname, 'src/entities'),
      '@features': path.resolve(__dirname, 'src/features'),
      '@widgets': path.resolve(__dirname, 'src/widgets'),
      '@pages': path.resolve(__dirname, 'src/pages'),
      '@processes': path.resolve(__dirname, 'src/processes')
    }
  }
};
```

Комментарии в коде помогут вам запомнить, зачем вы это делаете. Теперь любые новые импорты вы можете писать так:

```ts
// Здесь мы импортируем кнопку из слоя shared
import { Button } from '@shared/ui/button';

// Здесь мы импортируем сущность пользователя
import { UserCard } from '@entities/user';
```

#### Шаг 3. Настройка линтера зависимостей (опционально, но очень полезно)

Чтобы рефакторинг не откатывался назад, имеет смысл ввести правила, которые не дадут вам нарушить границы слоев. Для этого используют:

- ESLint-плагины под FSD;
- либо общие плагины для контроля путей (например, eslint-plugin-boundaries).

Цель – запретить, например:

- импорт `features` внутри `entities`;
- прямой импорт из чужого среза.

Это помогает держать архитектуру в порядке в долгосрочной перспективе.

### Этап 3. Миграция UI и утилит в shared

Большая часть «бесполезных» зависимостей крутится вокруг общих компонентов и утилит. Давайте начнем с них.

#### Выделяем shared/ui

Предположим, у вас есть папка:

src/  
└── components/  
    ├── Button.tsx  
    ├── Input.tsx  
    └── Modal.tsx  

Давайте перенесем это в FSD-слой:

src/  
└── shared/  
    └── ui/  
        ├── button/  
        │   ├── index.ts  
        │   └── button.tsx  
        ├── input/  
        │   ├── index.ts  
        │   └── input.tsx  
        └── modal/  
            ├── index.ts  
            └── modal.tsx  

Пример содержания `button/index.ts`:

```ts
// Здесь мы публично реэкспортируем компонент кнопки
export { Button } from './button';
```

А сам компонент:

```tsx
// Здесь мы определяем простой UI-компонент без бизнес-логики
import React from 'react';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  // Здесь можно добавить дополнительные пропсы
  variant?: 'primary' | 'secondary';
}

export const Button: React.FC<ButtonProps> = ({ variant = 'primary', ...props }) => {
  // Здесь мы добавляем базовые стили в зависимости от варианта кнопки
  const className = `btn btn-${variant} ${props.className ?? ''}`;

  return (
    // Здесь мы пробрасываем все остальные пропсы дальше
    <button {...props} className={className} />
  );
};
```

После переноса обновите импорты:

```tsx
// Было - импорт из старой папки components
// import { Button } from '../components/Button';

// Стало - импорт из слоя shared
import { Button } from '@shared/ui/button';
```

Так вы шаг за шагом:

1. Переносите компонент в `shared/ui/...`;
2. Добавляете файл `index.ts` для аккуратного экспорта;
3. Исправляете импорты по проекту.

#### Выделяем shared/lib и shared/config

Аналогично переносим:

- общие утилиты в `shared/lib`;
- константы и конфиги в `shared/config`;
- общие типы в `shared/types`.

Например:

src/shared/lib/format-date/format-date.ts:

```ts
// Здесь мы определяем простую функцию форматирования даты
export function formatDate(date: Date): string {
  // Здесь мы используем стандартный метод toLocaleDateString
  return date.toLocaleDateString('ru-RU');
}
```

src/shared/lib/format-date/index.ts:

```ts
// Здесь мы реэкспортируем функцию форматирования для внешнего использования
export { formatDate } from './format-date';
```

Импорт в коде:

```ts
// Здесь мы импортируем функцию форматирования даты из слоя shared
import { formatDate } from '@shared/lib/format-date';
```

На этом шаге вы уже получите частичный выигрыш:

- структура UI станет более предсказуемой;
- общие утилиты перестанут «гулять» по проекту.

### Этап 4. Выделение entities

Теперь давайте займемся доменными сущностями. Обычно они проявляются в нескольких местах:

- модели в хранилище (Redux, MobX, Zustand и т.п.);
- наборы API-запросов для работы с сущностью;
- компоненты, которые отображают эту сущность (UserCard, ProductList).

#### Пример: сущность User

Предположим, в старой структуре у вас есть:

src/  
├── store/user.ts  
├── api/userApi.ts  
└── components/UserCard.tsx  

Давайте перенесем это в `entities/user`.

Пример структуры:

src/entities/user/  
├── model/  
│   ├── types.ts  
│   ├── slice.ts  
│   └── selectors.ts  
├── api/  
│   └── user-api.ts  
├── ui/  
│   └── user-card/  
│       ├── index.ts  
│       └── user-card.tsx  
└── index.ts  

Теперь давайте посмотрим, как это может выглядеть.

src/entities/user/model/types.ts:

```ts
// Здесь мы описываем типы для сущности пользователя
export interface User {
  id: string;
  email: string;
  name: string;
}

// Здесь мы описываем часть состояния стора с информацией о пользователе
export interface UserState {
  authData?: User;
  isLoading: boolean;
}
```

src/entities/user/model/slice.ts (условный пример на Redux Toolkit):

```ts
// Здесь мы создаем slice для управления состоянием пользователя
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { User, UserState } from './types';

const initialState: UserState = {
  // Здесь мы задаем начальное состояние загрузки и данных
  authData: undefined,
  isLoading: false
};

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    // Здесь мы сохраняем данные авторизованного пользователя
    setAuthData(state, action: PayloadAction<User>) {
      state.authData = action.payload;
    },
    // Здесь мы очищаем данные при логауте
    clearAuthData(state) {
      state.authData = undefined;
    }
  }
});

// Здесь мы экспортируем редьюсер и экшены для подключения к стору
export const { reducer: userReducer, actions: userActions } = userSlice;
```

src/entities/user/ui/user-card/user-card.tsx:

```tsx
// Здесь мы определяем UI-компонент для отображения пользователя
import React from 'react';
import { User } from '../../model/types';

interface UserCardProps {
  // Здесь мы передаем сущность пользователя для отображения
  user: User;
}

export const UserCard: React.FC<UserCardProps> = ({ user }) => {
  // Здесь мы выводим основные поля пользователя
  return (
    <div className="user-card">
      <div className="user-card__name">{user.name}</div>
      <div className="user-card__email">{user.email}</div>
    </div>
  );
};
```

src/entities/user/ui/user-card/index.ts:

```ts
// Здесь мы реэкспортируем компонент UserCard для внешнего использования
export { UserCard } from './user-card';
```

src/entities/user/index.ts:

```ts
// Здесь мы собираем публичный API сущности User
export type { User } from './model/types';
export { userReducer, userActions } from './model/slice';
export { UserCard } from './ui/user-card';
```

Теперь в любом месте приложения вы можете использовать:

```tsx
// Здесь мы импортируем сущность User и связанную с ней логику
import { UserCard, userActions, User } from '@entities/user';
```

Это уже приближает вас к FSD:

- у сущности есть свой «дом»;
- все, что относится к User, собрано рядом;
- публичный API управляем через `index.ts`.

### Этап 5. Выделение features

Фичи в FSD – это законченные пользовательские сценарии, обычно над одной или несколькими сущностями. Например:

- `auth-by-email` – авторизация пользователя по email и паролю;
- `add-comment` – добавление комментария к статье;
- `add-to-cart` – добавление товара в корзину.

Фича включает в себя:

- UI-компонент (форма, кнопка);
- бизнес-логику (хендлеры, запросы, валидация);
- связи с сущностями.

#### Пример: фича авторизации auth-by-email

Предположим, в старом коде у вас есть:

- страница LoginPage, где прямо внутри:

  - форма логина;
  - запрос к API;
  - запись в стор;

- и этот код сложно переиспользовать.

Давайте вынесем это в `features/auth-by-email`.

Структура:

src/features/auth-by-email/  
├── ui/  
│   └── login-form/  
│       ├── index.ts  
│       └── login-form.tsx  
├── model/  
│   ├── types.ts  
│   ├── slice.ts  
│   └── services/  
│       └── login-by-email.ts  
└── index.ts  

service: src/features/auth-by-email/model/services/login-by-email.ts

```ts
// Здесь мы описываем асинхронный сервис авторизации пользователя
import { createAsyncThunk } from '@reduxjs/toolkit';
import { User, userActions } from '@entities/user';

interface LoginByEmailProps {
  email: string;
  password: string;
}

// Здесь мы создаем thunk для выполнения запроса логина
export const loginByEmail = createAsyncThunk<
  User,                // Здесь мы указываем тип успешного результата
  LoginByEmailProps,   // Здесь мы указываем тип аргументов функции
  { rejectValue: string } // Здесь мы указываем тип ошибки
>(
  'auth/loginByEmail',
  async ({ email, password }, thunkApi) => {
    const { rejectWithValue, dispatch } = thunkApi;

    try {
      // Здесь мы выполняем HTTP-запрос к вашему API
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });

      if (!response.ok) {
        // Здесь мы обрабатываем неуспешный статус ответа
        return rejectWithValue('Ошибка авторизации');
      }

      // Здесь мы получаем данные пользователя из ответа
      const user = (await response.json()) as User;

      // Здесь мы сохраняем данные пользователя в сущность user
      dispatch(userActions.setAuthData(user));

      return user;
    } catch (e) {
      // Здесь мы обрабатываем сетевые и другие ошибки
      return rejectWithValue('Сетевая ошибка');
    }
  }
);
```

UI: src/features/auth-by-email/ui/login-form/login-form.tsx

```tsx
// Здесь мы описываем UI-компонент формы логина по email
import React, { useState } from 'react';
import { useAppDispatch } from '@shared/lib/hooks/use-app-dispatch';
import { Button } from '@shared/ui/button';
import { loginByEmail } from '../../model/services/login-by-email';

export const LoginForm: React.FC = () => {
  // Здесь мы создаем локальное состояние для полей формы
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  // Здесь мы получаем dispatch из нашего приложения
  const dispatch = useAppDispatch();

  // Здесь мы описываем обработчик отправки формы
  const onSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    // Здесь мы вызываем фичевый thunk для авторизации
    await dispatch(loginByEmail({ email, password }));
  };

  // Здесь мы отображаем простую форму логина
  return (
    <form onSubmit={onSubmit}>
      <input
        type="email"
        // Здесь мы связываем инпут с состоянием email
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
      />
      <input
        type="password"
        // Здесь мы связываем инпут с состоянием пароля
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Пароль"
      />
      {/* Здесь мы используем общую кнопку из shared/ui */}
      <Button type="submit">Войти</Button>
    </form>
  );
};
```

index фичи:

```ts
// Здесь мы формируем публичный API фичи авторизации по email
export { LoginForm } from './ui/login-form';
export { loginByEmail } from './model/services/login-by-email';
```

Теперь LoginPage может выглядеть так:

```tsx
// Здесь мы используем фичу auth-by-email на странице логина
import React from 'react';
import { LoginForm } from '@features/auth-by-email';

export const LoginPage: React.FC = () => {
  return (
    <div>
      <h1>Вход</h1>
      <LoginForm />
    </div>
  );
};
```

Как видите, логика авторизации концентрируется в одном месте – внутри фичи. Страница становится более декларативной и простой.

### Этап 6. Выстраивание widgets и pages

Когда у вас уже есть `entities` и `features`, можно упорядочить более крупные блоки.

#### Widgets

Виджеты – это композиции из features и entities, которые отвечают за крупные части интерфейса:

- `widgets/navbar`;
- `widgets/sidebar`;
- `widgets/article-list`;
- `widgets/cart-panel`.

Пример: `widgets/navbar`, который показывает пользователя и кнопки навигации.

src/widgets/navbar/ui/navbar.tsx:

```tsx
// Здесь мы описываем виджет навигационной панели
import React from 'react';
import { UserCard } from '@entities/user';
import { Button } from '@shared/ui/button';

export const Navbar: React.FC = () => {
  // Здесь мог бы быть хук, который берет данные пользователя из стора
  const user = {
    id: '1',
    email: 'test@example.com',
    name: 'Test User'
  };

  return (
    <nav className="navbar">
      <div className="navbar__logo">MyApp</div>
      <div className="navbar__right">
        {/* Здесь мы показываем информацию о пользователе */}
        <UserCard user={user} />
        {/* Здесь мы показываем кнопку выхода */}
        <Button variant="secondary">Выйти</Button>
      </div>
    </nav>
  );
};
```

index виджета:

```ts
// Здесь мы реэкспортируем Navbar для использования на страницах
export { Navbar } from './ui/navbar';
```

#### Pages

Страницы – самые верхнеуровневые компоненты, которые:

- подключают маршрутизацию;
- собирают виджеты и фичи;
- почти не содержат бизнес-логику.

Пример: `pages/login-page`.

src/pages/login-page/ui/login-page.tsx:

```tsx
// Здесь мы описываем страницу логина
import React from 'react';
import { LoginForm } from '@features/auth-by-email';
import { Navbar } from '@widgets/navbar';

export const LoginPage: React.FC = () => {
  return (
    <>
      {/* Здесь мы используем общий виджет навигации */}
      <Navbar />
      <main>
        <h1>Вход в систему</h1>
        {/* Здесь мы подключаем фичу авторизации */}
        <LoginForm />
      </main>
    </>
  );
};
```

index страницы:

```ts
// Здесь мы реэкспортируем страницу для подключения к роутеру
export { LoginPage } from './ui/login-page';
```

Роутер в `app/router` может импортировать страницу через алиас:

```tsx
// Здесь мы настраиваем маршрутизацию приложения
import React from 'react';
import { Route, Routes } from 'react-router-dom';
import { LoginPage } from '@pages/login-page';

export const AppRouter: React.FC = () => {
  return (
    <Routes>
      {/* Здесь мы регистрируем маршрут для страницы логина */}
      <Route path="/login" element={<LoginPage />} />
    </Routes>
  );
};
```

### Этап 7. Работа с процессами (processes), если это нужно

Иногда у вас есть сквозные сценарии, которые затрагивают многие части приложения, например:

- «Onboarding нового пользователя»;
- «Оформление заказа» (несколько шагов с валидациями и сохранениями);
- «Мультишаговый мастер настройки».

В FSD для этого есть слой `processes`. Но для первого этапа миграции часто достаточно слоев `entities`, `features`, `widgets`, `pages`. Поэтому `processes` можно отложить на более поздний этап, когда вы стабилизируете основные модули.

## Типичные проблемы и как их решать при рефакторинге под FSD

### Проблема 1. «God-компоненты» и «страницы-монолиты»

Часто встречается страница, где:

- 1000+ строк кода;
- внутренняя форма;
- запросы к API;
- логика навигации;
- множество UI-элементов.

Подход:

1. Найдите на странице логически законченные части: «форма фильтрации», «таблица результатов», «панель с деталями».
2. Каждую часть превратите сначала в локальный компонент внутри той же папки.
3. Затем решите, что это: `feature`, `widget` или часть `entity`.

Например:

- «Форма фильтрации списка товаров» → `features/product-filters`;
- «Таблица заказов» → `widgets/orders-table` или `entities/order` + `widgets/order-list`.

Временная стратегия:

- допустимо какое-то время держать промежуточные «неидеальные» виджеты, которые потом вы разобьете на более мелкие фичи и сущности;
- главное – делать компонент меньше и изолировать в нем логику.

### Проблема 2. «Shared hell» – все тащат всё в shared

Нередко после знакомства с FSD команда начинает складывать почти всё в `shared`. В итоге это превращается в новую гигантскую свалку.

Как действовать:

- В `shared` допускайте только действительно переиспользуемые и абстрактные вещи:
  - базовые UI (Button, Input, Modal);
  - утилиты (formatDate, debounce);
  - типы, не привязанные к домену (ID-шники, Result).
- Как только в модуле появляется доменная привязка (User, Order, Product) – это кандидат в `entities`.
- Если модуль зависит от конкретной фичи (auth, cart) – нельзя тащить его в `shared`, его место в соответствующем слое.

Хороший фильтр: если вы не уверены, что модуль пригодится в другом проекте, не спешите класть его в `shared`.

### Проблема 3. Круговые зависимости

При неправильной декомпозиции легко получить ситуацию, когда:

- `entities/user` импортирует что-то из `features/auth-by-email`;
- а `features/auth-by-email` импользует `entities/user`.

Это прямое нарушение направлений зависимостей.

Решение:

- все доменные данные и базовая логика сущности живут в `entities`;
- фича только использует сущности, но не наоборот;
- если появляется общая логика, которая нужна и фиче, и сущности – подумайте, может ли она жить в `shared/lib`, либо нужно аккуратнее разделить ответственность.

### Проблема 4. Смешение слоёв в одном модуле

Иногда вы видите модуль, в котором одновременно:

- запрос к API;
- манипуляции со стором;
- сложная бизнес-логика;
- и UI.

Полностью исправить это за один шаг сложно. Действуйте поэтапно:

1. Вынесите UI в отдельный компонент (может остаться в той же папке).
2. Вынесите network-запрос в отдельный сервис.
3. Разделите стейт-менеджмент (slice, store) и чистую бизнес-логику.

Только после этого станет понятнее, что относится к `entities`, что к `features`, а что к `widgets`.

## Пошаговый план миграции для реального проекта

Теперь давайте сведем всё в практический чек-лист, по которому вы можете идти в живом проекте.

### Шаг 1. Ввести FSD-структуру и алиасы

- Создайте базовые папки: `shared`, `entities`, `features`, `widgets`, `pages`, `app`.
- Настройте алиасы импортов.
- Настройте минимальный линтинг путей (хотя бы на уровне соглашения в команде).

### Шаг 2. Перенести shared-слой

- Перенесите общие UI-компоненты в `shared/ui`.
- Перенесите общие утилиты в `shared/lib`.
- Перенесите константы и конфиги в `shared/config`.
- Обновите импорты во всем проекте.

Это уже можно сделать в одном-двух PR без серьезных рисков.

### Шаг 3. Начать выделять ключевые entities

- Определите 2–3 самые важные сущности (User, Product, Order).
- Для каждой создайте директорию в `entities/<name>`.
- Переместите модель и базовый UI (карточки, списки).
- Соберите публичный API через `index.ts`.

На этом этапе вы сможете использовать новые сущности как «точки опоры» для следующих изменений.

### Шаг 4. Выделить фичи для основных сценариев

- Авторизация / регистрация;
- Основные действия пользователя (добавить в корзину, оформить заказ, создать сущность и т.п.).

Для каждой фичи:

1. Создайте директорию `features/<action>-<entity>`.
2. Вынесите бизнес-логику из страниц в эту фичу.
3. Подключите фичу в нужных виджетах и страницах.

### Шаг 5. Рефакторинг страниц в сторону pages + widgets

- Для ключевых страниц создайте модули в `pages/<page-name>`.
- Перенесите туда UI и базовую композицию виджетов.
- Крупные куски логики и интерфейса переведите в `widgets`.

Спустя несколько таких шагов у вас вырисуется FSD-картина: страницы становятся более декларативными, виджеты отвечают за крупные зоны, фичи – за действия, сущности – за данные.

### Шаг 6. Усилить контроль архитектуры

Когда структура устаканится:

- добавьте ESLint-правила, которые не позволят нарушать слои;
- зафиксируйте договоренности в документации (README, wiki);
- договоритесь в команде, что новые фичи создаются только по FSD.

На этом рефакторинг можно считать завершенным и дальше уже говорить о развитии, а не о миграции.

## Заключение

Рефакторинг под Feature-Sliced Design – это не разовая операция, а постепенное переразбиение проекта на модули вокруг предметной области. Основная идея в том, чтобы:

- вынести общие части в `shared`;
- собрать доменные данные и базовую логику в `entities`;
- оформить пользовательские действия в `features`;
- собирать интерфейс из виджетов (`widgets`) и страниц (`pages`).

Ключевые моменты, на которые стоит опираться:

- двигаться итеративно, без «Big Bang»;
- начинать с структуры и путей импортов;
- переносить код кусками, не меняя сразу бизнес-логику;
- активно использовать публичные API модулей (index-файлы);
- не превращать `shared` в свалку всего подряд;
- поддерживать архитектуру линтерами и договоренностями в команде.

Если двигаться по описанным шагам, вы сможете перевести проект на Feature-Sliced Design без остановки разработки, постепенно улучшая читаемость, модульность и скорость внедрения новых фич.

## Частозадаваемые технические вопросы и ответы

### Как подключить Redux-слайсы из entities и features к общему стору при миграции

Сначала создайте «корневой» стор в `app/providers/store`. В entities и features экспортируйте только редьюсеры. Затем в сторе подключайте их как обычные редьюсеры. Пример:

```ts
// Здесь мы подключаем редьюсер сущности user к корневому стору
import { configureStore } from '@reduxjs/toolkit';
import { userReducer } from '@entities/user';

export const store = configureStore({
  reducer: {
    user: userReducer
  }
});
```

По мере миграции вы просто добавляете новые редьюсеры из фич.

### Как организовать тесты при переходе на FSD

Размещайте тесты рядом с кодом в тех же срезах. Например:

- `entities/user/model/slice.test.ts`;
- `features/auth-by-email/model/services/login-by-email.test.ts`.

Главное – не складывать тесты в одну общую папку `tests`, чтобы не терять связь с кодом.

### Что делать с legacy API-клиентом при миграции

Оставьте существующий клиент в `shared/api` как «обертку» над HTTP. Постепенно выносите конкретные запросы в `entities/*/api` и `features/*/api`. Не меняйте сразу всю реализацию клиента, просто переносите точки использования.

### Как быть с глобальными стилями и темизацией

Глобальные стили и тему удобно держать в `app/styles` и `shared/config/theme`. Компоненты из `shared/ui` могут использовать токены из темы, а более высокоуровневые слои не должны тащить свои стили внутрь shared.

### Как разделять серверную и клиентскую логику в FSD-проекте

Если у вас есть SSR или отдельные серверные части, придерживайтесь тех же срезов, но добавляйте подпапки `server` и `client` внутри модулей. Например: `entities/user/server` для серверных адаптеров и `entities/user/client` для клиентских хуков. Важно не смешивать их в одних и тех же файлах и четко разделять ответственность.