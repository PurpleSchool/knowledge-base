---
metaTitle: Слой entities в архитектуре приложения - entities-layer
metaDescription: Подробное руководство по слою entities в архитектуре приложения - его роль структура реализация и лучшие практики использования доменных сущностей
author: Олег Марков
title: Слой entities - entities-layer в архитектуре приложений
preview: Разбор назначения и реализации слоя entities - как описывать доменные сущности выделять инварианты и строить надежную архитектуру поверх entities-layer
---

## Введение

Слой entities (entities-layer) — это фундаментальный уровень в архитектуре приложения, особенно когда вы применяете подходы вроде Domain-Driven Design, чистой архитектуры или слоистой архитектуры. На этом уровне вы описываете то, о чем на самом деле ваше приложение — доменные сущности, их свойства, поведение и правила, которые не зависят от баз данных, HTTP, фреймворков и конкретных технологий.

Смотрите, цель слоя entities — выделить стабильное ядро системы. Все остальные слои (хранилища, API, UI, интеграции) должны подстраиваться под это ядро, а не наоборот. Если слой entities спроектирован аккуратно, вам проще менять СУБД, переписывать REST на gRPC или переносить логику в микросервисы, не ломая доменную модель.

В этой статье мы разберем:

- какие задачи решает слой entities;
- как отделить его от остальных слоев;
- какие требования предъявлять к сущностям;
- примеры кода с комментариями;
- типичные ошибки и практики, которые помогут их избежать.

Мы будем опираться на абстрактный пример предметной области — простую систему заказов, чтобы вам было легче связать теорию с практикой.

---

## Что такое слой entities и зачем он нужен

### Основная идея entities-layer

Слой entities описывает доменные сущности и их поведение. Под доменной сущностью понимается объект предметной области с:

- устойчивым идентификатором;
- набором значимых полей (атрибутов);
- инвариантами (правилами, которые всегда должны выполняться);
- поведением (методами), отражающим бизнес-логику.

Важно понимать: слой entities не должен знать, где и как эти сущности хранятся, как они передаются по сети и какой фреймворк вы используете. Он описывает только «что это такое» и «как это должно работать».

Если говорить проще, entities-layer — это:

- про смысл данных, а не про их хранение;
- про бизнес-правила, а не про протоколы;
- про устойчивые структуры и инварианты, а не про форматы обмена.

### Место entities-layer в архитектуре

Обычно слой entities располагают в самом центре архитектуры. Давайте визуально покажу, как часто выглядит типичная схема (упрощенно, словами):

- Entities — доменные сущности, value-объекты, доменные типы.
- Use cases / Application — сценарии использования (интеракции пользователя или внешних систем), которые оперируют сущностями.
- Infrastructure — базы данных, очереди, файловые системы, внешние API.
- Interface / Delivery — HTTP API, gRPC, UI, CLI и т.д.

Смотрите, что здесь ключевое:

- Entities не зависят ни от чего.
- Application зависит от entities, но не от инфраструктуры.
- Infrastructure и Interface зависят от application и entities.

Так вы получаете зависимость «внутрь»: чем ближе к центру, тем меньше зависимостей от деталей реализации.

---

## Требования к слою entities

### Отсутствие внешних зависимостей

Слой entities должен быть максимально независим. Это означает:

- нельзя тянуть в него ORM модели;
- не стоит импортировать HTTP пакеты и типы из веб-фреймворков;
- нельзя завязываться на структуру таблиц БД;
- не должно быть прямых зависимостей от логгеров, кэшей, брокеров.

Вы можете использовать только базовые типы языка и, при необходимости, небольшие общие утилиты, не завязанные на инфраструктуру. В идеальном варианте entities-layer компилируется как отдельный модуль без подтягивания «тяжелых» зависимостей.

### Фокус на бизнес-смысле

Сущности должны быть понятны бизнес-экспертам. Если бизнес-аналитику сложно объяснить, что делает метод доменной сущности, то, скорее всего, он находится не на том уровне.

Примеры «плохих» методов для сущности в слое entities:

- SaveToDB
- FromDTO
- ToHTTPResponse

Примеры «правильных»:

- ChangeStatus
- AddItem
- Cancel
- MarkAsPaid

Смотрите, названия напрямую отражают бизнес-смысл, а не технические детали.

### Инварианты и бизнес-правила внутри сущностей

Инварианты — это условия, которые всегда должны быть истинны для корректной работы сущности. Например:

- у заказа должна быть хотя бы одна позиция;
- сумма заказа не может быть отрицательной;
- дата доставки не может быть раньше даты создания;
- email пользователя должен быть валидным.

Слой entities — идеальное место, чтобы зафиксировать такие правила. Это уменьшает риск «забыть» проверить условие в каком-то слое приложения.

---

## Типы объектов в entities-layer

### Сущности (Entities)

Сущности имеют:

- собственный идентификатор;
- продолжительность жизни (они могут создаваться, изменяться, удаляться);
- историю изменений, которая может быть важна для бизнеса.

Пример в домене заказов: Order, Customer, Product.

### Объекты-значения (Value Objects)

Value Object — это объект, который:

- определяется только набором значений полей;
- не имеет отдельного «долгоживущего» ID;
- обычно неизменяем (immutability — хорошая практика).

Примеры:

- Money (amount + currency);
- Email;
- Address;
- Quantity.

Value Object помогает не размывать логику по коду и не держать «голые строки и числа» без содержания. Вы создаете отдельный тип и инкапсулируете логику проверки и поведения.

### Агрегаты и корни агрегатов

Агрегат — это группа связанных сущностей и value-объектов, которые рассматриваются как единое целое с точки зрения согласованности.

Корень агрегата (Aggregate Root):

- единственная точка входа к модификации агрегата;
- управляет инвариантами внутри себя;
- именно его обычно загружает и сохраняет репозиторий.

Например, Order может быть агрегатом, а OrderItem — частью агрегата. Тогда мы изменяем список OrderItem только через методы Order.

---

## Пример структуры entities-layer на практике

### Пример на языке Go (структура пакетов)

Чтобы было понятнее, как это может выглядеть в реальном проекте, давайте посмотрим на условную структуру каталога для entities-layer:

/internal
  /entities
    order.go
    order_item.go
    customer.go
    product.go
    money.go
    email.go
    errors.go

Важно, что пакет entities:

- не знает ни о каких HTTP контроллерах;
- не содержит кода работы с базой;
- не использует внешние библиотеки для сериализации.

Теперь давайте разберемся на примере кода.

---

## Пример доменной сущности Order

### Базовая модель заказа

Ниже — упрощенный пример сущности заказа. Здесь я размещаю пример, чтобы вам было проще понять, как завязать поведение и данные вместе.

```go
package entities

import (
	"errors"
	"time"
)

// OrderStatus - доменный тип для статуса заказа
type OrderStatus string

const (
	OrderStatusNew       OrderStatus = "NEW"        // Новый заказ
	OrderStatusPaid      OrderStatus = "PAID"       // Оплачен
	OrderStatusCancelled OrderStatus = "CANCELLED"  // Отменен
)

// OrderID - отдельный тип для идентификатора заказа
type OrderID string

// Order - доменная сущность заказа
type Order struct {
	ID        OrderID       // Устойчивый идентификатор заказа
	Customer  CustomerID    // Ссылка на клиента как на другую сущность
	Items     []OrderItem   // Позиции заказа - часть агрегата
	Status    OrderStatus   // Текущий статус заказа
	CreatedAt time.Time     // Дата создания
	PaidAt    *time.Time    // Дата оплаты - может быть nil
}

// NewOrder - фабричный метод для создания нового заказа
func NewOrder(id OrderID, customer CustomerID, items []OrderItem, createdAt time.Time) (*Order, error) {
	// Проверяем базовые инварианты
	if id == "" {
		return nil, errors.New("order id must not be empty") // Идентификатор обязателен
	}
	if customer == "" {
		return nil, errors.New("customer id must not be empty") // Клиент обязателен
	}
	if len(items) == 0 {
		return nil, errors.New("order must have at least one item") // Нужна хотя бы одна позиция
	}

	order := &Order{
		ID:        id,
		Customer:  customer,
		Items:     items,
		Status:    OrderStatusNew,
		CreatedAt: createdAt,
		PaidAt:    nil,
	}

	// Дополнительная проверка на корректность содержимого позиций
	if err := order.validateItems(); err != nil {
		return nil, err
	}

	return order, nil
}

// validateItems - внутренний метод для проверки позиций заказа
func (o *Order) validateItems() error {
	if len(o.Items) == 0 {
		return errors.New("order must have items") // Заказ не должен быть пустым
	}

	for _, item := range o.Items {
		if err := item.Validate(); err != nil {
			return err // Прокидываем ошибку валидации позиции
		}
	}

	return nil
}
```

Обратите внимание, что:

- мы не знаем, из какой БД пришли данные;
- мы не знаем, будет ли заказ возвращаться через REST или gRPC;
- все проверки завязаны на бизнес-правила, а не на инфраструктуру.

### Поведение сущности Order

Теперь давайте добавим поведение — оплату и отмену заказа.

```go
// Pay - доменная операция оплаты заказа
func (o *Order) Pay(now time.Time) error {
	// Проверяем, что заказ в подходящем состоянии
	if o.Status != OrderStatusNew {
		return errors.New("only new orders can be paid") // Оплачивать можно только новые заказы
	}

	// Меняем состояние агрегата
	o.Status = OrderStatusPaid
	o.PaidAt = &now

	return nil
}

// Cancel - доменная операция отмены заказа
func (o *Order) Cancel() error {
	// Нельзя отменить уже оплаченный заказ
	if o.Status == OrderStatusPaid {
		return errors.New("paid orders cannot be cancelled") // Защищаем инвариант
	}
	// Нельзя отменять уже отмененный заказ
	if o.Status == OrderStatusCancelled {
		return errors.New("order already cancelled")
	}

	o.Status = OrderStatusCancelled

	return nil
}
```

Как видите, этот код:

- описывает бизнес-правила (что можно и нельзя делать с заказом);
- не зависит от среды выполнения;
- гарантирует, что снаружи нельзя «незаметно» обойти эти проверки, если использовать методы сущности.

---

## Пример объекта-значения OrderItem и Money

### Позиция заказа как часть агрегата

Теперь вы увидите, как это выглядит в коде для внутренней части агрегата — позиции заказа.

```go
// ProductID - тип идентификатора продукта
type ProductID string

// OrderItem - позиция заказа, часть агрегата Order
type OrderItem struct {
	ProductID ProductID // Какой продукт заказан
	Quantity  int       // Количество
	Price     Money     // Цена за единицу
}

// Validate - проверка корректности позиции заказа
func (i OrderItem) Validate() error {
	if i.ProductID == "" {
		return errors.New("product id must not be empty") // Нужен продукт
	}
	if i.Quantity <= 0 {
		return errors.New("quantity must be positive") // Количество должно быть больше нуля
	}
	if i.Price.IsZero() {
		return errors.New("price must be greater than zero") // Цена должна быть больше нуля
	}
	return nil
}
```

Здесь OrderItem — не отдельная сущность верхнего уровня, а часть агрегата Order. Мы не можем изменить позицию заказа в отрыве от заказа.

### Объект-значение Money

Теперь давайте посмотрим, как можно оформить тип Money в entities-layer.

```go
// Money - value object для представления денег
type Money struct {
	Amount   int64  // Сумма в минимальных единицах - например в копейках
	Currency string // Код валюты - например "RUB" или "USD"
}

// NewMoney - фабрика с базовой валидацией
func NewMoney(amount int64, currency string) (Money, error) {
	if amount < 0 {
		return Money{}, errors.New("amount must not be negative") // Сумма не должна быть отрицательной
	}
	if currency == "" {
		return Money{}, errors.New("currency must not be empty") // Валюта обязательна
	}
	return Money{
		Amount:   amount,
		Currency: currency,
	}, nil
}

// Add - сложение двух Money одной валюты
func (m Money) Add(other Money) (Money, error) {
	if m.Currency != other.Currency {
		return Money{}, errors.New("cannot add money with different currencies")
	}

	return Money{
		Amount:   m.Amount + other.Amount,
		Currency: m.Currency,
	}, nil
}

// IsZero - проверка суммы на ноль
func (m Money) IsZero() bool {
	return m.Amount == 0
}
```

Здесь мы:

- инкапсулируем правила работы с деньгами;
- защищаемся от ошибок с валютами;
- не занимаемся здесь форматированием для вывода, округлением для платежных систем и т.п. — это задача других слоев.

---

## События домена в слое entities

### Зачем нужны доменные события

Когда в сущности происходят важные изменения, часто возникает необходимость:

- отправить уведомление;
- обновить проекцию для отчета;
- инициировать обмен с внешней системой.

Но слой entities не должен знать, как именно это произойдет. Хороший способ развязать уровни — доменные события.

Доменные события:

- описывают факт, произошедший в предметной области (OrderPaid, CustomerRegistered);
- не содержат логики отправки куда-либо;
- создаются в момент изменения состояния сущностей.

### Пример доменного события

Давайте посмотрим, как это реализовано на практике.

```go
// DomainEvent - базовый интерфейс для доменных событий
type DomainEvent interface {
	EventName() string   // Имя события для идентификации
	OccurredAt() time.Time // Время возникновения события
}

// OrderPaidEvent - событие оплата заказа
type OrderPaidEvent struct {
	OrderID   OrderID   // Идентификатор оплаченного заказа
	Customer  CustomerID // Клиент который оплатил заказ
	amount    Money      // Сумма оплаты - в данном примере не экспортируемое поле
	occurredAt time.Time // Время возникновения события
}

func (e OrderPaidEvent) EventName() string {
	return "order.paid"
}

func (e OrderPaidEvent) OccurredAt() time.Time {
	return e.occurredAt
}
```

Теперь адаптируем метод оплаты заказа, чтобы он генерировал событие.

```go
// PayWithEvent - оплата заказа с генерацией доменного события
func (o *Order) PayWithEvent(now time.Time) (DomainEvent, error) {
	if err := o.Pay(now); err != nil {
		// Используем уже существующую логику оплаты
		return nil, err
	}

	// Рассчитываем общую сумму заказа на основе позиций
	total, err := o.TotalAmount()
	if err != nil {
		return nil, err
	}

	// Создаем событие о том что заказ оплачен
	event := OrderPaidEvent{
		OrderID:   o.ID,
		Customer:  o.Customer,
		amount:    total,
		occurredAt: now,
	}

	return event, nil
}
```

Важный момент: сам слой entities не решает, куда отправлять это событие. Он только сообщает «это произошло». Обработка события лежит на других слоях — application и infrastructure.

---

## Расчет агрегированных значений в сущности

Часто в сущности есть производные значения, которые удобно считать внутри нее. Давайте реализуем метод TotalAmount для заказа.

```go
// TotalAmount - расчет общей суммы заказа
func (o *Order) TotalAmount() (Money, error) {
	if len(o.Items) == 0 {
		return Money{}, errors.New("order has no items")
	}

	// Берем валюту из первой позиции как основную
	total := Money{
		Amount:   0,
		Currency: o.Items[0].Price.Currency,
	}

	for _, item := range o.Items {
		// Проверяем корректность позиции
		if err := item.Validate(); err != nil {
			return Money{}, err
		}

		// Проверяем валюту
		if item.Price.Currency != total.Currency {
			return Money{}, errors.New("order items must have the same currency")
		}

		// Умножаем цену на количество и добавляем к сумме
		itemTotal := Money{
			Amount:   item.Price.Amount * int64(item.Quantity),
			Currency: item.Price.Currency,
		}

		var err error
		total, err = total.Add(itemTotal)
		if err != nil {
			return Money{}, err
		}
	}

	return total, nil
}
```

Здесь вы видите:

- логику подсчета суммы;
- проверку валют;
- работу с value-типом Money.

Все это находится в одном месте — в слое entities. Остальные слои могут безопасно вызывать этот метод, не дублируя логику.

---

## Организация зависимостей вокруг entities-layer

### Как использовать entities в слое application

Слой application (use cases) работает с сущностями и координирует работу внешних компонентов. Давайте посмотрим, как выглядит сценарий оплаты заказа, используя entities.

Я опущу детали некоторых интерфейсов и покажу только важные моменты взаимодействия.

```go
// OrderRepository - интерфейс репозитория в слое application
// Реализация будет в инфраструктуре но интерфейс ссылается на entities
type OrderRepository interface {
	GetByID(id entities.OrderID) (*entities.Order, error) // Загрузка заказа
	Save(order *entities.Order) error                     // Сохранение изменений
}

// PayOrderInput - входные данные сценария оплаты заказа
type PayOrderInput struct {
	OrderID string    // Идентификатор заказа в виде строки
	Now     time.Time // Время оплаты
}

// PayOrderUseCase - сценарий оплаты заказа
type PayOrderUseCase struct {
	orders OrderRepository // Зависимость от репозитория
	events DomainEventBus  // Шина событий - интерфейс
}

// Execute - выполнение сценария оплаты
func (uc *PayOrderUseCase) Execute(input PayOrderInput) error {
	orderID := entities.OrderID(input.OrderID) // Преобразуем строку во внутренний тип

	// Загружаем заказ из хранилища
	order, err := uc.orders.GetByID(orderID)
	if err != nil {
		return err
	}

	// Пытаемся оплатить заказ с генерацией события
	event, err := order.PayWithEvent(input.Now)
	if err != nil {
		return err
	}

	// Сохраняем изменения в хранилище
	if err := uc.orders.Save(order); err != nil {
		return err
	}

	// Публикуем событие в шину
	if event != nil {
		if err := uc.events.Publish(event); err != nil {
			return err
		}
	}

	return nil
}
```

Давайте посмотрим, что происходит в этом примере:

- Use case зависит от интерфейса OrderRepository и типов из entities (OrderID, Order).
- Внутри use case мы вызываем доменные методы сущности (PayWithEvent).
- repos и events — это зависимости, реализуемые в инфраструктурном слое.

Слой application не знает, какая база данных используется. А entities вообще не знает ни про базы, ни про use cases.

### Маппинг между entities и инфраструктурой

Чтобы инфраструктурный слой мог сохранять сущности, обычно делают отдельные структуры для хранения (ORM модели, схемы таблиц) и пишут маппинг туда и обратно.

Простой пример — как репозиторий может маппить сущность в структуру БД (абстрактно, без конкретной ORM).

```go
// dbOrder - структура уровня инфраструктуры для хранения заказа в БД
type dbOrder struct {
	ID        string    // Столбец id
	Customer  string    // Столбец customer_id
	Status    string    // Столбец status
	CreatedAt time.Time // Столбец created_at
	PaidAt    *time.Time // Столбец paid_at
	// + отдельная таблица для позиций заказа
}

// toEntity - преобразование db модели к доменной сущности
func (dbo dbOrder) toEntity(items []entities.OrderItem) (*entities.Order, error) {
	// Здесь мы используем фабрику NewOrder - она проверит инварианты
	order, err := entities.NewOrder(
		entities.OrderID(dbo.ID),
		entities.CustomerID(dbo.Customer),
		items,
		dbo.CreatedAt,
	)
	if err != nil {
		return nil, err
	}

	// Восстанавливаем статус и дату оплаты - с учетом доменных правил
	order.Status = entities.OrderStatus(dbo.Status)
	order.PaidAt = dbo.PaidAt

	return order, nil
}
```

Обратите внимание:

- сущность не знает о виде dbOrder;
- структура dbOrder не просачивается в entities-layer;
- ответственность за маппинг лежит на инфраструктурном слое.

---

## Типичные ошибки при проектировании entities-layer

### Перетекание инфраструктуры в сущности

Частая проблема: в сущности появляются:

- теги для ORM, специфичные для конкретной библиотеки;
- методы, которые напрямую ходят в БД или в HTTP;
- поля, нужные только для хранения (например, оптимистичные блокировки, версии строк).

Рекомендация:

- разделяйте доменные сущности и структуры хранения;
- помещайте инфраструктурно-зависимые структуры в другие пакеты (например, internal/storage или internal/repository);
- оставляйте в entities только то, что имеет доменный смысл.

### Избыточные сеттеры

Когда сущность имеет публичные поля или набор сеттеров без валидации, инварианты легко сломать.

Плохой пример:

```go
// Плохая практика - публичные поля и набор сеттеров без логики
type User struct {
	ID    string
	Email string
	Name  string
}

func (u *User) SetEmail(email string) {
	u.Email = email // Нет проверки формата email
}
```

Лучше инкапсулировать изменение данных и проверять условия:

```go
// Более безопасный вариант - изменение с валидацией
func (u *User) ChangeEmail(newEmail string) error {
	// Проверяем формат email
	if !isValidEmail(newEmail) {
		return errors.New("invalid email format") // Не даем установить некорректный email
	}
	u.Email = newEmail
	return nil
}
```

### Лишняя логика форматирования и представления

Логику, связанную с UI или API, тоже не стоит тянуть в entities-layer:

- форматирование дат и чисел для пользователя;
- локализация сообщений;
- построение JSON-ответов.

Слой entities работает с «сырыми» доменными данными и поведением. Все, что связано с отображением, должно быть выше по архитектуре.

---

## Лучшие практики для entities-layer

### Явные типы вместо «сырой» строки и чисел

Давайте посмотрим, что происходит, когда вы используете сырые строки:

- легко перепутать аргументы (id, email, phone);
- нет явной связи с доменным смыслом;
- сложнее найти, где используется конкретный вид данных.

Явные типы позволяют:

- обеспечить компиляционную проверку;
- централизовать валидацию;
- добавить методы с говорящими именами.

Пример:

```go
// Email - value object для email адреса
type Email struct {
	value string
}

// NewEmail - конструктор с валидацией
func NewEmail(v string) (Email, error) {
	if !isValidEmail(v) {
		return Email{}, errors.New("invalid email")
	}
	return Email{value: v}, nil
}

// String - безопасный способ получить строковое представление email
func (e Email) String() string {
	return e.value
}
```

Теперь вы можете использовать Email в сущности User и гарантировать корректность формата на уровне типов.

### Иммутабельность value-объектов

Value Object удобно делать неизменяемым:

- вы один раз создаете его через конструктор;
- любые изменения возвращают новый объект, а не меняют текущий;
- меньше побочных эффектов и ошибок при совместном использовании.

В примере с Money мы не меняли состояние текущего объекта в методе Add, а возвращали новый.

### Отдельные ошибки домена

Чтобы не смешивать доменные ошибки с техническими, можно определять свои типы ошибок в entities-layer. Это поможет:

- различать, что именно пошло не так;
- принимать решения в верхних слоях (например, вернуть 400 или 409 HTTP код).

Простой пример:

```go
// DomainError - базовый интерфейс для доменных ошибок
type DomainError interface {
	error
	Code() string // Короткий код ошибки для верхних слоев
}

// ErrInvalidOrderStatus - пример доменной ошибки
type ErrInvalidOrderStatus struct {
	message string
}

func (e ErrInvalidOrderStatus) Error() string {
	return e.message
}

func (e ErrInvalidOrderStatus) Code() string {
	return "invalid_order_status"
}

// Использование в сущности
func (o *Order) Pay(now time.Time) error {
	if o.Status != OrderStatusNew {
		return ErrInvalidOrderStatus{
			message: "only new orders can be paid",
		}
	}
	o.Status = OrderStatusPaid
	o.PaidAt = &now
	return nil
}
```

Слой application может по коду ошибки решать, как реагировать, не заглядывая в текст сообщения.

---

## Заключение

Слой entities (entities-layer) — это ядро архитектуры приложения, в котором живет доменная модель: сущности, value-объекты, инварианты и базовые бизнес-правила. Его главная задача — описать, «что» делает система и «по каким правилам», не завязываясь на то, «как» эти операции реализуются технически.

Ключевые моменты, на которые стоит опираться:

- entities не зависит от инфраструктуры, фреймворков и форматов обмена данными;
- в сущностях сосредоточена бизнес-логика, а не детали хранения и транспорта;
- инварианты и проверки лучше делать внутри сущностей и value-объектов;
- для устойчивых идентификаторов и важных доменных концепций полезно вводить отдельные типы;
- все, что связано с доступом к данным, форматированием или UI, выносится в другие слои.

Если вы аккуратно проектируете entities-layer, вам будет проще развивать систему, менять технологический стек и поддерживать устойчивую, понятную доменную модель, вокруг которой строятся остальные слои.

---

## Частозадаваемые технические вопросы по теме и ответы

### Как правильно версионировать сущности в entities-layer при эволюции домена

Используйте поэтапный подход:

1. Не меняйте интерфейсы и поля «в лоб» — сначала добавляйте новые поля и методы, помечая старые как устаревшие в комментариях.
2. Вводите промежуточные конвертеры из старого вида сущности в новый в слое application или инфраструктуры.
3. В entities оставляйте только актуальную модель, а миграции и маппинг версий выносите в другие слои.

### Можно ли использовать теги ORM (например gorm json) прямо в структурах entities

Технически можно, но это создает скрытую зависимость от конкретной библиотеки. Рекомендуемый подход:

- хранить ORM-модели в отдельном пакете инфраструктуры;
- делать явный маппинг между ORM-структурами и сущностями;
- если очень нужно использовать теги в entities, ограничивайтесь базовыми (например json), которые не привязывают вас к библиотеке хранения.

### Как хранить и обрабатывать локализацию и текстовые сообщения в entities-layer

Слой entities не должен заниматься локализацией. Практика:

1. В entities использовать короткие коды ошибок и событий (например invalid_order_status).
2. В слое application или interface сопоставлять коды с текстами сообщений и переводами.
3. Не использовать в entities формулировки, завязанные на конкретный язык интерфейса.

### Как тестировать entities отдельно от остальных слоев

Используйте модульные тесты на уровне пакета entities:

- создавайте сущности через фабрики (NewOrder NewMoney);
- вызывайте методы поведения (Pay Cancel Add);
- проверяйте инварианты и состояние без поднятия БД или HTTP;
- для ошибок проверяйте типы и коды, а не текст.

Так вы получите быстрые и надежные тесты на доменную модель.

### Как организовать зависимость между разными bounded context если у них есть пересекающиеся сущности

Рекомендуется:

1. В каждом bounded context определять свои сущности, даже если они похожи (Customer в платежах и Customer в CRM могут отличаться).
2. Использовать отдельные типы идентификаторов и value-объектов.
3. Для обмена данными между контекстами применять DTO или события интеграции, не пробрасывая напрямую сущности одного контекста в другой.