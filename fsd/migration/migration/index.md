---
metaTitle: Миграция на архитектуру FSD в фронтенд проектах
metaDescription: Подробное руководство по миграции существующего фронтенд проекта на архитектуру FSD - принципы подход - поэтапный план и практические примеры
author: Олег Марков
title: Миграция на FSD - практическое руководство по переходу к Feature Sliced Design
preview: Узнайте как поэтапно перевести существующее SPA приложение на архитектуру FSD - разбор слоев - правил зависимостей и примеров реальной миграции
---

## Введение

Миграция на FSD (Feature-Sliced Design) — это не просто «переложить файлы по папкам». Вы фактически меняете способ мышления о фронтенд-приложении: от «страниц и компонентов» к «фичам, слоям и четким границам ответственности».

Частая ситуация: у вас уже есть достаточно крупный проект на React (или другом SPA-фреймворке), и вы хотите:

- уменьшить связность модулей;
- упростить поддержку и онбординг новых разработчиков;
- ускорить внедрение фич, не ломая соседние части системы;
- подготовить проект к масштабированию (по командам и функционалу).

FSD как архитектурный подход хорошо это решает, но сам переход легко превратить в хаос, если делать его «в лоб» и без плана. Здесь я покажу вам, как подойти к миграции как к техническому проекту: с этапами, критериями завершенности, примерами структуры кода и типичных решений.

Давайте последовательно разберем:

- базовые принципы FSD, которые важны именно для миграции;
- стартовую диагностику текущего проекта;
- поэтапный план перехода на FSD без «большого взрыва»;
- примеры реорганизации кода и зависимостей;
- типичные ошибки при миграции и как их избежать.

---

## Что такое FSD в контексте миграции

### Кратко о слоях и срезах

Чтобы осознанно мигрировать, важно понимать минимальный набор концепций FSD:

- Срез (slice) — это «кусок» приложения по функциональности: авторизация, профиль, каталог, заказы и т.п.
- Слой (layer) — это уровень абстракции внутри любого среза.

Обычно используют такие слои:

- app — конфигурация приложения, провайдеры, роутинг, глобальные стили;
- processes — сквозные процессы: онбординг, checkout, регистрация с несколькими шагами;
- pages — страницы (роуты), которые собирают фичи и виджеты;
- widgets — крупные UI-композиции, объединяющие несколько фич;
- features — самостоятельные фичи (логин, фильтрация, лайк, выбор города и т.п.);
- entities — бизнес-сущности (User, Product, Order);
- shared — переиспользуемые примитивы: UI-кит, хелперы, константы, конфиг.

Для миграции важно правило зависимостей: зависимости идут сверху вниз, а не наоборот. Например:

- pages могут зависеть от widgets, features, entities, shared;
- features могут зависеть от entities и shared;
- entities — от shared;
- shared — ни от кого.

Смотрите, я покажу вам, как это выглядит на уровне импортов:

```ts
// Пример корректных импортов в FSD

// Страница может импортировать виджет, фичу и сущность
import { ProductListWidget } from '@/widgets/product-list';
import { AddToCartButton } from '@/features/add-to-cart';
import { Product } from '@/entities/product';
import { Container } from '@/shared/ui/container';
```

Здесь каждая зависимость идет с «нижнего» слоя на «верхний», что соответствует правилам FSD.

### Почему миграция на FSD — это не «переписать с нуля»

Полная миграция «за один заход» почти всегда:

- тормозит разработку фич;
- создает кучу регрессий;
- редко доходит до конца.

Гораздо эффективнее подход «страта за стратой»:

- вы постепенно вводите слои и соглашения;
- переносите части кода в новую структуру;
- временно допускаете «серую зону», где старое и новое сосуществуют.

Ключевая идея: миграция должна идти **поэтапно и измеримо**. Давайте посмотрим, как к этому подойти на практике.

---

## Подготовка к миграции: диагностика проекта

### Анализ текущей структуры

Сначала нужно понять, с чем вы работаете. Обычно в старых проектах структура напоминает одну из двух схем:

- «по типам»:
  - components/
  - pages/
  - hooks/
  - utils/
  - api/
- «по страницам»:
  - home/
  - profile/
  - admin/
  - common/

Ваши задачи на этом шаге:

1. Выявить основные доменные сущности: User, Product, Order, Cart и т.д.
2. Описать ключевые фичи: авторизация, поиск, фильтрация, лайки, комментирование.
3. Понять, какие модули чаще всего меняются вместе (это будущие срезы).

Для удобства можно сделать таблицу или список. Например:

- Сущности:
  - User — профиль пользователя, роли, настройки;
  - Product — карточка товара, цена, характеристики;
  - Cart — корзина, подсчет суммы.
- Фичи:
  - auth/login, auth/register;
  - product/add-to-cart;
  - product/add-to-favorites.

### Определение целевой структуры FSD

Теперь вы описываете, какой хотите видеть конечную структуру. Смотрите пример:

```txt
src/
  app/
    providers/
    router/
    styles/
  processes/
    checkout/
  pages/
    product/
    cart/
    profile/
  widgets/
    header/
    footer/
    product-list/
  features/
    auth/
      login/
      logout/
    cart/
      add-to-cart/
      remove-from-cart/
  entities/
    user/
    product/
    cart/
  shared/
    ui/
    api/
    config/
    lib/
```

На этом этапе не обязательно создавать все папки. Важно, чтобы команда договорилась, **как выглядит цель**: какие слои вы используете и как называете срезы.

---

## Стратегия миграции: поэтапный переход

### Этап 1. Введение базовой структуры и алиасов

Сначала вы добавляете базовый каркас FSD **без массового переноса кода**. Это практически не ломает существующий проект.

1. Создайте в корне src/ базовые директории: app, shared, entities, features, widgets, pages, processes.
2. Настройте алиасы импортов: например, @/shared, @/entities и т.д.

Теперь вы увидите, как это выглядит в конфигурации TypeScript:

```jsonc
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"],
      "@app/*": ["app/*"],
      "@shared/*": ["shared/*"],
      "@entities/*": ["entities/*"],
      "@features/*": ["features/*"],
      "@widgets/*": ["widgets/*"],
      "@pages/*": ["pages/*"]
    }
  }
}
```

В Webpack / Vite настраивается похожим образом.

3. Начните использовать алиасы **только в новом коде**.

Так вы задаете новое направление, не трогая пока старые relative-импорты.

### Этап 2. Миграция уровня shared

Shared — самый безопасный слой для начала:

- сюда переезжают ваши общие компоненты, утилиты, конфиги и т.п.;
- он почти не зависит от бизнес-логики.

Проделайте такие шаги:

1. Выделите общие UI-компоненты: Button, Input, Modal и т.п.
2. Перенесите их в shared/ui.
3. Поменяйте импорты в проекте.

Давайте разберемся на примере.

Было:

```tsx
// src/components/Button.tsx
export const Button = () => {
  // ...
};

// src/pages/HomePage.tsx
import { Button } from '../components/Button';
```

Станет:

```tsx
// src/shared/ui/button/index.tsx
export const Button = () => {
  // ...
};

// src/pages/HomePage.tsx
// Обратите внимание - используем новый алиас
import { Button } from '@shared/ui/button';
```

Комментарии к примеру:

- мы переносим Button в shared/ui/button;
- создаем index.tsx для экспорта;
- заменяем относительный импорт на импорт через алиас.

Параллельно можно вынести:

- хелперы в shared/lib;
- общие константы в shared/config или shared/const.

### Этап 3. Выделение entities

Теперь вы начинаете формировать «сердце» доменной модели: сущности.

Шаги:

1. Составьте список сущностей (User, Product, Cart).
2. Для каждой создайте директорию в entities с одноименным названием.
3. Переносите сюда:
   - типы данных;
   - API-запросы, связанные с сущностью;
   - UI-компоненты, представляющие сущность (UserCard, ProductCard и т.п.);
   - бизнес-логику, которая логично принадлежит сущности.

Теперь вы увидите, как это выглядит в коде.

Было:

```tsx
// src/api/userApi.ts
export const fetchUser = () => {
  // ...
};

// src/components/UserCard.tsx
import { fetchUser } from '../api/userApi';

export const UserCard = () => {
  // ...
};
```

Станет:

```tsx
// src/entities/user/api/userApi.ts
export const fetchUser = () => {
  // Здесь мы работаем с API пользователя
};

// src/entities/user/ui/user-card.tsx
import { fetchUser } from '../api/userApi';

export const UserCard = () => {
  // Здесь мы используем конкретный запрос для сущности User
};

// src/entities/user/index.ts
export { UserCard } from './ui/user-card';
export * as userApi from './api/userApi';
```

И далее в любом месте проекта:

```tsx
// src/widgets/profile-header/ui/profile-header.tsx
import { UserCard, userApi } from '@entities/user';

export const ProfileHeader = () => {
  // Здесь можно использовать и компонент, и api сущности User
};
```

Важно: entities не должны зависеть от features или widgets. Если вы видите такой импорт — это сигнал неправильной границы.

### Этап 4. Миграция features

Фичи — это(actions) приложения, которые приносят пользователю ценность: логин, поиск, фильтрация, добавление в корзину.

Алгоритм:

1. Найдите зоны кода, которые реализуют конкретное действие пользователя.
2. Сгруппируйте их в фичи по принципу «одна фича — один сценарий».
3. Внутри фичи можно иметь:
   - ui — компоненты;
   - model — состояние, бизнес-правила;
   - lib — хелперы, специфичные для фичи.

Давайте посмотрим, что происходит в примере миграции фичи «Добавить в корзину».

Было:

```tsx
// src/components/ProductCard.tsx
import { addToCart } from '../api/cart';

export const ProductCard = ({ product }) => {
  const handleAdd = () => {
    // Здесь прямо внутри компонента вызывается API корзины
    addToCart(product.id);
  };

  return (
    <div>
      {/* ... */}
      <button onClick={handleAdd}>Add to cart</button>
    </div>
  );
};
```

Станет:

```tsx
// src/features/cart/add-to-cart/model/use-add-to-cart.ts
import { cartApi } from '@entities/cart';

export const useAddToCart = () => {
  // Здесь мы инкапсулируем логику добавления в корзину
  const add = (productId: string) => {
    return cartApi.addToCart(productId);
  };

  return { add };
};
```

```tsx
// src/features/cart/add-to-cart/ui/add-to-cart-button.tsx
import { useAddToCart } from '../model/use-add-to-cart';

type Props = {
  productId: string;
};

export const AddToCartButton = ({ productId }: Props) => {
  const { add } = useAddToCart();

  const handleClick = () => {
    // Здесь мы используем бизнес-логику фичи
    add(productId);
  };

  return <button onClick={handleClick}>Add to cart</button>;
};
```

```ts
// src/features/cart/add-to-cart/index.ts
export { AddToCartButton } from './ui/add-to-cart-button';
```

```tsx
// src/entities/product/ui/product-card.tsx
import { AddToCartButton } from '@features/cart/add-to-cart';

export const ProductCard = ({ id, title }) => {
  // Обратите внимание - сущность Product теперь использует фичу
  return (
    <div>
      <h3>{title}</h3>
      <AddToCartButton productId={id} />
    </div>
  );
};
```

Здесь важно понимать нюанс: иногда фича не должна лежать внутри сущности. В FSD чаще пользуются правилом: **сущность не знает о фичах**, а фича использует сущность. Тогда ProductCard останется в entities, а кнопка AddToCartButton будет подключаться на уровне widgets или pages, а не в самом entities. Конкретное решение зависит от строгости соблюдения принципов в вашей команде. При миграции допускается промежуточный вариант, но его лучше планово переработать позже.

### Этап 5. Введение widgets и pages

Когда shared, entities и часть features уже перенесены, становится проще собрать более крупные блоки.

1. Widgets — композиции, которые:
   - сочетают несколько фич и сущностей;
   - используются на разных страницах;
   - имеют собственную локальную структуру.

Пример:

```tsx
// src/widgets/product-list/ui/product-list.tsx
import { ProductCard } from '@entities/product';
import { useProducts } from '@entities/product/model/use-products';

export const ProductList = () => {
  const { products } = useProducts();

  return (
    <div>
      {products.map((p) => (
        <ProductCard key={p.id} {...p} />
      ))}
    </div>
  );
};
```

```ts
// src/widgets/product-list/index.ts
export { ProductList } from './ui/product-list';
```

2. Pages — соответствуют роутам: /catalog, /product/:id, /cart.

Страница собирает виджеты и фичи:

```tsx
// src/pages/catalog/ui/catalog-page.tsx
import { ProductList } from '@widgets/product-list';
import { CategoryFilter } from '@features/catalog/category-filter';

export const CatalogPage = () => {
  return (
    <div>
      <CategoryFilter />
      <ProductList />
    </div>
  );
};
```

```ts
// src/pages/catalog/index.ts
export { CatalogPage } from './ui/catalog-page';
```

И потом страница подключается в app/router.

Таким образом, вы шаг за шагом выстраиваете новый «скелет» приложения.

---

## Организация переходного периода

### Сосуществование старой и новой структуры

На практике вы долгое время будете жить в ситуации, когда:

- часть кода уже лежит по FSD-структуре;
- часть находится в старых директориях.

Чтобы не запутаться, договоритесь в команде о правилах:

- новый код — только в FSD-структуре;
- рефакторинг старого кода — только «когда трогаем модуль по делу»;
- запрещены новые общие папки типа utils/ в корне.

Можно ввести временную директорию legacy/, куда складывать модули, которые вы позже планируете переработать. Например:

```txt
src/
  legacy/
    components/
    api/
    hooks/
```

### Временные «адаптеры» и фасады

Иногда проще не сразу переписывать логику, а сделать «прослойку»:

- новый код импортирует функции через FSD-слой;
- внутри адаптера вызывается старый модуль.

Покажу вам, как это реализовано на практике.

```ts
// src/entities/user/api/userApi.ts
// Здесь мы пока просто прокидываем вызов в старый модуль
import { getUser as legacyGetUser } from '@/legacy/api/user';

export const getUser = legacyGetUser;
```

Таким образом:

- снаружи уже используется entities/user;
- внутри вы пока не трогаете старый legacy/api/user;
- позже вы можете переписать реализацию, не меняя потребителей.

---

## Технические практики для контролируемой миграции

### ESLint-правила для слоев

Чтобы не полагаться только на «договоренности», хорошо ввести линтинг зависимостей. Доступны плагины, которые:

- проверяют, что imports идут правильным путем (pages → features, но не наоборот);
- запрещают использовать абсолютные пути мимо алиасов;
- контролируют «public API» модулей (использовать только index.ts).

Пример настройки с eslint-plugin-boundaries или аналогами может выглядеть так (упрощенно):

```js
// .eslintrc.js
module.exports = {
  // ...
  rules: {
    'fsd/layer-imports': [
      'error',
      {
        alias: '@',
        layers: ['app', 'processes', 'pages', 'widgets', 'features', 'entities', 'shared']
      }
    ],
    'fsd/public-api-imports': [
      'error',
      {
        alias: '@',
        // Здесь мы запрещаем импорт "глубже" index.ts снаружи среза
      }
    ]
  }
};
```

Комментарии к примеру:

- вы включаете кастомные правила, которые проверяют FSD-иерархию;
- alias должен совпадать с тем, что настроен в tsconfig.json.

### Public API модулей

Ключевой элемент FSD — public API. Для каждого среза (feature, entity, widget) создайте index.ts и экспортируйте из него только то, что должны видеть снаружи.

Например:

```ts
// src/features/auth/login/index.ts
export { LoginForm } from './ui/login-form';
export type { LoginFormValues } from './model/types';
```

Снаружи вы используете только этот файл:

```tsx
import { LoginForm } from '@features/auth/login';
```

Внутренние файлы (например, ui/fields.tsx или model/validation.ts) остаются закрытыми для проекта. Это помогает при миграции:

- вы можете спокойно менять внутреннюю структуру;
- потребителям достаточно, чтобы не ломался index.ts.

### Инкрементальный рефакторинг

Хорошая практика: закрепить правило «Boy Scout Rule» — каждый разработчик, заходя в старый модуль, немного прибирается и приближает его к FSD.

Примеры:

- вынести типы в entities;
- заменить импорт компонента с относительного пути на алиас;
- перенести фичу в features и добавить index.ts.

Так миграция становится частью ежедневной работы, а не отдельным «большим проектом».

---

## Типичные ошибки и как их избежать

### Ошибка 1. Перемещение без изменения зависимостей

Часто делают так: просто переносят папки в новую структуру, но при этом:

- остаются старые относительные импорты;
- логика доступа к сущностям и фичам не меняется;
- public API не вводится.

Фактически структура «косметическая», архитектурно ничего не улучшилось.

Решение:

- всегда после переноса проверяйте импорты;
- заменяйте относительные пути на алиасы;
- делайте public API (index.ts) и наружу экспортируйте только его.

### Ошибка 2. Слишком мелкая или слишком крупная грануляция фич

Иногда делают фичу на каждый маленький компонент, или наоборот — одну фичу на весь модуль авторизации.

Рекомендация:

- фича должна отражать осмысленное действие пользователя: login, reset-password, change-avatar;
- не бойтесь иметь несколько ui-компонентов внутри одной фичи;
- если фича раздулась, возможно, в ней спрятаны несколько сценариев — разбейте позже.

### Ошибка 3. Попытка мигрировать все слои сразу

Если вы одновременно:

- переносите UI в shared;
- выделяете entities;
- вводите features, widgets и pages,

то рискуете получить огромное количество конфликтов и нерешенных зависимостей.

Лучше двигаться по слоям и по модулям:

- сначала shared;
- потом entities;
- потом features;
- потом widgets/pages.

И не трогать сразу весь проект — выбирайте одну вертикаль: например, весь модуль Catalog от UI до API.

### Ошибка 4. Игнорирование процессов и app-слоя

Некоторые ограничиваются только features/entities/widgets/pages и забывают:

- app — конфигурацию приложения, провайдеры, router;
- processes — бизнес-процессы в несколько шагов (checkout, onboarding).

В результате:

- «глобальный» код остается разбросанным по разным местам;
- непонятно, где искать входные точки и сквозные сценарии.

Решение: постепенно переносить:

- роутинг, главные провайдеры и инициализацию в app;
- многошаговые сценарии (например, оформление заказа) в processes.

---

## Заключение

Миграция на FSD — это долгосрочный архитектурный проект, а не разовый рефакторинг. Основные идеи, которые важно удерживать:

- Не делайте «big bang». Переносите по слоям и по модулям.
- Начинайте с shared и entities — это самые стабильные и безопасные слои.
- Вводите public API и алиасы — они помогают контролировать зависимости.
- Используйте линтинг и правила командной разработки, а не только устные договоренности.
- Приучайте команду мыслить фичами и сущностями, а не страницами и «папкой components».

Если подойти к миграции как к серии маленьких, но последовательных шагов, вы сможете постепенно перевести проект на FSD, не останавливая бизнес-фичи и не создавая бесконтрольный хаос.

---

## Частозадаваемые технические вопросы по теме и ответы

### Как организовать тесты при миграции на FSD

На переходном этапе удобно располагать тесты рядом с модулями, следуя за структурой FSD:

- для сущностей: src/entities/user/model/user.test.ts;
- для фич: src/features/auth/login/model/use-login.test.ts.

Инструкция:

1. При переносе модуля перенесите рядом и его тесты.
2. Настройте Jest или Vitest так, чтобы алиасы @/shared, @/entities и т.д. работали в тестах.
3. Новые тесты пишите уже в FSD-структуре, старые переносите по мере миграции модулей.

### Как лучше организовать стили и дизайн-систему в FSD

Рекомендуется:

- базовые стили и тему хранить в shared/styles;
- UI-кит (Button, Input, Modal) — в shared/ui;
- специфические стили сущностей и фич — рядом с ними (entities/user/ui/...).

Если вы используете CSS Modules или CSS-in-JS, оставляйте файлы стилей рядом с компонентами в их слое.

### Что делать с глобальным состоянием (Redux, Zustand, Effector) при миграции

Стратегия:

1. Глобальный стор и провайдеры перенесите в app/store или app/providers.
2. Постепенно делите стор на срезы по сущностям и фичам.
3. Для новых фич используйте локальное состояние (hook-и) или стор внутри их слоя (features/.../model).

Старайтесь не создавать новые «общие» глобальные редьюсеры в старой структуре.

### Как поступать с legacy API при переходе на FSD

Постройте слой адаптеров:

1. Внутри entities создайте api-обертки, которые используют старые модули API.
2. Новый код обращается только к entities/.../api.
3. Позже переписывайте реализацию API внутри entities без изменения внешних контрактов.

Это позволяет менять инфраструктуру API без каскадных правок по всему коду.

### Как планировать задачи по миграции в бэклоге

Практика:

1. Приоритезируйте по бизнес-модулям: каталогу важнее, чем редко используемой админке.
2. Привязывайте миграцию к фичам: если дорабатываете модуль, заложите время на его перенос в FSD.
3. Введите технические задачи на линтинг слоев, настройку алиасов и public API.

Так миграция идет параллельно с бизнес-задачами и не превращается в отдельный «замороженный» проект.