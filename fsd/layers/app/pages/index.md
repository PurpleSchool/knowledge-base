---
metaTitle: Слой pages в веб приложении - архитектура pages-layer
metaDescription: Подробный разбор слоя pages в архитектуре веб приложений - как организовать страницы, рендеринг и маршрутизацию на уровне pages-layer
author: Олег Марков
title: Слой pages - архитектура pages-layer в современном веб приложении
preview: Разберем как устроен слой pages в архитектуре и как с его помощью организовать страницы, обработку запросов и связь с бизнес логикой на уровне pages-layer
---

## Введение

Слой pages (pages-layer) часто недооценивают, хотя именно он определяет, как пользователь взаимодействует с вашим приложением. Через этот слой проходят все HTTP-запросы, здесь формируются страницы, подключаются шаблоны, собираются данные из сервисов и подготавливается финальный HTML или JSON.

Смотрите, в этой статье я покажу вам, как можно системно организовать слой pages, чтобы:

- структура проекта оставалась понятной;
- код страниц не превращался в один огромный файл;
- было просто добавлять новые страницы и изменять существующие;
- бизнес-логика не просачивалась в слой представления.

Мы будем рассматривать слой pages как уровень между маршрутизатором и доменной/сервисной логикой. Он отвечает за:

- привязку URL к странице;
- получение и валидацию входных данных;
- вызов доменных сервисов;
- подготовку view-моделей;
- выбор и рендеринг шаблонов.

Давайте разберем это все по шагам.

## Роль и место слоя pages в архитектуре

### Общая схема уровней

Чтобы вам было проще ориентироваться, посмотрим на типичную многослойную архитектуру веб-приложения:

- transport/router-слой (маршрутизация HTTP)
- pages-слой (страницы, контроллеры, обработчики view)
- application/service-слой (бизнес-сценарии)
- domain-слой (модели и доменная логика)
- infrastructure-слой (БД, очереди, внешние API, кэш)

Слой pages находится скорее всего сразу после маршрутизатора. Маршрутизатор передает запрос в конкретный обработчик страницы, а тот дальше оркестрирует нужные сервисы и рендеринг.

Ключевые задачи pages-layer:

1. Принять HTTP-запрос и параметры пути/запроса.
2. Провести базовую валидацию и преобразование данных к формату, удобному для сервисов.
3. Вызвать один или несколько application-сервисов.
4. Сконструировать модель представления (view model).
5. Выбрать нужный шаблон и отрендерить ответ.
6. Обработать пользовательские ошибки так, чтобы они были понятны на UI.

### Чем слой pages отличается от API-слоя

Во многих проектах есть REST/JSON API и есть слой страниц. Они могут быть реализованы отдельно или как часть одного транспортного слоя, но по сути решают разные задачи:

- API-слой:
  - выдает структурированный JSON;
  - ориентирован на машинных клиентов;
  - возвращает статусы ошибок в виде кодов и полей errors;
  - редко рендерит HTML.

- pages-слой:
  - выдает HTML-страницы;
  - ориентирован на человека;
  - умеет показывать формы с ошибками;
  - часто использует шаблонизатор, layout и компоненты.

Важно не смешивать эти слои. Если вы начинаете в handlers страниц добавлять чистый JSON-рендеринг для бэкенд-клиентов, архитектура быстро становится нечитаемой.

## Структура папок и файлов слоя pages

### Базовая структура проекта

Давайте посмотрим на пример структуры, которую можно использовать в типичном веб-приложении (я покажу пример на Go, но концепция подходит и к другим языкам):

```go
// Пример структуры папок:
//
// /internal
//   /pages          // Слой pages
//     /home         // Страницы "домашнего" раздела
//       handler.go  // HTTP-обработчики
//       view.go     // View-модели и вспомогательные функции
//       templates/  // Шаблоны конкретного раздела
//     /users
//       handler.go
//       view.go
//       templates/
//     router.go      // Регистрация маршрутов для всех страниц
//
//   /app            // Application-слой (сервисы)
//   /domain         // Доменная логика
//   /infra          // Доступ к БД, кэш и т.п.
```

Комментарии в коде:

```go
// Папка /pages хранит все, что связано с отображением страниц.
// Внутри нее вы группируете код по функциональным модулям (home, users и т.п.)
// Каждый модуль имеет свой handler.go (HTTP-обработчики) и view.go (view-модели).
// templates/ содержит шаблоны, специфичные для этого модуля.
```

Такой подход помогает вам:

- локализовать логику каждой страницы;
- избежать огромного файла с десятками обработчиков;
- разделить view-модели и «чистые» доменные модели.

### Модульная организация по фичам

Здесь хорошо работает «feature-based» структура: каждый функциональный модуль содержит весь фронтовый серверный код слоя pages, который относится к нему.

Например, модуль users может содержать:

- список пользователей;
- страницу профиля;
- форму редактирования профиля.

Это объединяется в один модуль `users` на уровне pages, даже если на уровне домена сущностей больше.

Теперь давайте посмотрим на конкретные примеры кода.

## Обработчики страниц: от запроса к ответу

### Типичный обработчик страницы

Смотрите, на примере я покажу, как может выглядеть простой обработчик страницы в Go, использующий слой pages:

```go
package home

import (
	"net/http"
)

// HandlerIndex обрабатывает запрос на главную страницу.
// Он относится к слою pages и не содержит бизнес-логики.
func HandlerIndex(svc Service, tmpl TemplateRenderer) http.HandlerFunc {
	// svc - это интерфейс application-сервиса
	// tmpl - интерфейс для рендеринга HTML-шаблонов
	return func(w http.ResponseWriter, r *http.Request) {
		// 1. Получаем данные из сервисного слоя
		stats, err := svc.GetDashboardStats(r.Context())
		if err != nil {
			// Обрабатываем ошибку пользовательским образом
			http.Error(w, "Внутренняя ошибка сервера", http.StatusInternalServerError)
			return
		}

		// 2. Собираем view-модель для шаблона
		vm := DashboardView{
			UserName:   r.Context().Value(UserNameKey).(string), // Берем имя из контекста
			StatsBlock: statsToView(stats),                      // Преобразуем доменную модель к view-модели
		}

		// 3. Рендерим шаблон и отправляем ответ
		if err := tmpl.Render(w, "home/index.html", vm); err != nil {
			http.Error(w, "Ошибка рендеринга страницы", http.StatusInternalServerError)
			return
		}
	}
}
```

Ключевые моменты:

- обработчик **не** лезет напрямую в БД;
- обработчик не знает подробностей бизнес-логики (он вызывает `svc.GetDashboardStats`);
- есть явная view-модель `DashboardView`, а не просто доменная модель.

### Интерфейсы, которые использует pages-layer

Чтобы слой pages был слабо связан с остальной системой, часто вводят интерфейсы для сервисов и рендерера. Давайте разберемся на примере.

```go
// Service описывает, какие операции нужны от application-слоя
// для конкретного модуля (раздела) pages.
type Service interface {
	GetDashboardStats(ctx context.Context) (DashboardStats, error)
}

// TemplateRenderer описывает абстракцию рендеринга страниц.
type TemplateRenderer interface {
	Render(w http.ResponseWriter, name string, data any) error
}
```

Комментарии:

```go
// Такой подход позволяет:
// - Подменять реализацию сервисов в тестах.
// - Использовать разный шаблонизатор, не меняя код обработчиков.
// - Скрывать детали доменного и инфраструктурного слоя.
```

### Регистрация маршрутов для страниц

Обычно слой pages содержит собственный модуль или функцию, которая регистрирует все маршруты. Давайте посмотрим на пример:

```go
package pages

import (
	"net/http"

	"myapp/internal/pages/home"
	"myapp/internal/pages/users"
)

// RegisterRoutes регистрирует все маршруты для слоя pages.
// Здесь мы явно связываем URL-адреса с обработчиками страниц.
func RegisterRoutes(
	mux *http.ServeMux,
	homeService home.Service,
	usersService users.Service,
	tmpl TemplateRenderer,
) {
	// Главная страница
	mux.Handle("/", home.HandlerIndex(homeService, tmpl))

	// Пользователи
	mux.Handle("/users", users.HandlerList(usersService, tmpl))
	mux.Handle("/users/profile", users.HandlerProfile(usersService, tmpl))
}
```

Обратите внимание:

- слой pages не должен знать о конкретной реализации `home.Service` или `users.Service`;
- зависимости внедряются снаружи (через конструктор или функцию регистрации);
- так вам проще тестировать отдельные обработчики и поддерживать код.

## View-модели и преобразование данных

### Зачем нужны view-модели

Доменные модели часто содержат больше данных, чем нужно на странице, а также могут иметь поля, которые не предназначены для прямого отображения (например, внутренние статусы, технические идентификаторы).

Поэтому на уровне pages удобно вводить помощь в виде view-моделей:

- отдельные структуры для данных, которые идут в шаблон;
- только те поля, которые действительно нужны;
- уже отформатированные значения (строки дат, локализованные подписи).

Давайте посмотрим, как это может выглядеть.

```go
// DashboardView описывает данные, которые нужны главной странице.
type DashboardView struct {
	UserName   string
	StatsBlock StatsView
}

// StatsView - view-модель для блока статистики.
type StatsView struct {
	ProjectsCount string // Форматированная строка
	TasksCount    string
	LastLogin     string // Уже в формате для человека, а не timestamp
}

// statsToView преобразует доменную модель к view-модели.
func statsToView(d DashboardStats) StatsView {
	return StatsView{
		ProjectsCount: fmt.Sprintf("%d проектов", d.ProjectsCount),
		TasksCount:    fmt.Sprintf("%d задач", d.TasksCount),
		LastLogin:     d.LastLogin.Format("02.01.2006 15:04"), // Форматируем дату
	}
}
```

Здесь видите, мы отделяем:

- «сырой» объект `DashboardStats` (из application/domain-слоя);
- «человеческий» объект `StatsView` для шаблона.

### Где хранить view-модели

Хорошая практика — хранить view-модели:

- либо в том же файле/пакете, что и обработчики конкретной страницы;
- либо в отдельном файле `view.go` внутри модуля pages.

Так вы легко находите, какие модели используются для какой страницы, и избегаете путаницы между доменными структурами и структурами для UI.

### Валидация и отображение ошибок

Слой pages часто отвечает за удобное отображение ошибок пользователю. Обычно для этого тоже вводят отдельные view-модели форм.

Давайте разберемся на примере простой формы регистрации:

```go
// RegisterFormView описывает данные для формы регистрации.
type RegisterFormView struct {
	Email       string
	Password    string
	Errors      map[string]string // Поле -> текст ошибки
	CommonError string            // Ошибка верхнего уровня (например, общая)
}
```

Тогда обработчик может выглядеть так:

```go
func HandlerRegister(svc Service, tmpl TemplateRenderer) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method == http.MethodGet {
			// Показать пустую форму
			vm := RegisterFormView{}
			_ = tmpl.Render(w, "users/register.html", vm)
			return
		}

		// Обработка POST-запроса
		if err := r.ParseForm(); err != nil {
			http.Error(w, "Некорректный запрос", http.StatusBadRequest)
			return
		}

		// Собираем данные формы
		vm := RegisterFormView{
			Email:  r.FormValue("email"),
			Errors: map[string]string{},
		}

		// Простая валидация на уровне pages
		if vm.Email == "" {
			vm.Errors["email"] = "Укажите email"
		}
		password := r.FormValue("password")
		if len(password) < 6 {
			vm.Errors["password"] = "Пароль должен быть не короче 6 символов"
		}

		// Если есть ошибки валидации, показываем форму снова
		if len(vm.Errors) > 0 {
			_ = tmpl.Render(w, "users/register.html", vm)
			return
		}

		// Вызываем доменный или application-сервис
		if err := svc.RegisterUser(r.Context(), vm.Email, password); err != nil {
			// Обрабатываем бизнес-ошибки и показываем их пользователю
			vm.CommonError = "Не удалось зарегистрировать пользователя"
			_ = tmpl.Render(w, "users/register.html", vm)
			return
		}

		// Если все успешно, делаем редирект
		http.Redirect(w, r, "/users/profile", http.StatusSeeOther)
	}
}
```

Как видите, этот код:

- валидацию UI-уровня держит в слое pages;
- переносит только «чистые» данные в application-слой;
- возвращает формы с уже заполненными полями и ошибками.

## Шаблоны и рендеринг в слое pages

### Организация шаблонов

Структура шаблонов в слое pages может выглядеть так:

- layouts
  - base.html
  - auth.html
- partials
  - header.html
  - footer.html
  - nav.html
- home
  - index.html
- users
  - list.html
  - profile.html
  - register.html

При этом в самом pages-layer вы используете абстрактный рендерер, который знает, как эти шаблоны собирать.

Давайте посмотрим на упрощенный интерфейс рендерера:

```go
// TemplateRenderer скрывает детали используемого шаблонизатора.
type TemplateRenderer interface {
	Render(w http.ResponseWriter, name string, data any) error
}
```

Реализация может использовать стандартный html/template, другое решение или даже собственную обертку.

### Пример использования шаблонов в обработчике

Пример мы уже видели выше, но давайте акцентируемся на вызове:

```go
if err := tmpl.Render(w, "users/profile.html", vm); err != nil {
	http.Error(w, "Ошибка рендеринга страницы", http.StatusInternalServerError)
	return
}
```

Комментарии:

```go
// В pages-слое обработчик:
// - не знает, какие именно файлы включены в profile.html;
// - не занимается разбором и парсингом шаблонов;
// - получает уже готовый интерфейс render, который можно подменить.
```

### Обработка контекстных данных

Частая задача в слое pages — передать в шаблон общие данные:

- текущего пользователя;
- настройки локализации;
- флаги A/B-тестов;
- сообщения flash и т.п.

Обычно это решается:

- либо через базовую view-модель, от которой наследуются (композицией) остальные;
- либо через middleware, которое добавляет данные в контекст, а затем в обработчике вы добавляете их в модель.

Пример базовой view-модели:

```go
// BaseView содержит общие данные для всех страниц.
type BaseView struct {
	CurrentUserName string
	IsAuthenticated bool
	FlashMessages   []string
}

// ProfileView расширяет BaseView полями конкретной страницы.
type ProfileView struct {
	BaseView
	Email string
	Bio   string
}
```

Такой подход позволяет не дублировать общие поля и держать структуру данных для UI в одном месте.

## Навигация, маршруты и именованные пути

### Почему полезно использовать именованные маршруты

В слое pages часто нужно:

- строить ссылки;
- перенаправлять пользователя на другие страницы;
- хранить маршруты в одном месте.

Чтобы не размазывать по коду строки с URL, удобно использовать именованные маршруты. В некоторых фреймворках это стандартный функционал, где-то это можно реализовать самостоятельно.

Покажу вам подход на примере простого маршрутизатора:

```go
// RouteName описывает имя маршрута.
type RouteName string

const (
	RouteHome         RouteName = "home"
	RouteUsersList    RouteName = "users_list"
	RouteUserProfile  RouteName = "user_profile"
	RouteUserRegister RouteName = "user_register"
)

// Router хранит соответствие имени и пути.
type Router struct {
	mux    *http.ServeMux
	routes map[RouteName]string
}

// URL возвращает путь по имени маршрута.
func (r *Router) URL(name RouteName) string {
	return r.routes[name]
}
```

В pages-слое это позволяет:

- использовать `router.URL(RouteUserProfile)` вместо жестко заданной строки;
- проще рефакторить пути;
- избежать опечаток в URL.

### Применение в обработчиках

Давайте посмотрим, как именованный маршрут помогает при редиректе:

```go
func HandlerRegister(
	svc Service,
	tmpl TemplateRenderer,
	router *Router,
) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// ... обработка формы ...

		// Если все хорошо — переходим на страницу профиля по имени маршрута
		http.Redirect(w, r, router.URL(RouteUserProfile), http.StatusSeeOther)
	}
}
```

Так вы отвязываете обработчик от конкретного пути `/users/profile` и привязываете его к логическому имени.

## Безопасность и авторизация в слое pages

### Где проверять права доступа

Права доступа удобно проверять:

- либо в middleware до входа в обработчик страницы;
- либо в самом обработчике, если логика специфична.

Слой pages — хорошее место, чтобы:

- проверить, авторизован ли пользователь;
- запретить доступ к определенным страницам;
- отобразить корректную страницу ошибки (403, 404) или форму логина.

Давайте разберем простой пример с middleware.

```go
// AuthMiddleware проверяет, что пользователь авторизован.
// Если нет - делает редирект на страницу логина.
func AuthMiddleware(next http.HandlerFunc, router *Router) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Здесь мы предполагаем, что в контексте есть флаг авторизации.
		isAuth, ok := r.Context().Value(IsAuthKey).(bool)
		if !ok || !isAuth {
			// Редирект на логин
			http.Redirect(w, r, router.URL(RouteUserLogin), http.StatusSeeOther)
			return
		}

		// Если все хорошо, продолжаем выполнение цепочки
		next.ServeHTTP(w, r)
	}
}
```

Комментарии:

```go
// Такой middleware относится к транспортному уровню, но тесно связан со слоем pages,
// так как он решает, какие страницы показывать в зависимости от авторизации.
```

### Обработка ошибок доступа

Иногда нужно отобразить страницу 403 с объяснением, а не просто вернуть статус. Это тоже отвечает слой pages:

- он решает, какой шаблон рендерить;
- он формирует понятное сообщение для пользователя;
- он может показать рекомендации (например, связаться с администратором).

```go
func ForbiddenPage(tmpl TemplateRenderer) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusForbidden)

		// Здесь мы подготавливаем view-модель для страницы 403.
		vm := struct {
			Message string
		}{
			Message: "У вас нет прав для просмотра этой страницы",
		}

		_ = tmpl.Render(w, "errors/403.html", vm)
	}
}
```

## Тестирование слоя pages

### Что именно тестировать

В слое pages полезно покрывать тестами:

- корректный рендеринг в зависимости от входных данных;
- корректную обработку ошибок application-сервиса;
- правильные редиректы;
- работу валидации форм.

Здесь я покажу базовый пример теста обработчика в Go.

```go
func TestHandlerRegister_Success(t *testing.T) {
	// 1. Готовим заглушку сервиса
	svc := &FakeService{
		RegisterUserFunc: func(ctx context.Context, email, password string) error {
			// Здесь мы можем проверить, что приходят нужные данные
			if email == "" || password == "" {
				t.Errorf("ожидали непустые email и password")
			}
			return nil
		},
	}

	// 2. Готовим фейковый рендерер шаблонов
	tmpl := &FakeTemplateRenderer{}

	// 3. Создаем HTTP-запрос с корректными данными
	form := url.Values{}
	form.Set("email", "test@example.com")
	form.Set("password", "123456")

	req := httptest.NewRequest(http.MethodPost, "/users/register", strings.NewReader(form.Encode()))
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	// 4. Записываем ответ в recorder
	rec := httptest.NewRecorder()

	// 5. Вызываем обработчик
	handler := HandlerRegister(svc, tmpl, nil)
	handler.ServeHTTP(rec, req)

	// 6. Проверяем статус и редирект
	if rec.Code != http.StatusSeeOther {
		t.Fatalf("ожидали редирект, получили статус %d", rec.Code)
	}
}
```

Комментарии к тесту:

```go
// В тестах слоя pages мы:
// - подменяем application-сервисы на фейки;
// - не трогаем БД или реальные внешние сервисы;
// - проверяем только логику страницы (валидация, редиректы, рендеринг).
```

### Моки и фейки для рендерера

Рендерер шаблонов можно подменить простой заглушкой, чтобы не зависеть от реальных файлов шаблонов. Например:

```go
type FakeTemplateRenderer struct {
	LastName string
	LastData any
}

func (f *FakeTemplateRenderer) Render(w http.ResponseWriter, name string, data any) error {
	// Сохраняем последние параметры, чтобы проверить их в тесте
	f.LastName = name
	f.LastData = data

	// Пишем простой текст в ответ, чтобы он не был пустым
	_, _ = w.Write([]byte("ok"))
	return nil
}
```

Теперь вы можете в тестах проверять, какой шаблон и с какими данными был вызван.

## Типичные ошибки при проектировании pages-layer

### Смешение бизнес-логики и логики представления

Самая распространенная проблема: в обработчик страницы начинают подтягивать:

- прямые запросы к БД;
- сложные вычисления;
- транзакции;
- работу с внешними сервисами.

Слой pages при этом разрастается и превращается в набор «супер-контроллеров». Из-за этого:

- становится сложно тестировать;
- логика повторяется в разных обработчиках;
- теряется четкое разделение ответственности.

Хорошая практика:

- все «непро UI» операции — в application/domain-слой;
- слой pages только собирает входные данные и дергает методы application-слоя.

### Логика в шаблонах

Вторая частая ошибка — переносить логику в шаблоны:

- сложные условия if-else;
- фильтрация и сортировка;
- форматирование дат и чисел, зависящее от бизнес-правил.

Шаблоны лучше оставлять максимально «глупыми»:

- примитивные условия для отображения;
- простые циклы по коллекциям;
- вызов простых функций форматирования.

Весь подготовительный этап данных — в обработчике и view-модели слоя pages.

### Сильная связность с конкретным фреймворком

Иногда слой pages строится целиком вокруг конкретного фреймворка (конкретных типов запросов, рендера, middleware). Тогда:

- сложно перейти на другой фреймворк;
- трудно переиспользовать логику.

Лучше выделять абстрактные интерфейсы (как `TemplateRenderer`, `Service`) и придерживаться чистого кода обработчиков, где можно:

- подменять часть окружения;
- использовать без глубокого знания внутренностей фреймворка.

## Заключение

Слой pages (pages-layer) — это не просто набор HTTP-обработчиков. Это полноценный архитектурный уровень, который:

- связывает маршрутизатор и бизнес-логику;
- отвечает за сбор и подготовку данных для отображения;
- управляет навигацией, валидацией форм и отображением ошибок;
- скрывает от шаблонов внутреннюю структуру домена и сервисов.

Если вы:

- выделяете отдельные view-модели;
- не смешиваете бизнес-логику с логикой представления;
- используете интерфейсы для сервисов и рендерера;
- грамотно организуете структуру папок и модулей;

то слой pages становится прозрачным, предсказуемым и удобным в сопровождении. Добавление новой страницы превращается в понятный и повторяемый процесс: описать маршрут, написать обработчик, собрать view-модель и шаблон.

Теперь, когда общая картина слоя pages стала яснее, вы можете адаптировать предложенные подходы под свой стек технологий и размер проекта, постепенно упорядочивая код и разгружая другие уровни архитектуры.

## Частозадаваемые технические вопросы

### Как в слое pages корректно работать с асинхронными операциями (горoutines, фоновые задачи)

Если страница должна инициировать долгую операцию, не выполняйте ее целиком в обработчике. В pages-слое:

1. Считайте входные данные.
2. Вызовите application-сервис, который:
   - ставит задачу в очередь или запускает воркер;
   - возвращает идентификатор задачи.
3. В pages-слое:
   - сохраните ID задачи (например, в БД или кэше);
   - верните пользователю страницу с информацией, что операция выполняется;
   - дайте ссылку для проверки статуса по ID.

Так вы не блокируете HTTP-запрос и не смешиваете фоновые задачи с UI-слоем.

### Как в pages-layer реализовать локализацию сообщений и форматов дат

Не форматируйте строки напрямую в обработчиках. В pages-слое:

1. Получите язык пользователя (из куки, заголовков или профиля).
2. Передайте язык в сервис локализации (интерфейс, инкапсулирующий i18n).
3. В view-модели храните ключи сообщений, а не готовые строки, либо сразу вызывайте `localizer.Translate(key, lang)`.
4. Форматирование дат и чисел делайте через локализующий сервис, а не через жестко заданные форматы.

Так вы избегаете дублирования и сможете легко менять язык всего приложения.

### Как лучше организовать общий layout и partials в pages-слое

Вместо дублирования разметки в каждом шаблоне:

1. Введите шаблон layout (base.html), где есть общие блоки: `<head>`, шапка, меню, футер.
2. Для каждой страницы определяйте только контентную часть.
3. Части, используемые в нескольких местах (меню, карточка пользователя), вынесите в partials.
4. В pages-слое для всех страниц используйте одну и ту же базовую view-модель с общими полями (BaseView).

Так вы можете менять общий каркас приложения, не трогая десятки файлов.

### Как разделить слой pages и чистый API, если URL частично совпадают

Если у вас есть и HTML-страницы, и JSON API, не объединяйте их в один обработчик. Сделайте:

1. Отдельные маршруты, даже если логически ресурс один, например:
   - `/users` — HTML (pages-layer);
   - `/api/users` — JSON (API-layer).
2. Оба обработчика могут вызывать один и тот же application-сервис, но:
   - pages-слой строит view-модель и рендерит HTML;
   - API-слой формирует JSON-ответ и коды ошибок.

Так вы не будете писать условный код вида `if wantsJSON { ... } else { ... }` и упрощаете архитектуру.

### Как корректно пробрасывать context из слоя pages в application-слой

Не создавайте новый context в pages-слое. Вместо этого:

1. Используйте `r.Context()` как базовый context.
2. Добавляйте в него только данные, относящиеся к текущему запросу (ID пользователя, trace-id) через `context.WithValue`, но аккуратно и с типизированными ключами.
3. Передавайте этот context во все вызовы application-сервисов.
4. Не храните в контексте крупных объектов (модели, соединения с БД) — только метаданные.

Таким образом, вы сохраняете цепочку отмены и таймаутов и не разрываете логику трассировки и логирования.