---
metaTitle: Слайс либы lib-slice в Go - как упростить работу со срезами
metaDescription: Разберитесь как использовать слайс либу lib-slice в Go - готовые функции для фильтрации поиска агрегации и безопасной работы со срезами
author: Олег Марков
title: Слайс либы lib-slice в Go - полный разбор с примерами
preview: Узнайте как слайс либы lib-slice помогает писать чище и безопаснее код в Go - работа со срезами становится проще с готовыми утилитами и паттернами
---

## Введение

Срезы в Go — один из самых используемых типов данных. Через них проходят коллекции, буферы, результаты запросов к БД и многое другое. Но базовых возможностей языка часто не хватает: приходится вручную писать циклы для фильтрации, поиска, преобразования, проверки уникальности, удаления элементов и т.п.

Слайс либы, условная библиотека `lib-slice`, решает эту проблему. Она предлагает набор готовых функций и утилит для типичных операций над срезами. В итоге вы тратите меньше времени на «обвязку» и можете сосредоточиться на логике приложения.

В этой статье вы увидите, какие задачи закрывает `lib-slice`, как её использовать, какие есть ключевые функции и подводные камни. Я покажу вам примеры кода и дам пояснения, чтобы можно было понять не только «что делает», но и «почему так».

---

## Обзор библиотеки lib-slice

### Основная идея lib-slice

Главная цель `lib-slice` — сделать работу со срезами более декларативной и безопасной. Вместо повторяющихся циклов вы пишете короткие вызовы функций, которые сразу отражают намерение:

- найти элемент;
- отфильтровать по условию;
- преобразовать элементы в другой тип;
- сгруппировать данные;
- проверить наличие;
- объединить и пересечь наборы.

Смотрите, я покажу вам простой пример контраста.

Без lib-slice:

```go
// Ищем первое четное число в срезе
func findFirstEven(nums []int) (int, bool) {
    // Проходим по всем элементам
    for _, v := range nums {
        // Проверяем условие
        if v%2 == 0 {
            // Возвращаем найденное значение и флаг успеха
            return v, true
        }
    }
    // Если элемент не найден - возвращаем ноль и false
    return 0, false
}
```

С использованием lib-slice (примерный API):

```go
import "github.com/your-org/lib-slice"

even, ok := libslice.Find(nums, func(v int) bool {
    // Условие поиска - число должно быть четным
    return v%2 == 0
})
```

Как видите, во втором случае сразу видно, что вы «ищете» элемент по условию. Детали обхода и остановки цикла прячутся внутри библиотеки.

### Типы задач, которые покрывает lib-slice

Давайте кратко перечислим группы возможностей, а затем разберём их подробно:

- Поиск и проверка
  - поиск первого / последнего элемента по условию;
  - поиск индекса;
  - проверка вхождения (Contains / Any / All).
- Фильтрация и преобразование
  - Filter;
  - Map;
  - Compact / RemoveEmpty.
- Агрегация и вычисления
  - Sum / Avg / Min / Max;
  - Reduce / Fold.
- Работа с уникальностью и множествами
  - Unique / Distinct;
  - Union / Intersect / Difference.
- Утилиты изменения структуры
  - Insert / Delete;
  - Chunk / Split;
  - Reverse / Shuffle;
  - Clone / CopySafe.

Теперь давайте перейдем к отдельным категориям и конкретным функциям.

---

## Поиск и проверка элементов

### Поиск элемента по условию

Одна из самых частых задач — найти первый элемент, удовлетворяющий предикату. В `lib-slice` это обычно реализовано функцией наподобие `Find`.

Пример:

```go
package main

import (
    "fmt"

    libslice "github.com/your-org/lib-slice"
)

func main() {
    // Исходный срез целых чисел
    nums := []int{3, 7, 10, 15, 22}

    // Ищем первое число, большее 10
    n, ok := libslice.Find(nums, func(v int) bool {
        // Условие - число должно быть больше 10
        return v > 10
    })

    if !ok {
        // Обрабатываем ситуацию, когда элемент не найден
        fmt.Println("Не найдено")
        return
    }

    // Выводим найденное значение
    fmt.Println("Найдено:", n)
}
```

Обратите внимание:

- передаётся срез и функция-предикат;
- функция возвращает значение и булев флаг `ok`;
- предикат вызывается для каждого элемента, пока не найдётся подходящий.

Такой подход избавляет от многократного копирования одного и того же цикла в разных местах.

### Поиск индекса

Иногда важно знать не значение, а позицию элемента. Для этого в `lib-slice` вы встретите функцию `Index` или `FindIndex`.

```go
// Ищем индекс строки "admin" в списке ролей
idx := libslice.Index(roles, func(role string) bool {
    // Сравниваем значение с искомой строкой
    return role == "admin"
})

if idx == -1 {
    // Минус единица - типовой индикатор отсутствия
    fmt.Println("Роль admin не найдена")
} else {
    fmt.Println("Роль admin на позиции", idx)
}
```

Здесь мы имеем дело с более «низкоуровневой» информацией: номером элемента. Это полезно при последующих модификациях среза (например, удалении по индексу).

### Проверка вхождения и предикатов (Contains, Any, All)

Часто нужно просто проверить существование элемента или свойство набора:

- «есть ли хотя бы один активный пользователь»;
- «все ли значения валидны»;
- «содержит ли список определённый элемент».

В `lib-slice` это обычно выглядит так:

```go
// Проверяем наличие конкретного значения (используется ==)
hasAdmin := libslice.Contains(roles, "admin")

// Проверяем - есть ли хотя бы один отрицательный элемент
hasNegative := libslice.Any(nums, func(v int) bool {
    // Условие - число меньше нуля
    return v < 0
})

// Проверяем - все ли значения больше нуля
allPositive := libslice.All(nums, func(v int) bool {
    // Число должно быть строго положительным
    return v > 0
})
```

Смотрите, я покажу вам, как в реальном коде это может сократить проверки:

```go
if !libslice.Any(users, func(u User) bool {
    // Ищем хотя бы одного активного пользователя
    return u.Active
}) {
    // Если таких нет - логика обработки
    return errors.New("нет активных пользователей")
}
```

Вместо ручного цикла логика получается компактной и читаемой.

---

## Фильтрация и преобразование срезов

### Filter — отбор элементов по условию

`Filter` — одна из базовых функций любой коллекционной библиотеки. Она создаёт новый срез из элементов, которые удовлетворяют условию.

```go
// Фильтруем только чётные числа
evens := libslice.Filter(nums, func(v int) bool {
    // Оставляем только числа, делящиеся на 2 без остатка
    return v%2 == 0
})
```

Давайте разберемся на чуть более «живом» примере с доменной моделью:

```go
// User описывает пользователя системы
type User struct {
    ID     int
    Name   string
    Active bool
}

// Получаем только активных пользователей
activeUsers := libslice.Filter(users, func(u User) bool {
    // Условие - флаг Active должен быть true
    return u.Active
})
```

Здесь важно помнить: `Filter` обычно не модифицирует исходный срез, а создаёт новый. Это снижает риск неожиданных побочных эффектов.

### Map — преобразование элементов

`Map` позволяет пройтись по каждому элементу среза и создать на его основе новое значение. Часто используется для:

- вытягивания одного поля из структуры;
- преобразования типа (например, `int` → `string`);
- нормализации данных.

Теперь вы увидите, как это выглядит в коде:

```go
// Преобразуем срез пользователей в срез имён
names := libslice.Map(users, func(u User) string {
    // Возвращаем только поле Name
    return u.Name
})
```

Другой пример — преобразование чисел к строкам:

```go
// numbers - срез целых чисел
strs := libslice.Map(numbers, func(n int) string {
    // Преобразуем число в строку
    return strconv.Itoa(n)
})
```

Под капотом `Map` выделяет новый срез нужной длины и заполняет его результатами вызова функции.

### Композиция Filter и Map

На практике вы часто будете комбинировать `Filter` и `Map`. Например:

- отфильтровать только активных пользователей;
- взять только их идентификаторы.

```go
// Сначала оставляем только активных
active := libslice.Filter(users, func(u User) bool {
    // Оставляем пользователей с Active == true
    return u.Active
})

// Затем берем их ID
activeIDs := libslice.Map(active, func(u User) int {
    // Возвращаем только значение поля ID
    return u.ID
})
```

Иногда в `lib-slice` могут быть и комбинированные функции, но даже в простой форме такой код гораздо нагляднее «сырого» цикла с двумя ветками логики.

### Удаление пустых и нулевых значений

Частая задача — удалить нулевые значения: пустые строки, нули, `nil` в срезе интерфейсов. Многие реализации `lib-slice` предлагают функции типа `Compact`, `RemoveZero`, `RemoveEmpty`.

Пример с пустыми строками:

```go
// texts - срез строк, среди которых могут быть пустые или пробельные
clean := libslice.RemoveEmpty(texts, func(s string) bool {
    // Здесь мы сами определяем, что считаем "пустым"
    return strings.TrimSpace(s) == ""
})
```

Обратите внимание: условие «пустоты» передаётся явно. Это даёт гибкость и помогает избежать жёстко зашитых критериев в библиотеке.

---

## Агрегация и вычисления

### Sum, Min, Max, Avg для чисел

Для числовых срезов удобно иметь готовые функции для суммирования, нахождения минимума и максимума, а также среднего значения. Это те операции, которые в «голом» Go приходится писать вручную.

Допустим, в `lib-slice` есть специальные типизированные функции:

```go
// Находим сумму
total := libslice.SumInts(nums)

// Максимальное значение
max := libslice.MaxInts(nums)

// Минимальное значение
min := libslice.MinInts(nums)

// Среднее арифметическое
avg := libslice.AvgInts(nums)
```

Смотрите, я покажу вам, как обрабатывать ситуацию с пустым срезом, если библиотека возвращает ошибку:

```go
avg, err := libslice.AvgIntsSafe(nums)
if err != nil {
    // Пустой срез или другая ошибка - обрабатываем
    log.Println("невозможно вычислить среднее:", err)
} else {
    // Используем посчитанное значение
    fmt.Println("avg =", avg)
}
```

Если `lib-slice` не выбрасывает ошибку, а возвращает ноль, важно самим понять, что это ваш договор с библиотекой и учитывать его в логике.

### Reduce / Fold — произвольная агрегация

Если вам нужно более сложное свёртывание данных (например, объединение строк, построение словарей, подсчёт статистики), пригодится `Reduce`.

Давайте посмотрим, что происходит в следующем примере:

```go
// Считаем сумму квадратов чисел
sumSquares := libslice.Reduce(nums, 0, func(acc, v int) int {
    // acc - накопленное значение
    // v - текущий элемент
    return acc + v*v
})
```

Пример построения карты по ID:

```go
// Строим map[int]User по полю ID
usersByID := libslice.Reduce(users, make(map[int]User), func(acc map[int]User, u User) map[int]User {
    // Кладем пользователя в карту по ID
    acc[u.ID] = u
    return acc
})
```

Здесь `Reduce`:

- принимает начальное значение аккумулятора;
- проходится по всем элементам среза;
- на каждом шаге вызывает переданную функцию.

Такой подход особенно полезен, когда нужна сложная агрегация, а отдельной специализированной функции в библиотеке нет.

---

## Уникальность и операции над «множествами»

### Unique / Distinct — удаление дубликатов

Одна из типичных задач — сделать значения в срезе уникальными. В `lib-slice` это часто называется `Unique` или `Distinct`.

Пример для простых типов:

```go
// Убираем дубликаты из среза чисел
uniqueNums := libslice.UniqueInts(nums)
```

Для структур может понадобиться своя функция ключа:

```go
// UniqueBy строит уникальный список по ключу (например по ID)
uniqueUsers := libslice.UniqueBy(users, func(u User) int {
    // Возвращаем ключ уникальности - здесь это поле ID
    return u.ID
})
```

Внутри, как правило, используется карта (`map`), которая помнит уже встреченные ключи.

### Union, Intersect, Difference

Когда вы работаете с наборами данных, удобно мыслить их как множества:

- Union — объединение;
- Intersect — пересечение;
- Difference — разность.

Давайте разберемся на примере:

```go
a := []int{1, 2, 3, 4}
b := []int{3, 4, 5, 6}

// Объединение A и B
u := libslice.UnionInts(a, b)        // [1 2 3 4 5 6]

// Пересечение A и B
i := libslice.IntersectInts(a, b)    // [3 4]

// Разность A \ B (элементы только из A)
d := libslice.DifferenceInts(a, b)   // [1 2]
```

Если библиотека поддерживает обобщённые (`generic`) версии с пользовательским ключом, для структур можно написать так:

```go
// Пересечение пользователей по ID
common := libslice.IntersectBy(usersA, usersB, func(u User) int {
    // Ключ сравнения - ID пользователя
    return u.ID
})
```

Здесь мы явно указываем, по какому полю объекты считаются одинаковыми.

---

## Изменение структуры срезов

### Insert и Delete по индексу

В чистом Go вставка и удаление по индексу всегда требуют аккуратной работы с `append` и `copy`. `lib-slice` обычно предлагает удобные обёртки для таких операций.

Смотрите, я покажу вам, как можно упростить вставку:

```go
// Вставляем число 99 на позицию 2
nums2 := libslice.Insert(nums, 2, 99)
```

Типичная реализация внутри будет выглядеть как:

```go
// Псевдокод реализации Insert
func Insert[T any](s []T, idx int, v T) []T {
    // Создаем новый срез большей длины
    s = append(s, v)               // увеличиваем длину на 1
    copy(s[idx+1:], s[idx:])       // сдвигаем элементы вправо
    s[idx] = v                     // вставляем значение
    return s
}
```

Теперь давайте посмотрим на удаление:

```go
// Удаляем элемент с индексом 3
nums3 := libslice.Delete(nums2, 3)
```

Это делает код гораздо более читаемым и снижает риск ошибок с диапазонами срезов.

### Reverse и Shuffle

Иногда нужно развернуть порядок элементов или перемешать их в случайном порядке.

```go
// Разворачиваем срез "на месте"
libslice.Reverse(nums)

// Перемешиваем элементы случайным образом
libslice.Shuffle(nums, rand.New(rand.NewSource(time.Now().UnixNano())))
```

Обратите внимание на комментарий к `Shuffle`:

- она обычно принимает источник случайности (`rand.Source` или `*rand.Rand`);
- это позволяет вам контролировать детерминизм (важно для тестов).

### Clone / CopySafe — безопасное копирование

В Go важно понимать, что срез — это «окно» к массиву. Если вы просто присвоите один срез другому, оба будут ссылаться на один и тот же массив.

Чтобы сделать независимую копию, в `lib-slice` используется функция `Clone` или `CopySafe`.

```go
// Делаем независимую копию среза
numsCopy := libslice.Clone(nums)

// Теперь изменения numsCopy не повлияют на nums
numsCopy[0] = 100
```

Комментарии к этому моменту особенно важны для новичков: нередко они удивляются, почему изменения в одном срезе влияют на другой.

---

## Обобщения и типобезопасность (generic API)

### Обобщённые функции в стиле Go 1.18+

Если `lib-slice` современная, она чаще всего использует обобщения (`generics`). Это значит, что большинство функций объявлены с параметром типа `T any`, чтобы не дублировать код для каждого отдельного типа.

Упрощённый пример:

```go
// Find ищет первый элемент, удовлетворяющий предикату
func Find[T any](s []T, pred func(T) bool) (T, bool) {
    // Проходим по всем элементам
    for _, v := range s {
        // Проверяем условие предиката
        if pred(v) {
            // Возвращаем найденное значение и флаг успеха
            return v, true
        }
    }
    // Создаём нулевое значение типа T
    var zero T
    // Если ничего не нашли - возвращаем zero и false
    return zero, false
}
```

Покажу вам, как это выглядит при вызове:

```go
// Срез строк
words := []string{"go", "rust", "java"}

// Ищем первую строку длиной 2 символа
w, ok := libslice.Find(words, func(s string) bool {
    // Условие - длина строки должна быть равна 2
    return len(s) == 2
})
```

Компилятор сам подставит конкретный тип `T` на основе переданного среза.

### Ограничения типов (constraints)

Для числовых операций (Sum, Avg, Min, Max) могут использоваться ограничения типа `constraints.Integer`, `constraints.Float` или объединения.

Условная сигнатура:

```go
// Numeric описывает число (целое или с плавающей точкой)
type Numeric interface {
    ~int | ~int64 | ~float64
}

// Sum считает сумму числовых значений
func Sum[T Numeric](s []T) T {
    var total T
    // Проходим по всем элементам и накапливаем сумму
    for _, v := range s {
        total += v
    }
    return total
}
```

Здесь тип `T` ограничен только числами. Это защищает от случайного вызова функции для строк или структур.

---

## Производительность и работа с памятью

### Избежание лишних аллокаций

Когда вы часто создаёте новые срезы (Filter, Map, Unique), важно следить за выделениями памяти. Хорошие реализации `lib-slice` обычно:

- заранее резервируют нужную ёмкость (`make([]T, 0, len(s))`);
- по возможности модифицируют срез «на месте» (in-place).

Смотрите, я покажу вам пример экономной реализации `Filter`:

```go
func Filter[T any](s []T, pred func(T) bool) []T {
    // Создаем новый срез с максимальной возможной емкостью
    out := make([]T, 0, len(s))
    // Проходим по исходному срезу
    for _, v := range s {
        if pred(v) {
            // Добавляем только подходящие элементы
            out = append(out, v)
        }
    }
    return out
}
```

Здесь важный момент:

- `len(out)` растёт только при добавлении, но `cap(out)` сразу максимальный;
- это уменьшает количество реаллокаций при `append`.

### Изменение входного среза vs создание нового

Некоторые функции могут:

- модифицировать входной срез;
- или всегда создавать новый.

Это критичное поведение, которое библиотека должна явно документировать, а вам важно его знать. Например:

- `Reverse` может разворачивать «на месте»;
- `Filter` обычно возвращает новый срез.

Если вы не уверены, лучше считать, что исходный срез может быть изменён и при необходимости передавать в функцию клон:

```go
// Делаем копию перед разрушительной операцией
numsCopy := libslice.Clone(nums)
libslice.Reverse(numsCopy)
// nums остался без изменений
```

---

## Обработка ошибок и граничных случаев

### Пустые срезы

Для большинства функций работа с пустым срезом должна быть безопасной:

- `Filter` вернёт пустой срез;
- `Map` вернёт пустой срез;
- `Any` вернёт `false`;
- `All` вернёт `true` (в терминах логики для пустого множества).

Но для `Min`, `Max`, `Avg` ситуация сложнее. Здесь есть варианты:

- паника;
- возврат нулевого значения и флага успеха;
- возврат ошибки.

Давайте разберемся на примере функции с безопасной семантикой:

```go
// MaxSafe возвращает максимум и флаг успеха
max, ok := libslice.MaxSafe(nums)
if !ok {
    // Пустой срез - максимум не определён
    fmt.Println("нет значений для поиска максимума")
} else {
    fmt.Println("max =", max)
}
```

Совет: при изучении конкретной реализации `lib-slice` обязательно посмотрите документацию к таким функциям.

### Индексы и выход за границы

Функции `Insert`, `Delete` и подобные работают с индексами. Нужно понимать, как библиотека реагирует на некорректные индексы:

- паникует;
- молча игнорирует;
- возвращает ошибку.

Безопасная форма может выглядеть так:

```go
// Пытаемся удалить по индексу c проверкой
nums2, err := libslice.DeleteSafe(nums, idx)
if err != nil {
    // Индекс вышел за границы или другая проблема
    log.Println("ошибка удаления:", err)
}
```

Если вы используете версию без ошибок, будьте внимательны к диапазонам: чаще всего там используется обычный индексный доступ, который при выходе за границы приведёт к панике.

---

## Практический пример: фильтрация, группировка и агрегирование

Чтобы связать всё вместе, давайте посмотрим на условный реальный кейс. Представим, что у вас есть лента транзакций, и нужно:

- взять только успешные транзакции;
- сгруппировать их по пользователю;
- посчитать сумму по каждому пользователю;
- выбрать топ-3 по сумме.

### Описание структуры

```go
// Transaction описывает платёж или перевод
type Transaction struct {
    ID       int
    UserID   int
    Amount   int64  // сумма в минимальных единицах (например в копейках)
    Status   string // "ok" "failed" и т.д.
}
```

### Шаг 1. Фильтрация успешных

```go
// Фильтруем только успешные транзакции
successTx := libslice.Filter(allTx, func(t Transaction) bool {
    // Нас интересуют только транзакции со статусом "ok"
    return t.Status == "ok"
})
```

### Шаг 2. Группировка по UserID

В `lib-slice` может быть готовая функция `GroupBy`, но если её нет, можно использовать `Reduce`. Здесь я размещаю пример с возможной `GroupBy`:

```go
// Группируем по полю UserID
byUser := libslice.GroupBy(successTx, func(t Transaction) int {
    // Ключ группировки - идентификатор пользователя
    return t.UserID
})
```

Предположим, тип `byUser` — `map[int][]Transaction`.

### Шаг 3. Сумма по пользователю

```go
// Структура для итоговой статистики по пользователю
type UserTotal struct {
    UserID int
    Total  int64
}

// Создаём срез агрегированных значений
totals := make([]UserTotal, 0, len(byUser))

// Проходим по карте групп
for userID, txs := range byUser {
    // Считаем сумму по срезу транзакций
    sum := libslice.Reduce(txs, int64(0), func(acc int64, t Transaction) int64 {
        // Накапливаем значение поля Amount
        return acc + t.Amount
    })

    // Добавляем агрегированную запись в итоговый срез
    totals = append(totals, UserTotal{
        UserID: userID,
        Total:  sum,
    })
}
```

### Шаг 4. Выбор топ-3 пользователей

Теперь нужно отсортировать и взять первые три элемента. В `lib-slice` может быть обертка над `sort.Slice`:

```go
// Сортируем по Total по убыванию
libslice.SortBy(totals, func(a, b UserTotal) bool {
    // Возвращаем true если a должен идти раньше b
    return a.Total > b.Total
})

// Берём только первые 3 записи если их достаточно
topN := 3
if len(totals) < topN {
    topN = len(totals)
}
top := totals[:topN]
```

В результате код получается довольно декларативным: вы работаете с «фильтровать», «группировать», «суммировать», «сортировать» — а не с низкоуровневыми циклами.

---

## Заключение

Слайс либы `lib-slice` помогает выстроить работу со срезами в Go в более высокоуровневом стиле. Вместо множества однотипных циклов вы получаете:

- функции поиска и проверки (Find, Index, Contains, Any, All);
- фильтрацию и преобразование (Filter, Map, RemoveEmpty);
- агрегирование (Sum, Min, Max, Avg, Reduce);
- операции уникальности и множеств (Unique, Union, Intersect, Difference);
- утилиты для изменения структуры (Insert, Delete, Reverse, Shuffle, Clone);
- обобщённый API с generics и ограничениями типов.

При этом важно понимать, что:

- каждая функция имеет свои правила обработки пустых срезов;
- некоторые операции могут модифицировать исходный срез;
- вложенные вызовы (Filter → Map → Reduce) повышают выразительность кода, но требуют внимания к производительности.

Использование такой библиотеки уместно, если:

- вы часто работаете с безындексными операциями над срезами;
- хотите сделать код декларативным и понятным;
- готовы придерживаться определённых соглашений по названию и семантике функций.

Если вы только начинаете знакомиться с `lib-slice`, имеет смысл сначала освоить базовые операции (Filter, Map, Find), а затем постепенно добавлять остальные инструменты по мере необходимости.

---

## Частозадаваемые технические вопросы по lib-slice

### Как подключить lib-slice к проекту и зафиксировать версию

1. Выполните команду:

   ```bash
   go get github.com/your-org/lib-slice@v1.2.3
   ```

   // Здесь v1.2.3 - нужная вам версия

2. Проверьте, что в go.mod появилась строка с этой зависимостью.
3. Импортируйте пакет в коде:

   ```go
   import libslice "github.com/your-org/lib-slice"
   ```

### Как понять, модифицирует ли функция исходный срез

1. Откройте документацию или исходный код функции.
2. Ищите комментарии вида:

   ```go
   // Reverse reverses the slice in place
   ```

3. Если явно не указано - посмотрите, создаётся ли новый срез через `make` или используется входной.
4. При сомнении делайте клон перед вызовом:

   ```go
   s2 := libslice.Clone(s)
   libslice.SomeFunc(s2)
   ```

### Как использовать lib-slice без generics в старых версиях Go

1. Если ваш проект на Go ниже 1.18, ищите старую версию библиотеки без generics.
2. В go.mod зафиксируйте мажорную версию, например:

   ```bash
   go get github.com/your-org/lib-slice@v0.9.0
   ```

3. Используйте типизированные функции, такие как `FilterInts`, `MapStrings` и т.п.

### Как отлаживать сложные цепочки Filter/Map/Reduce

1. Разбейте длинную цепочку на несколько промежуточных переменных.
2. После каждого шага выводите размер среза и пару элементов:

   ```go
   step1 := libslice.Filter(...)
   log.Println("после Filter:", len(step1))

   step2 := libslice.Map(step1, ...)
   log.Println("после Map:", len(step2))
   ```

3. Это поможет быстро найти, на каком шаге данные становятся некорректными.

### Как контролировать аллокации при интенсивном использовании lib-slice

1. Используйте профилировщик `go test -bench . -benchmem` или `pprof`.
2. Обратите внимание на функции, которые создают новые срезы (`Filter`, `Map`, `Unique`).
3. Для горячих участков:
   - по возможности используйте версии, работающие in-place;
   - заранее выделяйте срез с нужной ёмкостью и передавайте его в функции, если API это позволяет.