---
metaTitle: Добавление файлов в индекс в Git - полное руководство по git add
metaDescription: Узнайте как команда git add добавляет файлы в индекс Git - разберите синтаксис режимы работы и типичные сценарии использования с практическими примерами
author: Олег Марков
title: Добавление файлов в индекс в Git - команда git add
preview: Исследуйте как git add подготавливает файлы к коммиту - разберитесь с индексом шаблонами выбора файлов и типичными ошибками при работе с Git
---

## Введение

Команда git add — это первый обязательный шаг перед созданием коммита. Без нее Git просто не узнает, какие именно изменения вы хотите сохранить в истории проекта. Смотрите, я покажу вам, как это работает и почему правильное использование git add сильно влияет на качество вашей истории коммитов.

Главная идея: в Git есть три основных состояния данных:

- рабочая директория — реальные файлы на диске, которые вы редактируете;
- индекс (staging area) — промежуточная область, где вы собираете набор изменений для будущего коммита;
- история (repository) — уже сделанные коммиты.

Команда git add как раз перемещает изменения из рабочей директории в индекс. Давайте разбираться подробнее, что именно она делает, какие у нее есть режимы и как избежать типичных ошибок.

## Что такое индекс (staging area) и зачем он нужен

Прежде чем смотреть на git add, важно понять, что такое индекс.

Индекс — это снимок состояния файлов, который будет использован при следующем коммите. Он позволяет:

- подготовить только часть изменений из файла;
- собрать один логичный коммит из изменений в разных файлах;
- отложить какие-то изменения «на потом»;
- контролировать, что именно попадет в историю.

Проще говоря, индекс — это ваш «черновик коммита». Пока изменения не добавлены в индекс, команда git commit их не увидит.

Давайте посмотрим, как это выглядит в простой последовательности действий:

1. Вы изменили файлы в рабочей директории.
2. Проверили состояние репозитория через:
   ```bash
   git status
   ```
3. Добавили нужные изменения в индекс:
   ```bash
   git add файл_или_путь
   ```
4. Сделали коммит:
   ```bash
   git commit -m "Сообщение коммита"
   ```

git add отвечает именно за шаг номер 3.

## Базовое использование git add

### Добавление одного конкретного файла

Самый простой вариант — добавить один файл в индекс. Давайте разберемся на примере.

Представим, что вы изменили файл main.py и хотите включить его в следующий коммит:

```bash
git add main.py
```

Что здесь происходит:

- Git сравнивает содержимое файла main.py в рабочей директории с версией, которая хранится в последнем коммите;
- разница (дифф) записывается в индекс;
- команда git commit при следующем запуске возьмет именно эту версию файла из индекса.

Если вы после этого еще раз измените main.py, то новые изменения в индекс автоматически не попадут. Вам снова нужно будет выполнить git add main.py. Это важный момент: индекс не синхронизируется сам по себе.

### Добавление нескольких файлов списком

Вы можете указать несколько файлов подряд:

```bash
git add main.py utils.py README.md
```

Git добавит все перечисленные файлы. Это удобно, когда вы осознанно выбираете набор файлов для одного коммита.

### Добавление всех измененных и новых файлов

Частый сценарий — быстро добавить все изменения в проекте.

Самый популярный вариант:

```bash
git add .
```

Комментарии к этому примеру:

- точка означает «текущая директория и все вложенные поддиректории»;
- будут добавлены новые файлы и измененные файлы;
- файлы, которые были удалены в файловой системе, в индекс таким способом добавлены не будут (об удалении поговорим отдельно).

Есть и другой вариант:

```bash
git add -A
```

или эквивалент:

```bash
git add --all
```

Здесь поведение немного иное:

- добавляются новые файлы;
- добавляются изменения существующих файлов;
- фиксируется информация об удаленных файлах — то есть Git запомнит, что файл был удален, и коммит затем также его удалит из репозитория.

Команда git add -u (update) еще один похожий режим:

```bash
git add -u
```

Она:

- добавляет изменения и удаления уже отслеживаемых файлов;
- но не добавляет новые неотслеживаемые файлы (untracked).

Смотрите, как это обычно выглядит в работе:

```bash
git status
# Вы видите, что изменены несколько файлов и один файл удален

git add -A
# Подготовили все изменения, включая удаление файла

git commit -m "Обновил логику и удалил устаревший модуль"
```

## Поведение git add с разными типами файлов

### Отслеживаемые и неотслеживаемые файлы

Файлы в Git могут быть:

- отслеживаемыми (tracked) — уже добавлялись в индекс хотя бы раз и попали в коммит;
- неотслеживаемыми (untracked) — Git их видит, но пока не учитывает в истории;
- игнорируемыми (ignored) — попадают под правила .gitignore.

Команда git add:

- может перевести файл из состояния untracked в tracked;
- обновляет содержимое файла в индексе, если он уже tracked;
- не добавляет по умолчанию файлы, попадающие под игнорирование (.gitignore), если вы явно не попросите.

Пример:

```bash
# Создали новый файл
echo "test" > notes.txt

# Git показывает его как неотслеживаемый
git status

# Добавляем в индекс
git add notes.txt

# Теперь файл отслеживается и при следующем коммите попадет в историю
git commit -m "Добавил notes.txt"
```

### Взаимодействие с .gitignore

Если файл или путь указан в .gitignore, то команда git add . их не добавит.

Например, в корне репозитория лежит .gitignore:

```text
node_modules/
*.log
```

- папка node_modules и все ее содержимое не будут добавлены в индекс;
- файлы с расширением .log также не будут добавляться при git add . или git add -A.

Если все же нужно добавить игнорируемый файл явно, используйте опцию:

```bash
git add -f debug.log
```

Комментарии:

- флаг -f (force) говорит Git: «я понимаю, что файл игнорируется, добавь его все равно»;
- это стоит делать осознанно, чтобы не затянуть случайно большие временные файлы в репозиторий.

## Добавление каталогов и использование шаблонов

### Добавление целой директории

Вы можете добавить целую папку:

```bash
git add src/
```

В этом случае:

- будут добавлены все файлы и подпапки внутри src;
- будут проигнорированы файлы, описанные в .gitignore (если путь совпадает с правилами).

Это удобный способ, если вы хотите подготовить к коммиту изменения только в определенной части проекта, например, в модуле src, не затрагивая documentation или scripts.

### Использование шаблонов (глобов)

Git поддерживает шаблоны путей:

```bash
git add *.py
git add src/**/*.js
```

Пояснения:

- *.py — добавит все файлы с расширением .py в текущей директории;
- src/**/*.js — добавит все файлы с расширением .js во всех подпапках директории src (две звездочки означают рекурсивный поиск).

Давайте посмотрим, что происходит в следующем примере:

```bash
# Добавляем все Python-файлы в папке scripts
git add scripts/*.py

# Добавляем все конфигурационные файлы .yml где бы они ни лежали
git add "**/*.yml"
```

Комментарии к примеру:

- двойные кавычки часто полезны в Windows или при сложных шаблонах, чтобы оболочка не изменила строку до того, как ее увидит Git;
- такие шаблоны удобны, если вы хотите сделать, например, коммит только по тестам или только по конфигурации.

## Частичное добавление изменений в файл

Иногда вам нужно включить в один коммит не все изменения файла, а только их часть. Например, вы случайно поправили форматирование и логику в одном файле, а хотите разделить это на два осмысленных коммита.

Здесь помогает режим интерактивного добавления.

### Режим git add -p (patch)

Команда:

```bash
git add -p файл
```

или просто:

```bash
git add -p
```

(во втором случае Git последовательно предложит вам все изменения во всех файлах).

Что делает этот режим:

- разбивает изменения в файле на небольшие фрагменты (hunks);
- показывает каждый фрагмент и спрашивает, добавлять его в индекс или нет;
- позволяет выбирать, какие части изменений пойдут в этот коммит.

Когда вы выполните git add -p, увидите диалог вида:

```text
diff --git a/main.py b/main.py
@@ -10,6 +10,10 @@
- old line
+ new line

Stage this hunk [y,n,q,a,d,s,e,?]?
```

Основные ответы:

- y — добавить этот фрагмент в индекс;
- n — пропустить этот фрагмент;
- a — добавить этот и все последующие фрагменты файла;
- d — пропустить этот и все последующие фрагменты;
- s — разделить фрагмент на более мелкие;
- q — выйти, не обрабатывая остальные.

Обратите внимание, как этот режим помогает вам структурировать коммиты: вы можете в одном файле подготовить несколько логических коммитов, добавляя разные фрагменты по очереди.

### Частичное добавление по имени файла

Есть еще один вариант — если вы хотите добавить только уже отслеживаемые файлы, не включая новые.

```bash
git add -u path/
```

или:

```bash
git add -u
```

Здесь ключ -u (update) говорит: «обнови в индексе только то, что уже отслеживается». Этот режим часто используют, когда новые файлы пока не готовы к коммиту.

## Работа с удалением файлов через git add

Когда вы удаляете файл средствами файловой системы (через rm, del или проводник), Git видит это как изменение рабочего дерева.

Если выполнить:

```bash
git status
```

вы увидите удаленный файл в разделе «Changes not staged for commit».

Чтобы зафиксировать сам факт удаления в индексе, можно:

```bash
git add удаленный_файл
```

Git поймет, что файл был удален в рабочей директории, и пометит его как «удаленный» в индексе. При следующем коммите этот файл исчезнет из репозитория.

Чуть более типичный способ — использовать команду git rm, которая одновременно удаляет файл из файловой системы и добавляет это удаление в индекс:

```bash
git rm obsolete.txt
# Файл удален и изменение попадет в следующий коммит
```

Но справедливо помнить, что git add тоже умеет «подтверждать» удаление, если файл уже отсутствует на диске.

## Проверка, что именно вы добавили в индекс

Прежде чем делать коммит, полезно убедиться, какие именно изменения сейчас находятся в индексе.

### Команда git status

Классический вариант:

```bash
git status
```

Вы увидите две группы изменений:

- Changes to be committed — то, что уже находится в индексе;
- Changes not staged for commit — то, что изменено в рабочей директории, но еще не добавлено в индекс.

Это помогает отличать:

- изменения, которые точно попадут в следующий коммит;
- изменения, которые пока «висят» в рабочей директории.

### Просмотр диффа индекса

Если вы хотите увидеть конкретные строки кода, которые сейчас подготовлены к коммиту, используйте:

```bash
git diff --cached
```

или:

```bash
git diff --staged
```

Это одно и то же. Команда показывает разницу между:

- последним коммитом;
- и текущим индексом.

То есть то, что вы уже добавили через git add.

Если хотите увидеть разницу между индексом и рабочей директорией (то есть «что еще не добавлено»), используйте:

```bash
git diff
```

Здесь я размещаю краткую сводку:

- git diff — показывает изменения, которые еще не в индексе;
- git diff --cached — показывает изменения, которые уже в индексе.

## Как отменить добавление в индекс

Бывает, вы по ошибке сделали git add . и подготовили к коммиту слишком много файлов. Смотрите, как исправить ситуацию.

### Удаление файла из индекса, не трогая рабочую директорию

Если вы добавили файл через git add, но еще не сделали коммит, вы можете «вернуть» его из индекса обратно в состояние «просто изменен в рабочей директории».

Используется команда:

```bash
git restore --staged файл
```

Комментарии:

- флаг --staged говорит «работай с индексом»;
- файл останется измененным на диске, но перестанет быть частью следующего коммита.

Аналогично для всех файлов:

```bash
git restore --staged .
```

или:

```bash
git reset HEAD файл
```

Здесь:

- HEAD — текущий коммит;
- git reset HEAD файл сбрасывает состояние файла в индексе к тому, что хранится в текущем коммите;
- рабочая директория не меняется.

### Полный сброс индекса к последнему коммиту

Если вы хотите полностью очистить индекс и вернуть его к состоянию последнего коммита, можно выполнить:

```bash
git reset
```

Эта команда:

- сбросит все добавленные в индекс изменения;
- оставит сами файлы в рабочей директории измененными.

После этого вы снова сможете выбирать, что именно добавить в индекс, более аккуратно.

## Взаимодействие git add с другими командами Git

### Связка git add и git commit

Чаще всего git add идет в паре с git commit:

```bash
git add file1 file2
git commit -m "Осмысленное описание изменений"
```

Но есть и сокращенная форма:

```bash
git commit -am "Сообщение"
```

Флаг -a говорит git commit:

- автоматически добавить в индекс все измененные и удаленные отслеживаемые файлы;
- но не добавлять новые untracked файлы.

Важно: git commit -am не заменяет git add для новых файлов. Для них вы обязательно должны хотя бы один раз явно вызвать git add.

### Связка git add и git stash

Если вы добавили что-то в индекс, а затем решили временно отложить изменения (stash), также стоит помнить:

- git stash по умолчанию учитывает только изменения в рабочей директории, но не всегда ожидаемо ведет себя с уже проиндексированными изменениями;
- есть режимы, которые работают и с индексом, и без.

Чтобы однозначно сохранить и рабочие изменения, и индекс, чаще всего используют:

```bash
git stash push -m "Описание" --include-untracked
```

Но в контексте git add ключевая мысль такая: индекс — это отдельный слой, и многие команды Git умеют с ним работать по-разному, поэтому перед серьезными действиями (stash, reset, checkout) полезно проверить git status.

## Практические сценарии использования git add

### Сценарий 1. Разделение логических изменений в один файл на два коммита

Представим, вы:

- в файле main.py исправили баг;
- и заодно отформатировали код (например, автоформатером).

Вы хотите сделать:

- один коммит «Fix bug»;
- второй коммит «Format code».

Покажу вам, как это реализовано на практике:

```bash
# Смотрим изменения
git diff main.py

# Добавляем только часть, относящуюся к багу
git add -p main.py
# В диалоге внимательно выбираем фрагменты кода, относящиеся к исправлению

git commit -m "Fix bug in main logic"

# Теперь в индекс не добавлены фрагменты с форматированием
# Добавляем оставшееся
git add main.py

git commit -m "Reformat main.py"
```

В итоге в истории у вас два понятных и независимых коммита, хотя изменения были сделаны в один заход.

### Сценарий 2. Добавление только одного модуля из большого проекта

В большом репозитории вы меняли код в нескольких модулях, но часть изменений еще не готова. Вы хотите сделать коммит только по модулю src/payment.

Давайте посмотрим:

```bash
# Проверяем общее состояние
git status

# Добавляем только папку payment
git add src/payment/

# Проверяем, что именно попало в индекс
git status
git diff --cached

# Если все устраивает — коммитим
git commit -m "Обновление логики платежей"
```

Остальные изменения в других модулях останутся только в рабочей директории и не попадут в коммит.

### Сценарий 3. Быстрая подготовка всего проекта к коммиту

В небольших проектах бывает удобно просто добавить все изменения целиком:

```bash
git add -A
git commit -m "Обновление проекта"
```

Но даже в таком простом сценарии полезно:

- перед git add -A выполнить git status, чтобы убедиться, что в проекте нет лишних файлов;
- при необходимости скорректировать .gitignore, чтобы не тянуть в историю временные файлы, секреты или большие бинарники.

## Типичные ошибки при использовании git add и как их избежать

### Случайный git add . в корне репозитория

Одна из самых распространенных ситуаций: вы выполняете git add . в корне проекта и случайно добавляете:

- служебные файлы IDE;
- большие файлы (например, архивы или дампы баз данных);
- локальные конфигурации с паролями.

Как действовать:

1. Выполнить git status и посмотреть, что именно попало в индекс.
2. Если там есть лишнее, убрать их из индекса:

   ```bash
   git restore --staged путь/к/лишнему_файлу
   ```

3. При необходимости добавить путь в .gitignore, чтобы в будущем такие файлы не попадали под git add .:

   ```text
   # В .gitignore
   .idea/
   *.log
   *.bak
   ```
4. Повторно выполнить git status и убедиться, что в индексе остались только нужные файлы.

### Добавление секретных данных

Ошибка похуже — добавить в индекс и закоммитить файл с паролями или токенами.

Правильный порядок действий:

1. До коммита, если вы заметили проблему:

   ```bash
   git restore --staged config/secrets.yml
   # или
   git reset HEAD config/secrets.yml
   ```

2. Добавить файл в .gitignore.

3. Перенести секреты в защищенное хранилище или переменные окружения.

Если же вы уже закоммитили такие данные, вопрос выходит за рамки простого git add — придется перезаписывать историю (git filter-repo, git filter-branch) и инвалидировать утекшие секреты.

### Непонимание разницы между git add и git commit -am

Новички часто думают, что git commit -am полностью заменяет git add. Это не так:

- git commit -am обновляет в индексе только уже отслеживаемые файлы;
- новые файлы никуда не попадут без явного git add.

Чтобы не запутаться:

- для новых файлов всегда используйте git add;
- git commit -am годится как удобное сокращение для типичных правок в уже существующих файлах, но не вместо git add в целом.

## Заключение

Команда git add — это точка, в которой вы принимаете решение, какие изменения действительно должны попасть в следующий коммит. Она работает с индексом, а индекс — это ваш контролируемый «черновик» будущей записи в истории.

Ключевые моменты, которые важно запомнить:

- git add добавляет изменения в индекс, но не создает коммит;
- индекс отделен от рабочей директории и истории;
- есть разные режимы: добавление конкретного файла, директории, всех изменений, только уже отслеживаемых файлов;
- вы можете добавлять изменения частями через git add -p;
- всегда полезно проверять результат через git status и git diff --cached;
- если вы ошиблись с git add, это легко отменить через git restore --staged или git reset HEAD файл.

Используя git add осознанно, вы делаете историю проекта понятной: каждый коммит отражает логическое изменение, а не случайный набор правок.

## Частозадаваемые технические вопросы по теме и ответы

### Как добавить только новые файлы, не затрагивая измененные

Используйте команду с шаблонами или явным указанием путей:

```bash
# Добавить только неотслеживаемые файлы
git ls-files --others --exclude-standard | xargs git add
```

Комментарии:

- git ls-files --others --exclude-standard выводит список только новых файлов, которые не игнорируются;
- xargs git add передает их в git add;
- измененные отслеживаемые файлы в индекс не попадут.

### Как исключить один конкретный файл при git add .

Если вы хотите добавить «все, кроме одного файла», используйте два шага:

```bash
git add .
git restore --staged путь/к/файлу
```

Первой командой вы добавляете все, второй — убираете ненужный файл из индекса. Сам файл на диске остается без изменений.

### Как добавить в индекс символические ссылки и не получить неожиданных эффектов

По умолчанию git add добавляет саму ссылку, а не содержимое по ссылке. Убедиться в том, что все корректно, можно через:

```bash
git ls-files -s
```

В списке будет тип 120000 для символических ссылок. Ничего дополнительного делать не нужно — главное не разыменовывать ссылки утилитами до git add.

### Как добавить файл, имя которого начинается с дефиса

Если имя файла начинается с -, Git может воспринимать это как опцию. В таком случае используйте специальный разделитель:

```bash
git add -- -myfile.txt
```

Комментарии:

- двойной дефис говорит Git, что дальше нет опций, только имена файлов;
- так вы избежите конфликтов с флагами.

### Как добавить изменения только в определенной строке файла

Git не умеет добавлять буквально отдельные строки, но позволяет точно контролировать фрагменты через git add -p и опцию s (split):

```bash
git add -p file.txt
# При появлении крупного фрагмента выберите s
# Git попробует разделить его на более мелкие части
```

Так вы сможете включить в индекс лишь небольшую часть изменений, максимально приблизившись к уровню отдельных строк.