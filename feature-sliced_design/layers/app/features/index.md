---
metaTitle: Слой features в архитектуре фронтенда - как выделять и организовывать фичи
metaDescription: Разбор слоя features в фронтенд архитектуре на примере FSD - как выделять фичи организовывать код и избегать типичных ошибок разделения ответственности
author: Олег Марков
title: Слой features - features-layer в архитектуре фронтенда
preview: Подробный разбор слоя features в архитектуре приложений по FSD - от принципов выделения фич и структуры каталогов до примеров кода и интеграции с остальными слоями
---

## Введение

Слой features (features-layer) часто становится поворотной точкой в архитектуре фронтенда. До его появления проект выглядит как набор страниц или компонентов, а после — как система бизнес-возможностей, которые можно переиспользовать, комбинировать и развивать.

Здесь важно не просто «сложить код в папку features», а понять, **что такое фича**, как она живет в архитектуре и как правильно выстраивать зависимости между слоями. Именно от этого зависит, превратится ли ваш проект в удобно масштабируемую систему или в ещё один «слоеный монолит» с кучей связей.

В статье вы увидите:

- Как понимать слой features в современной архитектуре (на примере Feature-Sliced Design).
- Чем фича отличается от виджета, страницы и сущности.
- Как проектировать и именовать фичи.
- Как строить структуру файлов и модулей внутри фичи.
- Как фичи взаимодействуют с сущностями (entities), виджетами (widgets) и страницами (pages).
- Типичные ошибки и практические примеры кода.

Давайте разбираться по шагам.

## Что такое слой features

### Основная идея слоя features

Слой features описывает **прикладные возможности** (application features), которые доступны пользователю или системе:

- отправить форму авторизации;
- добавить товар в корзину;
- оформить заказ;
- подписаться на рассылку;
- добавить комментарий;
- сменить язык интерфейса.

То есть фича — это **конкретное действие, которое приносит пользу пользователю**. При этом сама фича:

- обычно **узко сфокусирована** (одна задача);
- **собирает вместе** разные сущности и технологии;
- имеет собственный **UI, бизнес-логику, побочные эффекты**;
- должна быть **переиспользуемой**: фича может появляться на разных страницах или в разных виджетах.

Смотрите, можно представить слой features как библиотеку «умных LEGO-блоков», которые уже знают, как работать с данными и как взаимодействовать с пользователем. Дальше эти блоки собираются в виджеты и страницы.

### Место слоя features в архитектуре

Если ориентироваться на FSD (Feature-Sliced Design), типичный стек слоёв выглядит так:

- app — инициализация приложения, роутинг, глобальные провайдеры;
- processes — сквозные сценарии (onboarding, checkout-процесс);
- pages — страницы, композиция виджетов и фич;
- widgets — крупные UI-области страницы;
- features — фичи (прикладные возможности);
- entities — бизнес-сущности (User, Product, Order);
- shared — переиспользуемые, не доменно-зависимые модули (UI, lib, api, config).

Здесь слой features:

- **использует**:
  - сущности из entities;
  - общие модули из shared.
- **не знает**:
  - о страницах (pages);
  - о виджетах (widgets);
  - о приложении (app);
  - о процессах (processes).

Так выстраивается направленная ациклическая зависимость: верхние слои опираются на нижние, но не наоборот.

### Чем фича отличается от других слоёв

Это важный момент, который часто вызывает путаницу.

- **Feature vs Entity**  
  Entity — это **что** (User, Product).  
  Feature — это **что можно сделать** (LoginByEmail, AddProductToCart).

- **Feature vs Widget**  
  Widget — это **область интерфейса** (Header, ProductListWidget, ProfileSidebar).  
  Feature — это **действие/возможность** (ChangePassword, ToggleTheme, AddToFavorites).  
  Фича может быть встроена внутрь разных виджетов.

- **Feature vs Page**  
  Page — это **контейнер для композиции**: собирает виджеты и фичи в конечный экран.  
  Feature — одна конкретная возможность, которая может использоваться на разных страницах.

## Критерии выделения фичи

### Признаки хорошей фичи

Хорошо выделенная фича обычно отвечает нескольким признакам:

1. **Ясная пользовательская цель**  
   Можно сформулировать фичу как законченный сценарий: «пользователь может…».

   Примеры:
   - user-can-login-by-username-and-password;
   - user-can-add-product-to-cart;
   - user-can-change-interface-language.

2. **Локализованное состояние и логика**  
   Состояние формы, валидация, запросы к API, локальные обработки ошибок — всё это живет внутри фичи, а наружу она отдает уже «готовый интерфейс» и/или методы.

3. **Потенциальное переиспользование**  
   Фича не привязана жестко к одной странице. Например, авторизация по паролю может быть:
   - на отдельной странице login;
   - в модальном окне;
   - во всплывающем блоке при попытке оформить заказ.

4. **Четкий контракт на границе**  
   Фича должна явно описывать:
   - какие параметры она принимает;
   - какие события/коллбэки «пробрасывает» наружу;
   - какие данные возвращает (при необходимости).

Давайте разберем на простом примере.

### Пример: выделение фичи «Добавление товара в корзину»

Сценарий: пользователь может добавить товар в корзину с карточки товара или из списка.

Слой entities уже может содержать:

- entities/product
- entities/cart

Слой features может получить фичу:

- features/add-to-cart

Эта фича:

- принимает на вход данные товара (или его id);
- вызывает соответствующий use-case изменения корзины;
- отображает кнопку «Добавить» / «В корзине»;
- показывает спиннер/ошибку/уведомление.

Эта же фича может использоваться:

- в карточке товара (widget ProductCard);
- в модальном окне с деталями товара;
- на странице деталей товара.

Важно, что фича **не знает**, где именно её отрисуют.

### Что не должно быть фичей

Иногда разработчики пытаются сделать фичей всё подряд:

- «LeftSidebar»
- «TopMenu»
- «FooterButtons»

Это скорее виджеты или наборы UI-компонентов. У них нет самостоятельной пользовательской цели, они лишь **контейнеры** для фич или сущностей.

Если вы не можете описать модуль как «пользователь может сделать X» — вероятно, это не фича.

## Структура слоя features

### Общая структура папки features

На уровне проекта часто используют такую структуру:

- src/
  - features/
    - add-to-cart/
    - login-by-username/
    - change-theme/
    - toggle-favorite/
    - …

Каждая фича — это **отдельная папка**. Внутри фичи обычно используются подмодули по смыслу, например по типам «public API» и внутренней реализации.

Давайте посмотрим на распространенный вариант:

- features/
  - add-to-cart/
    - ui/
    - model/
    - lib/
    - api/
    - config/
    - index.ts

Где:

- ui — компоненты, которые участвуют в реализации фичи;
- model — состояние, сторы, хук-логика, эффекты;
- lib — вспомогательные функции именно для этой фичи;
- api — адаптеры для запросов;
- config — настройки фичи;
- index.ts — публичный API фичи (entry-point).

Структура может меняться в зависимости от стека (React, Vue, Zustand, Redux Toolkit, Effector и т.д.), но принцип остаётся: фича инкапсулирует всё, что ей нужно, и наружу вы отдаете только то, что нужно другим слоям.

### Публичный API фичи

Ключевая идея — **фича должна экспортировать наружу только минимальный необходимый интерфейс**. Обычно это:

- UI-компоненты;
- функции/хуки для запуска логики;
- типы и константы (если нужны извне).

Например, для React-приложения:

```ts
// features/add-to-cart/index.ts
export { AddToCartButton } from './ui/AddToCartButton'
export type { AddToCartButtonProps } from './ui/AddToCartButton'
```

Комментарии:

// Здесь мы определяем публичный API фичи add-to-cart
// Внешние слои (widgets, pages) могут использовать только то, что экспортировано из index.ts
// Внутренние модули (model, lib, api) остаются скрытыми и могут меняться без влияния на остальную систему
```

Теперь вы увидите, как это выглядит в коде при использовании, например, в виджете:

```tsx
// widgets/product-card/ui/ProductCard.tsx
import { AddToCartButton } from 'features/add-to-cart'
import { Product } from 'entities/product'

type ProductCardProps = {
  product: Product
}

export function ProductCard(props: ProductCardProps) {
  const { product } = props

  return (
    <article>
      {/* Здесь мы показываем название и цену товара */}
      <h3>{product.title}</h3>
      <p>{product.price} ₽</p>

      {/* Смотрите, мы используем фичу add-to-cart как готовый UI-блок */}
      <AddToCartButton productId={product.id} />
    </article>
  )
}
```

Комментарии:

// Виджет ProductCard не знает, как именно реализована логика добавления в корзину
// Он просто использует AddToCartButton из фичи add-to-cart
// Если внутренности фичи изменятся (например, поменяется API корзины), код виджета останется тем же
```

## Реализация фичи шаг за шагом

Теперь давайте пройдем полный цикл: от постановки задачи до кода.

### Постановка задачи: фича «Логин по имени пользователя»

Фича: user-can-login-by-username-and-password.

Функции фичи:

- показать форму с полями username и password;
- валидировать поля;
- отправить запрос к серверу;
- сохранить токен/пользователя (через слой entities);
- показать ошибки и состояние загрузки.

Технические решения:

- форма: React Hook Form или контролируемые компоненты;
- состояние: локальный стейт или store;
- запрос: fetch/axios/RTK Query/и т.п.

### Структура фичи login-by-username

- features/
  - login-by-username/
    - ui/
      - LoginForm.tsx
    - model/
      - types.ts
      - useLoginByUsername.ts
    - api/
      - loginApi.ts
    - index.ts

Смотрите, я покажу вам, как это разложить.

#### Публичный API

```ts
// features/login-by-username/index.ts
export { LoginForm } from './ui/LoginForm'
```

Комментарии:

// Снаружи мы показываем только LoginForm
// Вся остальная реализация остаётся внутри фичи
```

#### API-файл фичи

```ts
// features/login-by-username/api/loginApi.ts

// Здесь мы описываем контракт запроса на логин
export type LoginRequest = {
  username: string
  password: string
}

export type LoginResponse = {
  accessToken: string
  refreshToken?: string
}

// Функция, которая отправляет запрос на сервер
export async function loginByUsername(req: LoginRequest): Promise<LoginResponse> {
  // Обратите внимание, здесь может использоваться общий http-клиент из shared
  const response = await fetch('/api/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(req),
  })

  if (!response.ok) {
    // Здесь мы явно выбрасываем ошибку, чтобы верхний уровень мог её обработать
    throw new Error('Login request failed')
  }

  // Здесь мы приводим ответ к типу LoginResponse
  const data = (await response.json()) as LoginResponse
  return data
}
```

Комментарии:

// loginApi.ts полностью инкапсулирован внутри фичи
// Если контракт бэкенда поменяется, вы меняете только этот файл
// Снаружи достаточно знать, что есть форма LoginForm, которая сама все сделает
```

#### Модель фичи: хук с логикой входа

```ts
// features/login-by-username/model/useLoginByUsername.ts
import { useState } from 'react'
import { loginByUsername, LoginRequest } from '../api/loginApi'
// Допустим, у нас есть сущность user, которая умеет сохранять текущего пользователя
import { useUserStore } from 'entities/user'

type UseLoginByUsernameResult = {
  login: (payload: LoginRequest) => Promise<void>
  isLoading: boolean
  error: string | null
}

export function useLoginByUsername(): UseLoginByUsernameResult {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Здесь мы получаем метод обновления пользователя из слоя entities
  const { setUser } = useUserStore()

  const login = async (payload: LoginRequest) => {
    setIsLoading(true)
    setError(null)

    try {
      const response = await loginByUsername(payload)

      // Здесь мы сохраняем токен, например, в localStorage
      localStorage.setItem('accessToken', response.accessToken)

      // Здесь мы можем запросить профиль пользователя или декодировать токен
      // Сейчас для примера просто вызываем setUser с пустым объектом
      setUser({ username: payload.username })

    } catch (e) {
      // Если что-то пошло не так — сохраняем текст ошибки
      setError('Не удалось войти. Проверьте логин и пароль')
    } finally {
      setIsLoading(false)
    }
  }

  return { login, isLoading, error }
}
```

Комментарии:

// useLoginByUsername инкапсулирует всю логику логина
// Внутри он использует API и сущность user (entities/user)
// Снаружи компоненты работают только с login, isLoading и error
```

#### UI-файл фичи

```tsx
// features/login-by-username/ui/LoginForm.tsx
import { FormEvent, useState } from 'react'
import { useLoginByUsername } from '../model/useLoginByUsername'

export function LoginForm() {
  const [username, setUsername] = useState('')
  const [password, setPassword] = useState('')

  const { login, isLoading, error } = useLoginByUsername()

  const handleSubmit = async (event: FormEvent) => {
    // Предотвращаем перезагрузку страницы
    event.preventDefault()

    // Простейшая валидация на клиенте
    if (!username || !password) {
      // В реальном проекте вы бы завели отдельное состояние для ошибок валидации
      alert('Введите логин и пароль')
      return
    }

    // Здесь мы вызываем бизнес-логику фичи
    await login({ username, password })
  }

  return (
    <form onSubmit={handleSubmit}>
      {/* Поле для имени пользователя */}
      <input
        type="text"
        placeholder="Имя пользователя"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        disabled={isLoading}
      />

      {/* Поле для пароля */}
      <input
        type="password"
        placeholder="Пароль"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        disabled={isLoading}
      />

      {/* Кнопка отправки формы */}
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Входим...' : 'Войти'}
      </button>

      {/* Блок ошибок, если они есть */}
      {error && <p style={{ color: 'red' }}>{error}</p>}
    </form>
  )
}
```

Комментарии:

// LoginForm — это основной публичный UI-компонент фичи
// Он использует хук useLoginByUsername, но не знает деталей реализации авторизации
// Страница или виджет могут просто вставить <LoginForm /> в нужное место
```

### Использование фичи на странице

Теперь давайте посмотрим, как фича подключается в слое pages.

```tsx
// pages/login/ui/LoginPage.tsx
import { LoginForm } from 'features/login-by-username'

export function LoginPage() {
  return (
    <main>
      <h1>Вход в систему</h1>

      {/* Здесь мы просто используем фичу как готовую форму логина */}
      <LoginForm />
    </main>
  )
}
```

Комментарии:

// LoginPage не содержит логики авторизации
// Она занимается только композицией: заголовок, оформление, расположение фичи LoginForm
// Если появятся другие способы авторизации (например, по email или через OAuth), страница просто добавит новые фичи
```

Такой подход делает код **читаемым**, **гибким** и **масштабируемым**.

## Взаимодействие features с другими слоями

### Связь с сущностями (entities)

Чаще всего фичи:

- используют сущности для:
  - чтения данных (например, список товаров);
  - записи изменений (например, обновление корзины или профиля);
- вызывают use-cases / методы store, которые описаны на уровне entities.

Примеры:

- features/add-to-cart → entities/cart;
- features/edit-profile → entities/user;
- features/toggle-favorite → entities/favorite-product.

Хорошая практическая рекомендация: **логика, связанная с бизнес-инвариантами сущности, должна лежать в entities**, а фича только использует её.

Например:

- правило «нельзя добавить в корзину больше N штук одного товара» — в entities/cart;
- логика «показать всплывающее уведомление при успешном добавлении» — в features/add-to-cart.

### Связь с виджетами (widgets)

Виджеты собирают фичи и сущности в конкретные UI-области:

- Header:
  - features/change-theme
  - features/logout
  - entities/user (показать аватар)
- ProductDetailsWidget:
  - entities/product
  - features/add-to-cart
  - features/toggle-favorite

Фичи **не должны импортировать виджеты**. В случае необходимости «общего UI-контейнера» лучше вынести его в shared/ui или в отдельный widget.

### Связь с страницами (pages) и процессами (processes)

Фичи не знают о страницах. Страницы:

- используют готовые фичи;
- комбинируют их с виджетами и сущностями;
- связывают фичи в сценарии (при необходимости — через слой processes).

Например:

- process/checkout использует:
  - features/add-shipping-address;
  - features/select-payment-method;
  - features/confirm-order.

Фича сама по себе **не знает**, участвует ли она в более сложном процессе или просто существует на одной странице.

## Best practices для слоя features

### 1. Именование фич

Старайтесь называть фичи по **действию**, а не по форме или компоненту. Хорошие шаблоны:

- login-by-username
- add-to-cart
- toggle-favorite
- update-profile
- change-password
- change-theme
- filter-products
- upload-avatar

Нежелательные варианты:

- login-form (это UI-форма, но не описывает действие);
- user-card (это сущность/виджет, а не пользовательское действие);
- theme-switcher (может быть фичей, но лучше change-theme — как сценарий).

### 2. Ясный public API

Давайте посмотрим на пример «плохого» и «хорошего» API фичи.

Плохо:

```ts
// features/add-to-cart/index.ts
export * from './ui/AddToCartButton'
export * from './model/useAddToCart'
export * from './api/addToCartApi'
```

Комментарии:

// Здесь наружу «утекли» все внутренности фичи
// Теперь любые изменения внутри могут сломать внешние слои
```

Хорошо:

```ts
// features/add-to-cart/index.ts
export { AddToCartButton } from './ui/AddToCartButton'
export type { AddToCartButtonProps } from './ui/AddToCartButton'
```

Комментарии:

// Внешние слои знают только о компонентах и явных типах фичи
// Внутренние детали (api, model, lib) могут меняться свободно
```

### 3. Не тянуть внутрь фич глобальное состояние без необходимости

Иногда соблазнительно «подключить» глобальный стор приложения прямо в фиче. Лучше:

- хранить локальное состояние, связанное с конкретным UI (форма, локальная ошибка);
- работать с доменным состоянием через entities;
- глобальные cross-cutting вещи (например, toaster-уведомления) выносить в shared.

Например, вместо того чтобы импортировать глобальный Redux-store, вы можете:

- создать в shared/lib функцию showToast;
- внутри фичи просто вызвать showToast('Товар добавлен в корзину').

### 4. Минимизировать пропсы и зависимости

Фича не должна требовать у родителя слишком много данных, если может получить их сама. Обычно вы подаете только:

- идентификаторы или минимальный набор данных;
- коллбэки для внешних реакций (например, `onSuccess`).

Пример:

```tsx
// Хороший вариант: фиче достаточно productId
<AddToCartButton productId={product.id} />

// Плохой вариант: фича знает слишком много деталей
<AddToCartButton
  product={product}
  cart={cart}
  user={user}
  apiClient={apiClient}
/>
```

Комментарии:

// Чем больше фича знает о внешнем окружении, тем сложнее её переиспользовать
// Старайтесь, чтобы фича сама доставала нужные ей сущности из entities и shared
```

### 5. Один сценарий — одна фича

Если модуль начинает выполнять слишком много задач, его стоит разделить. Признаки того, что фича «разрослась»:

- внутри появился сложный роутинг;
- нужно десяток пропсов и контекстов;
- файл UI-компонента стал слишком большим и тяжело читается.

В таких случаях выгодно:

- отделить «вспомогательные действия» в другие фичи;
- оставить в текущей фиче только основной сценарий.

Например:

- вместо одной фичи manage-profile создайте:
  - update-profile-data;
  - change-password;
  - upload-avatar.

## Типичные ошибки при работе со слоем features

### Ошибка 1. Перепутаны уровни ответственности

Пример: фича login-by-username записывает токен прямо в app-level хранилище и управляет роутингом.

Лучше:

- запись токена и текущего пользователя переложить на entities/user (или entities/auth);
- навигацию после успешного логина вынести:
  - либо на уровень страницы;
  - либо в отдельный процесс (например, onboarding после логина).

То есть фича должна «уметь» авторизовать пользователя, но не должна решать за приложение, куда его дальше перенаправить.

### Ошибка 2. Фича знает о страницах или виджетах

Пример:

- features/add-to-cart импортирует компоненты из widgets/ProductList;
- features/login-by-username использует router.push('/profile'), жестко привязываясь к конкретной странице.

Лучше:

- фича просто сообщает наружу о результате (успех/ошибка);
- страница или процесс уже решают, что делать дальше.

Пример для логина:

```tsx
// pages/login/ui/LoginPage.tsx
import { useNavigate } from 'react-router-dom'
import { LoginForm } from 'features/login-by-username'

export function LoginPage() {
  const navigate = useNavigate()

  const handleSuccess = () => {
    // Здесь мы управляем навигацией на уровне страницы
    navigate('/profile')
  }

  return (
    <main>
      <h1>Вход</h1>
      {/* Передаем коллбэк успеха в LoginForm, если мы так её спроектировали */}
      <LoginForm onSuccess={handleSuccess} />
    </main>
  )
}
```

Комментарии:

// Фича login-by-username не знает про роутер и страницы
// Страница login решает, что делать после успешного логина
```

### Ошибка 3. Фичи превращаются в «мини-приложения»

Иногда в одной фиче хотят реализовать:

- собственный роутинг;
- собственную микроструктуру слоев (pages/widgets/entities внутри фичи);
- сложную инициализацию, зависящую от app.

Это резко усложняет архитектуру. Если сценарий настолько сложный, что требует внутренней композиции — возможно, его место в слое **processes**, а не features.

## Заключение

Слой features — это основной слой прикладной логики, который связывает доменные сущности с пользовательскими сценариями. Если вы правильно выделяете фичи и строите их как самостоятельные модули с четким публичным API, проект:

- проще поддерживать и развивать;
- легче реиспользовать куски логики;
- удобнее разделять между командами;
- проще тестировать — как на уровне UI, так и на уровне бизнес-логики.

Ключевые идеи, которые важно удерживать:

- фича описывает действие пользователя, а не просто визуальный блок;
- фича опирается на entities и shared, но не знает о pages, widgets, app;
- каждая фича имеет свой public API и инкапсулирует внутреннюю реализацию;
- один сценарий — одна фича, без чрезмерного нагромождения задач.

Когда вы начнете думать о проекте не как о наборе страниц и компонентов, а как о библиотеке фич, архитектура станет гораздо более предсказуемой и масштабируемой.

## Частозадаваемые технические вопросы по теме

### Как тестировать фичи из слоя features

Для фич удобно использовать два уровня тестов:

1. Unit-тесты модели (model, hooks, бизнес-логика).  
   Здесь вы проверяете:
   - корректность вызовов API;
   - обработку ошибок;
   - работу с сущностями (через моки или тестовые реализации entities).

2. Компонентные тесты UI (например, через React Testing Library).  
   Здесь вы проверяете:
   - поведение формы;
   - состояние кнопок/спиннеров;
   - отображение ошибок.

Главное — тестировать фичу **через её public API**: импортировать только то, что экспортируется из index.ts.

### Как лучше передавать коллбэки из страниц в фичи

Если фича должна сообщить о событии внешнему миру (например, успешный логин), добавьте в её публичный компонент проп onSuccess или похожий. Внутри фичи просто вызывайте этот коллбэк в нужный момент.  
Важно: не завязывайте фичу на конкретный роутер или глобальный стор, если это можно делегировать наружу.

### Как быть с асинхронными фичами и SSR

Если у вас используется SSR, старайтесь:

- выносить асинхронные загрузки данных в entities или в страницы;
- фичам передавать уже готовые идентификаторы/данные, либо использовать универсальные data-fetching хуки, которые корректно работают и на сервере, и на клиенте.

В сложных случаях можно добавить в фичу метод init, который будет вызываться страницей в getServerSideProps или аналогичном механизме.

### Можно ли использовать одну и ту же сущность в нескольких фичах

Да, это нормальный и ожидаемый сценарий. Сущности в entities как раз и нужны для того, чтобы **разные фичи могли использовать общую доменную модель**. Главное — соблюдать инварианты сущности на уровне entities, а не дублировать правила в каждой фиче.

### Как выделять границу между двумя похожими фичами

Смотрите на пользовательский сценарий и контракт. Если:

- у фич разное поведение при успехе/ошибке;
- разные требования к данным;
- разный набор UI-состояний,

то лучше разделить их на отдельные фичи, даже если часть реализации будет похожей. Общую часть можно вынести в shared/lib и использовать в обеих фичах, избегая избыточного дублирования.