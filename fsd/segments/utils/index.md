---
metaTitle: Сегмент utils - библиотека utils-segment в деталях
metaDescription: Разбор библиотеки utils-segment - принципы работы с сегментами, API, типовые сценарии использования и практические примеры для разработчиков
author: Олег Марков
title: Сегмент utils - как эффективно работать с библиотекой utils-segment
preview: Обзор возможностей utils-segment - как создавать и объединять сегменты, фильтровать данные и использовать библиотеку в реальных проектах
---

## Введение

Сегментирование данных — одна из базовых задач в современных приложениях. Вы постоянно делите пользователей на группы, режете временные ряды на интервалы, выделяете фрагменты текста или формируете выборки по условиям. В какой‑то момент такие операции начинают повторяться из проекта в проект, и возникает соблазн вынести их в универсальную утилитную библиотеку.

Здесь на сцену выходит модуль Сегмент utils — условно назовем его `utils-segment`. Это набор вспомогательных функций и типов, которые помогают работать с сегментами:

- диапазонами чисел (например, ID пользователей или временные метки);
- текстовыми диапазонами (позиции в строке, смещения в байтах или runes);
- обобщенными сегментами с произвольным типом границ.

В статье вы увидите, как удобно описывать сегменты через единый интерфейс, как безопасно их объединять, пересекать, вычитать и использовать в фильтрации коллекций. Я покажу вам основы, а также более практичные сценарии, чтобы вы могли быстро встроить `utils-segment` в свой код.

Давайте по шагам разберем, как это устроено.

## Базовые понятия и модель сегмента

### Что такое сегмент в контексте utils-segment

Сегмент — это отрезок на оси значений. Чаще всего это:

- числовой интервал (например, `[10, 20)` — все значения `>= 10` и `< 20`);
- диапазон индексов массива или строки;
- интервал времени (например, минутные, часовые или дневные окна).

Важно, что utils-segment:

1. Явно фиксирует тип границ.
2. Определяет, какие границы включены, а какие нет.
3. Предоставляет единый API для проверки принадлежности значения, пересечения, объединения и т. д.

Обычно в таких библиотеках используется структура вида:

```go
// Segment описывает интервал [Start, End)
// Важно - начало включительно, конец не включительно.
type Segment[T constraints.Ordered] struct {
    Start T // Левая граница интервала - включительно
    End   T // Правая граница интервала - не включительно
}
```

Смотрите, я сразу добавил комментарии, чтобы вам было проще понять, как трактуются границы. Такой полузакрытый интервал `[Start, End)` часто используется, потому что он хорошо сочетается с индексами срезов и упрощает логику объединения и пересечения.

### Инварианты сегмента

Чтобы сегменты работали корректно, библиотека обычно накладывает несколько правил:

- `Start <= End` — сегмент не может иметь отрицательную длину.
- Пустой сегмент — это `Start == End`.
- Для интервала `[a, b)` элемент `x` принадлежит сегменту, если `a <= x && x < b`.

При работе с `utils-segment` проверка инвариантов либо происходит в конструкторе, либо явно документируется как ответственность разработчика. Давайте посмотрим на типичный конструктор.

```go
// NewSegment создает новый сегмент [start, end).
// Если start > end - вернет ошибку.
func NewSegment[T constraints.Ordered](start, end T) (Segment[T], error) {
    if start > end {
        // Здесь мы явно защищаемся от некорректного интервала
        return Segment[T]{}, fmt.Errorf("start > end")
    }
    return Segment[T]{Start: start, End: end}, nil
}
```

Как видите, мы сразу фиксируем два ключевых свойства: типизированность границ и проверку корректности диапазона при создании.

### Типы границ и поддерживаемые значения

В большинстве реализаций подобной утилиты используются generic-типы (через `constraints.Ordered`), что позволяет использовать любой упорядочиваемый тип: числа, строки, время.

Примеры возможных сегментов:

- `Segment[int]` — целочисленные индексы, ID, порядковые номера.
- `Segment[float64]` — вещественные величины, измерения.
- `Segment[time.Time]` — временные интервалы.
- `Segment[string]` — лексикографические диапазоны (например, ключи в БД).

Смотрите, как это может выглядеть в простом коде:

```go
// Сегмент ID пользователей [1000, 2000)
userIDSegment, _ := NewSegment[int](1000, 2000)

// Временной сегмент - один час
start := time.Date(2025, 1, 1, 10, 0, 0, 0, time.UTC)
end := start.Add(time.Hour)
hourSegment, _ := NewSegment[time.Time](start, end)
```

Здесь основная идея — иметь один общий интерфейс для самых разных задач.

## Создание и инициализация сегментов

### Основные способы создания сегмента

Чаще всего в utils-segment есть несколько способов создать сегмент:

1. Через конструктор с проверками.
2. Через “сырой” инициализатор (без проверок).
3. Через вспомогательные функции для популярных типов.

Давайте разберемся на примере.

```go
// 1. Безопасный конструктор с проверкой инвариантов
seg, err := NewSegment[int](10, 20)
if err != nil {
    // Здесь обрабатываем ошибку - например, логируем или возвращаем дальше
}

// 2. Прямой литерал структуры - без проверки
// Используйте его только если уверены в корректности данных.
rawSeg := Segment[int]{Start: 10, End: 20}

// 3. Вспомогательные функции - создают частоиспользуемые сегменты.
func NewOpenEndedRight[T constraints.Ordered](start T) Segment[T] {
    // Сегмент [start, +∞) - правая граница не ограничена
    return Segment[T]{Start: start, End: maxValue[T]()}
}
```

Здесь я показываю, как может выглядеть API с разными уровнями безопасности. В реальной библиотеке имя и конкретный набор функций могут отличаться, но концептуально подход похожий.

### Пустые и специальные сегменты

В utils-segment обычно есть понятие “пустого” сегмента. Это интервал, длина которого равна нулю.

```go
// EmptySegment создает пустой сегмент [x, x)
func EmptySegment[T constraints.Ordered](x T) Segment[T] {
    // Здесь начало и конец совпадают, значит внутри нет ни одного элемента
    return Segment[T]{Start: x, End: x}
}
```

Пустые сегменты удобно использовать:

- как “нейтральный” элемент при последовательных операциях;
- как результат отсутствия пересечения;
- как признак “ничего не найдено”.

Некоторые реализации ввводят еще и “неограниченные” сегменты (от минус бесконечности до плюс бесконечности). Тогда могут использоваться специальные значения, вроде `minValue` и `maxValue` для границ.

```go
// FullSegment создает глобальный сегмент (-∞, +∞)
// В примере max/min абстрактны - зависят от реализации
func FullSegment[T constraints.Ordered]() Segment[T] {
    return Segment[T]{Start: minValue[T](), End: maxValue[T]()}
}
```

## Базовые операции над сегментами

Теперь давайте перейдем к тому, ради чего обычно подключают utils-segment: операции над интервалами.

### Проверка принадлежности значения сегменту

Самая частая операция — проверить, попадает ли значение внутрь заданного сегмента.

```go
// Contains проверяет, принадлежит ли значение val сегменту s.
func (s Segment[T]) Contains(val T) bool {
    // Здесь используем правило [Start, End)
    return val >= s.Start && val < s.End
}
```

Применение:

```go
// Создаем сегмент возрастов [18, 30)
ageSeg, _ := NewSegment[int](18, 30)

// Проверяем возраст пользователя
age := 25
if ageSeg.Contains(age) {
    // Здесь можно дать доступ к разделу "молодая аудитория"
}
```

Как видите, код достаточно простой и хорошо читается.

### Проверка пересечения сегментов

Очень часто нужно понять, пересекаются ли два сегмента (например, два временных окна или два диапазона ID).

```go
// Intersects проверяет, пересекаются ли два сегмента.
// Пересечение есть, если они имеют хотя бы одну общую точку.
func (s Segment[T]) Intersects(other Segment[T]) bool {
    // Пересечение есть, если начало одного меньше конца другого и наоборот
    return s.Start < other.End && other.Start < s.End
}
```

Пример:

```go
// Сегмент запланированной промо-акции
promo, _ := NewSegment[int](10, 20)
// Сегмент текущих активных пользователей по ID
active, _ := NewSegment[int](15, 25)

if promo.Intersects(active) {
    // Здесь мы понимаем - акция затронет часть текущих активных пользователей
}
```

Здесь важно помнить, что используется полузакрытый интервал. То есть `[10, 20)` и `[20, 30)` уже не пересекаются.

### Объединение сегментов

Еще одна типовая операция — объединить два сегмента в один, если они:

- пересекаются;
- или “соприкасаются” вплотную (конец одного равен началу другого).

Посмотрим, как это может быть реализовано.

```go
// Union пытается объединить два сегмента.
// Если сегменты не пересекаются и не соприкасаются - возвращает false.
func (s Segment[T]) Union(other Segment[T]) (Segment[T], bool) {
    // Если сегменты не пересекаются и не касаются - объединить нельзя
    if s.End < other.Start || other.End < s.Start {
        return Segment[T]{}, false
    }

    // Находим минимальное начало и максимальный конец
    start := min(s.Start, other.Start)
    end := max(s.End, other.End)

    // Возвращаем объединенный сегмент и признак успеха
    return Segment[T]{Start: start, End: end}, true
}
```

Применение:

```go
s1, _ := NewSegment[int](10, 20)
s2, _ := NewSegment[int](20, 30)

merged, ok := s1.Union(s2)
if ok {
    // merged - это [10, 30)
}
```

Обратите внимание, что здесь мы допускаем объединение “соприкасающихся” сегментов `[10, 20)` и `[20, 30)`.

### Пересечение (intersection) сегментов

Фактически нам часто нужен не просто факт пересечения, а сам результирующий сегмент.

```go
// Intersection возвращает пересечение двух сегментов.
// Если пересечения нет - возвращает пустой сегмент и false.
func (s Segment[T]) Intersection(other Segment[T]) (Segment[T], bool) {
    start := max(s.Start, other.Start)
    end := min(s.End, other.End)

    if start >= end {
        // Здесь нет общей части - пересечение пустое
        return Segment[T]{Start: start, End: start}, false
    }

    return Segment[T]{Start: start, End: end}, true
}
```

Пример:

```go
s1, _ := NewSegment[int](10, 25)
s2, _ := NewSegment[int](20, 30)

inter, ok := s1.Intersection(s2)
if ok {
    // inter - это [20, 25)
}
```

Здесь я специально показываю логику через min и max, чтобы вам было проще mentally “прокрутить” решение на бумаге.

### Вычитание сегментов (difference)

Иногда нужно “вычесть” один сегмент из другого. Например, есть основной диапазон и в нем “вычеркиваются” исключения.

```go
// Difference вычитает other из s.
// Возвращает до двух сегментов - левую и правую части, которые остаются после вычитания.
func (s Segment[T]) Difference(other Segment[T]) []Segment[T] {
    // Если пересечения нет - вернем исходный сегмент
    if !s.Intersects(other) {
        return []Segment[T]{s}
    }

    var result []Segment[T]

    // Левая часть - если начало s меньше начала other
    if s.Start < other.Start {
        left := Segment[T]{Start: s.Start, End: other.Start}
        result = append(result, left)
    }

    // Правая часть - если конец s больше конца other
    if s.End > other.End {
        right := Segment[T]{Start: other.End, End: s.End}
        result = append(result, right)
    }

    // Если other полностью покрывает s - result будет пустым
    return result
}
```

Пример использования:

```go
base, _ := NewSegment[int](10, 30)
cut, _ := NewSegment[int](15, 20)

rest := base.Difference(cut)
// Здесь rest будет содержать два сегмента - [10, 15) и [20, 30)
```

Теперь вы видите, как можно поэтапно “вычитать” из базового диапазона различные поддиапазоны.

## Работа с наборами сегментов

В реальных задачах чаще работают не с одним сегментом, а с наборами, которые:

- нужно упорядочить;
- объединить (схлопнуть) пересекающиеся и соприкасающиеся интервалы;
- искать для них пересечения с другими наборами.

### Нормализация наборов сегментов

Под нормализацией обычно понимают:

1. Сортировку сегментов по `Start`.
2. Объединение пересекающихся/соприкасающихся сегментов.

Такой набор называют “непересекающимся покрытием”. Давайте посмотрим, как это может выглядеть.

```go
// NormalizeSegments сортирует сегменты и объединяет пересекающиеся интервалы.
func NormalizeSegments[T constraints.Ordered](segments []Segment[T]) []Segment[T] {
    if len(segments) == 0 {
        // Здесь нечего нормализовывать
        return nil
    }

    // Сначала сортируем по Start
    sort.Slice(segments, func(i, j int) bool {
        return segments[i].Start < segments[j].Start
    })

    result := make([]Segment[T], 0, len(segments))
    current := segments[0]

    for i := 1; i < len(segments); i++ {
        next := segments[i]

        // Пытаемся объединить current и next
        merged, ok := current.Union(next)
        if ok {
            // Сегменты пересекаются или соприкасаются - схлопываем
            current = merged
        } else {
            // Сегменты разорваны - сохраняем текущий и переходим к следующему
            result = append(result, current)
            current = next
        }
    }

    // Не забываем добавить последний текущий сегмент
    result = append(result, current)

    return result
}
```

Здесь я разместил пример, чтобы вам было проще понять идею “схлопывания”.

Пример использования:

```go
segments := []Segment[int]{
    {Start: 10, End: 20},
    {Start: 18, End: 25},
    {Start: 30, End: 40},
    {Start: 25, End: 30},
}

normalized := NormalizeSegments(segments)
// В итоге normalized будет содержать два сегмента - [10, 25) и [25, 40) => [10, 40)
```

После нормализации вы получаете компактное представление диапазонов без лишних пересечений.

### Поиск пересечений наборов сегментов

Теперь давайте перейдем к задаче, которая встречается в фильтрации и аналитике: есть два набора сегментов, нужно найти их пересечение.

Алгоритм похож на “слияние” двух отсортированных массивов.

```go
// IntersectSegmentSets ищет пересечение двух наборов сегментов.
// Оба набора должны быть предварительно нормализованы и отсортированы.
func IntersectSegmentSets[T constraints.Ordered](
    a, b []Segment[T],
) []Segment[T] {
    var result []Segment[T]
    i, j := 0, 0

    for i < len(a) && j < len(b) {
        segA := a[i]
        segB := b[j]

        // Пытаемся получить пересечение текущих сегментов
        inter, ok := segA.Intersection(segB)
        if ok {
            // Если пересечение есть - добавляем в результат
            result = append(result, inter)
        }

        // Двигаем указатель в том массиве, у которого сегмент заканчивается раньше
        if segA.End < segB.End {
            i++
        } else {
            j++
        }
    }

    return result
}
```

Пример:

```go
a := NormalizeSegments([]Segment[int]{
    {Start: 0, End: 10},
    {Start: 20, End: 30},
})
b := NormalizeSegments([]Segment[int]{
    {Start: 5, End: 25},
})

inter := IntersectSegmentSets(a, b)
// Здесь inter будет содержать [5, 10) и [20, 25)
```

Такой подход очень полезен, когда вы хотите найти общую аудиторию нескольких условий, пересечение временных интервалов и т. п.

## Применение utils-segment в реальных задачах

Теперь давайте посмотрим на несколько прикладных сценариев, где utils-segment показывает себя особенно полезным.

### Фильтрация коллекций по сегментам

Допустим, у вас есть массив значений (например, ID или индексы), и вам нужно отфильтровать только те, которые попадают в заданный набор сегментов.

```go
// FilterBySegments оставляет в срезе values только элементы,
// которые попадают хотя бы в один сегмент из segments.
func FilterBySegments[T constraints.Ordered](
    values []T,
    segments []Segment[T],
) []T {
    // Для эффективности нормализуем сегменты один раз
    normalized := NormalizeSegments(segments)

    var result []T

    for _, v := range values {
        if valueInAnySegment(v, normalized) {
            result = append(result, v)
        }
    }

    return result
}

// valueInAnySegment проверяет, попадает ли значение в какой-либо сегмент.
// Реализация может использовать бинарный поиск для ускорения.
func valueInAnySegment[T constraints.Ordered](
    val T,
    segments []Segment[T],
) bool {
    // Здесь можно сделать бинарный поиск по Start
    // Чтобы пример был наглядным - используем простой линейный обход
    for _, s := range segments {
        if s.Contains(val) {
            return true
        }
    }
    return false
}
```

Пример использования:

```go
values := []int{5, 10, 15, 20, 25, 30}
segments := []Segment[int]{
    {Start: 10, End: 20},
    {Start: 25, End: 35},
}

filtered := FilterBySegments(values, segments)
// filtered будет содержать 10, 15, 25, 30
```

Здесь вы сразу видите типичный паттерн: нормализуем сегменты, а потом уже используем их в различных операциях.

### Временные окна и аналитика

При работе с логами и метриками часто нужно оперировать временными интервалами.

Пример: у вас есть события с меткой времени, и вы хотите оставить только те, которые попадают в “окно пиковых нагрузок”.

```go
type Event struct {
    Timestamp time.Time // Время события
    Value     int       // Какое-то числовое значение
}

// FilterEventsByTimeSegments фильтрует события по временным сегментам.
func FilterEventsByTimeSegments(
    events []Event,
    segments []Segment[time.Time],
) []Event {
    normalized := NormalizeSegments(segments)
    var result []Event

    for _, e := range events {
        if valueInAnySegment(e.Timestamp, normalized) {
            result = append(result, e)
        }
    }

    return result
}
```

Давайте разберемся на примере:

```go
start1 := time.Date(2025, 1, 1, 10, 0, 0, 0, time.UTC)
end1 := start1.Add(time.Hour)

start2 := time.Date(2025, 1, 1, 18, 0, 0, 0, time.UTC)
end2 := start2.Add(2 * time.Hour)

segments := []Segment[time.Time]{
    {Start: start1, End: end1},   // Окно 10:00–11:00
    {Start: start2, End: end2},   // Окно 18:00–20:00
}

events := []Event{
    {Timestamp: start1.Add(30 * time.Minute), Value: 1},  // Внутри первого окна
    {Timestamp: start1.Add(-time.Minute), Value: 2},      // До первого окна
    {Timestamp: start2.Add(time.Hour), Value: 3},         // Внутри второго окна
}

filtered := FilterEventsByTimeSegments(events, segments)
// В result останутся события с Value 1 и 3
```

Теперь вы увидели, как один и тот же API сегментов удобно переносится с чисел на время.

### Сегментация пользователей по ID

Еще один пример — сегментация пользователей по ID (например, для A/B‑тестов или rollout-фич).

Допустим, вам нужно разделить всех пользователей на три непересекающихся сегмента по ID:

- `A` — [0, 1_000_000)
- `B` — [1_000_000, 2_000_000)
- `C` — [2_000_000, +∞)

Вы можете описать это через utils-segment и затем просто проверять, в какой сегмент попадает конкретный пользователь.

```go
type User struct {
    ID   int    // Идентификатор пользователя
    Name string // Остальные поля нам здесь не важны
}

// AssignGroup по ID пользователя определяет, к какой группе он относится.
func AssignGroup(userID int) string {
    segA, _ := NewSegment[int](0, 1_000_000)
    segB, _ := NewSegment[int](1_000_000, 2_000_000)
    segC := Segment[int]{Start: 2_000_000, End: int(^uint(0) >> 1)} // Условный "максимум"

    switch {
    case segA.Contains(userID):
        return "A"
    case segB.Contains(userID):
        return "B"
    case segC.Contains(userID):
        return "C"
    default:
        // На практике этот кейс почти недостижим
        return "unknown"
    }
}
```

Обратите внимание, как этот фрагмент кода решает задачу чистого разделения на группы: логика сегментации становится явной и легко читаемой.

## Рекомендации по проектированию с использованием utils-segment

### Явно выбирайте модель границ

Перед тем как активно использовать сегменты, важно для себя зафиксировать:

- Используете ли вы `[Start, End)` или `[Start, End]`.
- Что означает “пустой” сегмент.
- Как вы интерпретируете касающиеся интервалы.

В utils-segment имеет смысл придерживаться одной модели — чаще всего `[Start, End)`. Это:

- избавляет от неоднозначностей при объединении и пересечении;
- хорошо сочетается с индексами срезов (`a[start:end]`);
- упрощает рассуждения о пустых и граничных сегментах.

Если вы все же хотите использовать закрытые интервалы `[Start, End]`, нужно:

- аккуратно адаптировать все функции;
- внимательно относиться к операциям `Intersection`, `Union` и `Difference`.

### Следите за сортировкой и нормализацией наборов

Для работы с наборами сегментов (особенно при пересечении наборов) критично важно, чтобы:

- сегменты были отсортированы по `Start`;
- сегменты не пересекались и не соприкасались (были нормализованы).

Рекомендуется:

- сразу после загрузки/конфигурации сегментов пропускать их через `NormalizeSegments`;
- внутри бизнес‑функций предполагать, что на вход всегда приходит нормализованный набор.

Это упрощает реализацию и повышает предсказуемость поведения.

### Выносите “сложную математику” в отдельный слой

Если вы используете сложную логику сегментации (много вычитаний, объединений, вложенных пересечений), полезно:

- вынести операции с сегментами в отдельный пакет или модуль;
- тестировать их отдельно, покрывая граничные случаи;
- не смешивать “математику сегментов” с бизнес‑логикой в одних и тех же функциях.

Тогда `utils-segment` становится вашим “двигателем”, а вся бизнес-логика опирается на уже проверенные абстракции.

### Тестируйте граничные случаи

Сегменты всегда крутятся вокруг границ, поэтому в тестах стоит уделить особое внимание:

- случаям, когда `Start == End` (пустые интервалы);
- сегментам, которые только соприкасаются (например, `[10, 20)` и `[20, 30)`);
- полностью вложенным сегментам (один интервал полностью внутри другого);
- сценариям без пересечения вообще.

Для каждой ключевой функции (`Contains`, `Intersects`, `Union`, `Intersection`, `Difference`, `NormalizeSegments`) полезно иметь отдельный набор тестов на такие случаи.

## Заключение

Сегмент utils, реализованный в виде библиотеки `utils-segment`, дает вам простую, но сильную абстракцию: интервал, с которым можно выполнять единообразные операции.

Вы увидели, как на основе одной структуры `Segment[T]` и нескольких функций можно:

- работать с числовыми, строковыми и временными диапазонами;
- проверять принадлежность значений интервалам;
- объединять и пересекать отрезки;
- вычитать подмножества и нормализовать наборы сегментов;
- строить прикладные решения — от фильтрации событий до сегментации пользователей.

Главная ценность utils-segment — в том, что вся “математика интервалов” становится централизованной и проверяемой. Вместо десятков ручных `if` по коду у вас появляется единый слой, который можно легко тестировать и переиспользовать.

Если вы последовательно применяете сегменты в проекте, код становится более предсказуемым, а ошибки на границах интервалов — менее вероятными.

## Частозадаваемые технические вопросы по теме статьи и ответы

### Как эффективно проверять принадлежность значения набору сегментов без линейного обхода?

Используйте бинарный поиск по отсортированным и нормализованным сегментам.

Мини-инструкция:

1. Нормализуйте массив сегментов: `segments := NormalizeSegments(segments)`.
2. Реализуйте функцию бинарного поиска по полю `Start`.
3. Найдите сегмент с максимальным `Start`, не превышающим `val`.
4. Проверьте `Contains` только для этого сегмента.

Так вы снижаете сложность с O(n) до O(log n).

---

### Как хранить сегменты в базе данных и восстанавливать их в коде?

Обычно используют две колонки: `start` и `end` нужного типа (int, timestamp и т. д.).

Мини-инструкция:

1. В БД создайте таблицу с полями `start`, `end`, при необходимости — `type` или `group`.
2. При чтении из БД маппьте строки в `Segment[T]`.
3. Сразу после загрузки вызывайте `NormalizeSegments` для набора.
4. Для сериализации в JSON/Proto выносите `Start` и `End` как отдельные поля.

---

### Как обрабатывать “открытые” границы (только левая или только правая)?

Используйте специальные значения или отдельный тип, который хранит флаг “открытости”.

Мини-инструкция:

1. Для числовых типов можно хранить “открытую” границу как `minValue`/`maxValue`.
2. Для времени — использовать “технический максимум” (например, `time.Unix(1<<63-1, 0)`).
3. Введите обертку `BoundedSegment`, где кроме `Start`/`End` есть флаги `LeftOpen`, `RightOpen`.
4. Внутри `Contains` учитывайте эти флаги при сравнении.

---

### Как правильно сравнивать и сортировать сегменты разных типов (int и time.Time) вместе?

Нельзя смешивать разные типы в одном generic‑сегменте. Нужен слой абстракции.

Мини-инструкция:

1. Определите интерфейс `ComparableSegment` с методами `StartAsFloat64`, `EndAsFloat64`, `ContainsFloat64`.
2. Для `Segment[int]` и `Segment[time.Time]` реализуйте адаптеры, приводящие значения к общей оси (например, секунды с начала эпохи).
3. Сортируйте и обрабатывайте массив `ComparableSegment` по этим числовым значениям.

---

### Как избежать ошибок при изменении логики границ (например, переход с [Start, End) на [Start, End])?

Вводите явный тип для модели интервала и не меняйте поведение “тихо”.

Мини-инструкция:

1. Создайте два разных типа: `HalfOpenSegment` и `ClosedSegment`.
2. Для каждого типа реализуйте свои методы `Contains`, `Intersection`, `Union`.
3. Не смешивайте их в одном API — используйте разные функции и сигнатуры.
4. Миграцию делайте через адаптеры: `ClosedToHalfOpen` и наоборот, с явной конверсией.